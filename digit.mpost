%
% digits
%
% die Bilder werden in der Form digit.xnn erzeugt,
% wobei x von 0 bis 9 läuft und nn von 00 bis 59.
%
% von 01 bis 30 Veränderung der alten Form, von 31 bis 59
% Veränderung zur neuen, bei 00 dann neue Form
%

outputtemplate := "%j-%c.mps";

numeric f;   % [f]rame index
numeric m;   % [m]orph factor
numeric t;   % [t]ension
numeric phi; % rotation angle [phi]
numeric u;   % [u]nit
u := 5cm;
numeric q;   % [q]adratic,"[q]ubic", or [q]artic factor
pair C;      % [C]enter of rotation
C := (0,0.425u);
pen pc;      % [p]en[c]ircle
pc := pencircle scaled 0.1u;
path tmppath;
numeric tmp;
pair aux[];

% symbolic variables
numeric LEFT, RIGHT, TOP, BOTTOM;
numeric BEGIN, END, JOINT, MID;
numeric L_ARC, R_ARC, U_ARC, D_ARC;
LEFT = 0;
RIGHT = 1;
TOP = 2;
BOTTOM = 3;
BEGIN = 4;
END = 5;
JOINT = 6;
MID = 7;
L_ARC = 8;
R_ARC = 9;
U_ARC = 10; % upper arc or upper part of arc
D_ARC = 11;

pair zero[], one[],   two[], three[], four[];
pair five[], six[], seven[], eight[], nine[];

%
% TODO:
%
% * Geschwindigkeit der Übergänge: langsam von der Ziffer weg, schnell zur nächsten hin
%   (eventuell nicht immer bei n30/n31?)


def draw_grid(expr u) =
    draw (-0.6u,-u) -- (-0.6u,1.7u) -- (0.6u,1.7u) -- (0.6u,-u) -- cycle;
    draw (-0.6u,0) -- (0.6u,0);
    draw (-0.6u,0.85u) -- (0.6u,0.85u);
    draw (-0.25u,-u)--(-0.25u,1.7u);
    draw (0.25u,-u)--(0.25u,1.7u);
enddef;

def accel(expr x) = sqrt x enddef;

def decel(expr x) = x*x enddef;

%
% Null
%

zero[TOP]    = (0,0.85u);
zero[BOTTOM] = (0,0);
zero[LEFT]   = (-0.25u,0.425u);
zero[RIGHT]  = zero[LEFT] xscaled -1;

beginfig(000);
   draw_grid(u);
   pickup pc;

   draw zero[TOP]
        .. zero[RIGHT]
        .. zero[BOTTOM]
        .. zero[LEFT]
        .. cycle;
endfig;

%
% Null -> Eins
%

one[BEGIN]  = (-0.25u,0.55u);
one[TOP]    = zero[TOP];
one[BOTTOM] = zero[BOTTOM];

for i = 001 upto 029:
    % 29 statt 30, um einen Glitch bei i=30 zu vermeiden
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := i/30;
       m := f;
       
       draw zero[TOP]
            ... (m/2)[zero[RIGHT],zero[LEFT]]
            ... zero[BOTTOM]
            ... (m/2)[zero[LEFT],zero[RIGHT]]
            ... cycle;
    endfig;
endfor

for i = 030 upto 059:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-30)/30;
       m := decel(f);

       draw m[one[TOP],one[BEGIN]]
            -- one[TOP]
            -- one[BOTTOM];
    endfig;
endfor

%
% Eins
%

beginfig(100);
   draw_grid(u);
   pickup pc;

   draw one[BEGIN]
        -- one[TOP]
        -- one[BOTTOM];
endfig;

%
% Eins -> Zwei
%

two[BEGIN] = one[BEGIN];
two[TOP]   = one[TOP];
two[R_ARC] = (0.225u,0.55u);
two[JOINT] = (-0.25u,0);
two[END]   = (0.25u,0);

for i = 101 upto 130:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-100)/30;
       m := decel(f);

       draw one[BEGIN]
            -- m[one[TOP],two[R_ARC]]
            -- m[one[BOTTOM],two[JOINT]];
    endfig;
endfor

for i = 131 upto 159:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       
       f := (i-130)/30;
       m := f; %accel(f);
       t := 1/sqrt(sqrt(m)); % zur Vermeidung einer Spitze im Scheitel der 2
       
       aux0 := (1/2)[two[BEGIN],two[R_ARC]];
       aux1 := m[aux0,two[TOP]];
       
       draw two[BEGIN]
            .. tension  t .. aux1
            .. tension  t .. two[R_ARC]
            .. tension 2t .. two[JOINT];
       draw two[JOINT]
            -- m[two[JOINT],two[END]];
    endfig;
endfor

%
% Zwei
%

beginfig(200);
   draw_grid(u);
   pickup pc;
   
   draw two[BEGIN]
        .. two[TOP]
        .. two[R_ARC]
        .. tension 2 .. two[JOINT];
   draw two[JOINT] -- two[END];
endfig;

%
% Zwei -> Drei
%

three[BEGIN] = (-0.25u,0.65u);
three[TOP]   = two[TOP];
three[U_ARC] = (0.25u,0.5u);
three[JOINT] = (-0.15u,0);
three[D_ARC] = (0.3u,-0.625u);
three[END]   = three[D_ARC] xscaled -1;

for i = 201 upto 230:
    beginfig(i);
       draw_grid(u);
       pickup pc;         
       f := (i-200)/30;
       m := decel(f);
       phi := -90m;

       draw two[BEGIN]
            .. two[TOP]
            .. two[R_ARC]
            .. tension 2 .. two[JOINT];
       draw two[JOINT]
            -- two[END] rotatedaround (two[JOINT],phi);
    endfig;
endfor

for i = 231 upto 259:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-230)/30;
       m := decel(f);
       t := 1/m;

       aux1 := two[END] rotatedabout (two[JOINT],-90);

       draw m[two[BEGIN],three[BEGIN]]
            .. three[TOP]
            .. m[two[R_ARC],three[U_ARC]]
            .. tension (2-m) .. m[two[JOINT],three[JOINT]];
       draw m[two[JOINT],three[JOINT]]
            .. m[two[JOINT],three[D_ARC]]
            .. m[aux1,three[END]];
    endfig;
endfor

%
% Drei
%

beginfig(300);
   draw_grid(u);
   pickup pc;

   draw three[BEGIN]
        .. three[TOP]
        .. three[U_ARC]
        .. three[JOINT];
   draw three[JOINT]
        .. three[D_ARC]
        .. three[END];
endfig;

%
% Drei -> Vier
%

four[LEFT]   = (-0.25u,0);
four[TOP]    = (0.25u,0.85u);
four[MID]    = four[LEFT] xscaled -1;
four[BOTTOM] = (0.25u,-0.75u);
four[RIGHT]  = (0.4u,0);

for i = 301 upto 330:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       
       f := (i-300)/30;
       m := f;
       t := 15*f*f; if t < 1: t := 1 fi;

       z1 = ((0.1f-0.35)*u,(0.65-0.65f)*u);
       z12 = ((0+0.25f)*u,0.85u);
       z2 = (0.25u,(0.5-0.5f)*u);
       z3 = (-0.15u,0);
       z34 = (0.3u,-0.625u);
       z4 = (-0.3u,-0.625u);

       % Der "Austrittswinkel" des unteren Bogens an der "Spitze"
       % wird ermittelt und wandert langsam gegen 0.
       tmppath := three[JOINT] .. three[D_ARC] .. three[END];
       aux0 := direction 0 of tmppath;

       phi := (1-m)*angle(aux0);

       draw m[three[BEGIN],four[LEFT]] 
            .. tension t .. m[three[TOP],four[TOP]]
            .. tension t .. m[three[U_ARC],four[MID]]
            .. tension t .. three[JOINT];
       draw three[JOINT]{dir phi}
            .. three[D_ARC]
            .. three[END];
    endfig;
endfor

for i = 331 upto 359:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       
       f := (i-330)/30;
       m := f;
       t := 15*f*f*f; if t < 1: t := 1 fi;

       draw four[LEFT]
            -- four[TOP]
            -- four[MID]
            -- m[three[JOINT],four[LEFT]]{right}
            .. tension t .. m[three[D_ARC],four[MID]]
            .. tension t .. m[three[END],four[BOTTOM]];
       draw four[MID]
            -- m[four[MID],four[RIGHT]];
    endfig;
endfor

%
% Vier
%
beginfig(400);
   draw_grid(u);
   pickup pc;
   
   draw four[RIGHT]
        -- four[LEFT]
        -- four[TOP]
        -- four[BOTTOM];
endfig;

%
% Vier -> Fünf
%

five[BEGIN] = four[TOP];
five[LEFT]  = five[BEGIN] xscaled -1;
five[JOINT] = four[LEFT];
five[U_ARC] = (0,0.1u);
five[R_ARC] = (0.3u,-0.425u);
five[END]   = (-0.3u,-0.75u);
   
for i = 401 upto 430:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-400)/30;
       m := f;

       draw four[TOP]
            -- four[LEFT]
            -- m[four[RIGHT],four[MID]];
       draw m[four[TOP],four[MID]]
            -- four[BOTTOM];
    endfig;
endfor

for i = 431 upto 459:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-430)/30;
       t := 5-5*f; if t < 1: t := 1 fi;
       m := accel(f);

       draw five[BEGIN]
            -- m[four[TOP],five[LEFT]]
            -- five[JOINT]
            .. tension t .. m[four[MID],five[U_ARC]]
            .. tension 1 .. m[four[MID],five[R_ARC]]
            .. tension t .. if i>454: {left} fi m[four[BOTTOM],five[END]];
       %TODO: if-Anweisung durch Winkelberechnung glätten
    endfig;
endfor    

%
% Fünf
%
beginfig(500);
   draw_grid(u);
   pickup pc;

   draw five[BEGIN]
        -- five[LEFT]
        -- five[JOINT]
        .. five[U_ARC]
        .. five[R_ARC]
        .. {left}five[END];
endfig;

%
% Fünf -> Sechs
%

six[BEGIN]  = (0.25u,1.5u);
six[LEFT]   = zero[LEFT] xscaled 3/2;
six[RIGHT]  = zero[RIGHT] xscaled 3/2;
six[TOP]    = zero[TOP];
six[BOTTOM] = zero[BOTTOM];
   
for i = 501 upto 530:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-500)/30;
       m := f;

       aux1 := (xpart(five[LEFT]),ypart(m[five[BEGIN],six[BEGIN]]));
       
       draw m[five[BEGIN],six[BEGIN]]
            -- aux1
            -- m[five[JOINT],six[LEFT]];
       draw m[five[JOINT],six[LEFT]]
            .. m[five[U_ARC],six[TOP]]
            .. m[five[R_ARC],six[RIGHT]]
            .. {left}m[five[END],six[BOTTOM]]
            .. if i < 530:
                  m[five[END],six[LEFT]]
               else:
                  cycle
               fi;
    endfig;
endfor

for i = 531 upto 559:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-530)/30;
       t := 1/f;
       m := f;
            
       % wir ermitteln den Punkt, der auf 2/3 des gedachten Bogens liegt;
       % aux1 wandert von der linken Ecke der verschobenen "5" zum Zielpunkt.
       % Weil er dann auf dem Bogen liegt, kann er bei der "6" einfach
       % weggelassen weden.
       
       tmppath := six[LEFT]{up} .. six[BEGIN];
       aux23 := point 2/3 of tmppath;
       aux0 := (xpart(six[LEFT]),ypart(six[BEGIN]));
       aux1 := m[aux0,aux23];
       
       draw six[LEFT]{up}
            .. tension t .. aux1
            .. tension t .. six[BEGIN];
       draw six[TOP]
            .. six[RIGHT]
            .. six[BOTTOM]
            .. six[LEFT]
            .. cycle;
    endfig;
endfor

%
% Sechs
%
beginfig(600);
   draw_grid(u);
   pickup pc;
   
   % der Abstand vom Zentrum zur Schwungspitze in y-Richtung
   % ist bei der Sechs mit 1.5-0.425=1.075 geringer
   % als bei der Neun: 0.425-(-0.75)=1.175
   
   draw six[TOP]
        .. six[RIGHT]
        .. six[BOTTOM]
        .. six[LEFT]
        .. cycle;
   draw six[LEFT]{up}
        .. six[BEGIN];
endfig;

%
% Sechs -> Sieben (1/2)
%

seven[BEGIN] = (-0.3u,0.75u);
seven[LEFT]  = (-0.3u,0.85u);
seven[JOINT] = seven[LEFT] xscaled -1;
seven[MID]   = (0.1u,0.15u);
seven[END] = (0,-0.75u);

for i = 601 upto 630:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-600)/30;
       m := f;
       q := 3*m*m-3*m+1;
         % Parabelabschnitt y = 1 .. 1/4 .. 1 für x = 0 .. 0.5 .. 1;
       phi := 180m;
       
       z13 = (-0.375u,0.425u) rotatedaround (C,phi); % war z23
       z1 = (0.25u,(1q + 0.5)*u) rotatedaround (C,phi);
       z32 = (0.375u,0.425u) rotatedaround (C,phi/2);
       z2 = (0,0.85u) rotatedaround (C,phi/4);
       z3 = (0,(0+0.0m)*u) rotatedaround (C,3phi/4);
       z23 = ((-0.375+0.125m)*u,(0.425+0.075m)*u);
       % Nach der Rotation gilt:
       % z1'=(-0.25u,-0.65u);
       % z13'=(0.375u,0.425u);
       % z32'=(0,0.8u);
       % z2'=(-0.3,0.725); weil 0.425/sqrt(2)=0.30!
       % z3'=(0.3,0.725);
       
       draw z1 .. z13{dir (phi-90)} .. z3 ... z32  ... z2 ... z23; 
    endfig;
endfor

%
% Sechs -> Sieben (2/2)
%
for i = 631 upto 659:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-630)/30;
       t := 30 * f * f; if t < 1: t :=1 fi;
              
       z1 = (0.3u,(0.725+0.125f)*u); % war z3
       z21 = ((0.375-0.275f)*u,(0.425-0.275f)*u); % war z13
       z2 = ((-0.25+0.25f)*u,(-0.65-0.1f)*u); % war z1
       z13 = (-0.3u,(0.725+0.125f)*u); % war z2
       z3 = ((-0.25-0.05f)*u,(0.5+0.25f)*u); % war z23
       z32= (0,(0.8+0.05f)*u); % liegt dann genau zwischen neu z1 und z13 und fällt dann weg
       
       % Der Tangentenwinkel an z1↓ beträgt näherungsweise 135° und soll auf 90°=up verkürzt werden
       draw z2 .. z21 .. z1{dir (135-45f)} .. tension t .. z32{dir 180} .. tension t .. z13 .. tension t .. z3;
    endfig;
endfor

%
% Sieben
%
beginfig(700);
   draw_grid(u);
   pickup pc;
   
   z1 = (0.3u,0.85u);
   z21 = (0.1u,0.15u);
   z2 = (0u,-0.75u);
   z13 = (-0.3u,0.85u);
   z3 = (-0.3u,0.75u);
      
   %draw z2 .. z21 .. z1{up} -- z13 -- z3;
   draw seven[BEGIN]
        -- seven[LEFT]
        -- seven[JOINT]{down}
        .. seven[MID]
        .. seven[END];
endfig;

%
% Sieben -> Acht (1/2)
%

eight[MID] = (0,0.85u);
eight[L_ARC] = (-0.3u,1.25u);
eight[R_ARC] = eight[L_ARC] xscaled -1;
eight[LEFT] = (-0.4u,0.35u);
eight[RIGHT] = eight[LEFT] xscaled -1;
eight[BOTTOM] = zero[BOTTOM];

for i = 701 upto 730:
    beginfig(i);  
       draw_grid(u);
       pickup pc;
       f := (i-700)/30;
       
       z1 = (0.3u,0.85u);
       z21 = (0.1u,0.15u);
       z2 = (0u,-0.75u);
       z13 = (-0.3u,0.85u);
       z3 = (-0.3u,(0.75+0.1f)*u); % wandert zu z31 und ersetzt diesen
         
       tmppath := z2 .. tension 1 .. z21 .. tension 1 .. z1{up} -- z13 -- z3; % Die "Sieben"
       
       aux0 := ((-infinity,0)--(infinity,0)) intersectionpoint tmppath;
       tmp := xpart(aux0);
       
       z4 = (tmp+(-0.25u-tmp)*f,0);
       z5 = (tmp+(0.25u-tmp)*f,0);
       
       draw tmppath;
       draw z4 -- z5;
    endfig;
endfor

%
% Sieben -> Acht (2/2)
%
for i = 731 upto 759:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-730)/30;
       m := decel( f);
       t := 1/f; 
       tt := t/2; if tt < 1: tt := 1 fi;
       
       % schiebe um 0.85u nach oben
       z1 = (0.3u,(0.85-0.5m+0.85m)*u);
       z21 = ((0.1-0.5m)*u,(0.15-0.65m+0.85m)*u);
       z2 = (0.4m*u,(-0.75+0.25m+0.85m)*u);
       z3 = (-0.3u,(0.85-0.35m+0.85m)*u);       
       z4 = ((-0.25-0.05m)*u,(0.35m+0.85m)*u);
       z45 = (0,0.85m*u);
       z5 = ((0.25+0.15m)*u,(-0.5m+0.85m)*u);
       
       draw z2 .. z21 .. z1{up} .. tension t .. z3;
       draw z4{down} .. tension tt .. z45 .. tension tt .. {down}z5;
    endfig;
endfor

%
% Acht
%
beginfig(800);
   draw_grid(u);
   pickup pc;
   
   z12 = z34 = (0,0.85u); % war z45
   z1 = (0.3u,1.25u);
   z2 = (-0.4u,0.35u); % war z21
   z3 = (0.4u,0.35u);
   z4 = (-0.3u,1.25u);
   z23 = (0,0);
   
   %draw z1 .. z12 .. z2 .. z23 .. z3 .. z34 .. z4 .. cycle;
   draw eight[R_ARC]
        .. eight[MID]
        .. eight[LEFT]
        .. eight[BOTTOM]
        .. eight[RIGHT]
        .. eight[MID]
        .. eight[L_ARC]
        .. cycle;
endfig;

%
% Acht -> Neun (1/2)
%
nine[TOP]  = six[TOP];
nine[LEFT] = six[LEFT];
nine[RIGHT] = six[RIGHT];
nine[BOTTOM] = six[BOTTOM];
nine[END] = (-0.25u,-0.75u);

for i = 801 upto 830:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-800)/30;
       m := f;
       phi := -90m*m;
       
       z12 = z34 = (0,(0.85-0.05m)*u) rotatedabout (C,phi);
       z1 = ((0.3-0.3m)*u,(1.25-0.45m)*u) rotatedabout (C,phi);
       z2 = ((-0.4-0.025m)*u,(0.35+0.125m)*u) rotatedabout (C,phi);
       z23 = (0,(0+0.05m)*u) rotatedabout (C,phi);
       z3 = ((0.4+0.025m)*u,(0.35+0.125m)*u) rotatedabout (C,phi);
       z4 = ((-0.3+0.3m)*u,(1.25-0.45m)*u) rotatedabout (C,phi);
       
       % Wir ändern die Punktreihenfolge, um bei i=830 eine geschlossene Schleife
       % zu bekommen:
       draw z2 .. z23 .. z3 .. z34 .. if i < 830: z4 .. z1 .. z12 .. fi cycle;
    endfig;
endfor

%
% Acht -> Neun (2/2)
%
for i = 831 upto 859:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-830)/30;
       m := accel(f);
              
       z23 = (-0.375u,0.425u);         
       z32 = (0.375u,0.425u); % war z12 und z34
       z1 = ((0.425-0.675m*m)*u,(0.425-1.175m)*u);
       z2 = (0,0.85u);
       z3 = (0,0);
       
       draw z2 .. z23 .. z3 .. z32  .. cycle;
       draw z32{down} .. z1;
    endfig;
endfor


%
% Neun
%
beginfig(900);
   draw_grid(u);
   pickup pc;
            
   z23 = (-0.375u,0.425u);         
   z32 = (0.375u,0.425u);
   z1 = (-0.25u,-0.75u);
   z2 = (0,0.85u);
   z3 = (0,0);
      
   %draw z2 .. z23 .. z3 .. z32  .. cycle;
   %draw z32{down} .. z1;
   draw nine[TOP]
        .. nine[RIGHT]
        .. nine[BOTTOM]
        .. nine[LEFT]
        .. cycle;
   draw nine[RIGHT]{down}
        .. nine[END];
endfig;

%
% Neun -> Null (1/2)
%
for i = 901 upto 930:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-900)/30;
       m := decel(f);
       q := -4*f*f+4f+1; % Scheitel bei (0.5,2), f(0)=f(1)=1
       
       z23 = (-0.375u,0.425u);
       z32 = (0.375u,0.425u);
       z1 = ((-0.25-0.125q)*u,(-0.75+1.175m)*u);
       z2 = (0,0.85u);
       z3 = (0,0);
       
       draw z2 .. z23 .. z3 .. z32  .. cycle;
       draw z32{down} .. if i > 925 : z3 .. fi z1;
    endfig;
endfor

%
% Neun -> Null (2/2)
%
for i = 931 upto 959:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-930)/30;
       m := accel(f);
       
       z32 = ((0.375-0.125m)*u,0.425u);
       z23 = ((-0.375+0.125m)*u,0.425u);
       z2 = (0,0.85u);
       z3 = (0,0);
       
       draw z2 .. z23 .. z3 .. z32  .. cycle;
    endfig;
endfor

end;
