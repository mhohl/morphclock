%
% digits
%
% die Bilder werden in der Form digit.[1]ftnn erzeugt:
% f = "from": Startziffer
% t = "to":   Endziffer
% nn : laufende Nummer
%
% Für die Anzeige der Uhrzeit sind folgende Übergänge notwendig:
%
% 0 -> 1: 01nn
% 1 -> 2: 12nn
% 2 -> 3: 23nn
% ...
% 9 -> 0: 90nn
%
% sowie zusätzlich:
%
% 1 -> 0: 10nn (Zehnerstelle Stunden: 12am -> 01pm)
% 2 -> 0: 20nn (Zehnerstelle Stunden: 23:59 -> 00:00)
% 2 -> 1  21nn (Einerstelle Stunden: 12am -> 01pm)
% 3 -> 0: 30nn (Einerstelle Stunden:  23:59 -> 00:00)
% 5 -> 0: 50nn (Zehnerstelle Minuten: 10:59 -> 11:00)
%
% Die "1" als Zehntausenderstelle kodiert die Nicht-Ziffern:
%
% a <-> p
% m
% :
% für die Übergänge am <-> pm und den Doppelpunkt
%

outputtemplate := "%j-%c.mps";

warningcheck := 0; % unterdrückt Fehlermeldungen für i > 4096 bei beginfig(i);

numeric f;      % [f]rame index
numeric m;      % [m]orph factor
numeric t;      % [t]ension
numeric phi[];  % rotation angle [phi1]
numeric u;      % [u]nit
u := 5cm;
numeric q;      % [q]adratic factor
pair C;         % [C]enter of rotation
C := (0,0.425u);
pen pc;         % [p]en[c]ircle
pc := pencircle scaled 0.1u;
path tmppath[]; % [t]e[mp]orary [path]
numeric tmp[];  % [t]e[mp]orary variable
pair aux[];     % [aux]iliary points;

picture tmppic; % [t]e[mp]orary [pic]ture

% symbolische Variablen
numeric LEFT, RIGHT, TOP, BOTTOM;
numeric BEGIN, END, JOINT, MID;
numeric L_ARC, R_ARC, U_ARC, D_ARC;
LEFT   = 1000;
RIGHT  = 1001;
TOP    = 1002;
BOTTOM = 1003;
BEGIN  = 1004;
END    = 1005;
JOINT  = 1006;
MID    = 1007;
L_ARC  = 1008; % [l]eft (part of) [arc]
R_ARC  = 1009; % [r]ight (part of) [arc]
U_ARC  = 1010; % [u]pright (part of) [arc]
D_ARC  = 1011; % [d]ownright (part of) [arc]

% Arrays für die Koordinaten der Ziffern …
pair zero[], one[],   two[], three[], four[];
pair five[], six[], seven[], eight[], nine[];
% … und die anderen Zeichen
pair _a_[], _p_[], _m_[], colon[];

%
% TODO:
%
% * for-Schleifen parametrisieren: for i = startIndex[45] upto midIndex[45]
%

numeric draft; draft := 1;

def draw_grid(expr u) =
    if draft > 0:
      draw (-0.6u,-u) -- (-0.6u,1.7u) -- (0.6u,1.7u) -- (0.6u,-u) -- cycle;
      draw (-0.6u,0) -- (0.6u,0);
      draw (-0.6u,0.85u) -- (0.6u,0.85u);
      draw (-0.25u,-u)--(-0.25u,1.7u);
      draw (0.25u,-u)--(0.25u,1.7u);
    fi
enddef;

path boundingpath;
boundingpath := (-0.6u,-u)
                -- (-0.6u,1.7u)
                -- (0.6u,1.7u)
                -- (0.6u,-u)
                -- cycle;

vardef advanced(expr xx) = sind(90xx) enddef;
vardef retarded(expr xx) = 1 - cosd(90xx) enddef;

%
% Null
%
zero[TOP]    = (0,0.85u);
zero[BOTTOM] = (0,0);
zero[LEFT]   = (-0.25u,0.425u);
zero[RIGHT]  = zero[LEFT] xscaled -1;

beginfig(0100);
   draw_grid(u);
   pickup pc;

   draw zero[TOP]
        .. zero[RIGHT]
        .. zero[BOTTOM]
        .. zero[LEFT]
        .. cycle;
   setbounds currentpicture to boundingpath;
endfig;

%
% Null -> Eins
%
one[BEGIN]  = (-0.25u,0.55u);
one[TOP]    = zero[TOP];
one[BOTTOM] = zero[BOTTOM];

for i = 0101 upto 0130:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-0100)/30;
       m := retarded(f);

       if m < 1:
          draw zero[TOP]
               ... (m/2)[zero[RIGHT],zero[LEFT]]
               ... zero[BOTTOM]
             ... (m/2)[zero[LEFT],zero[RIGHT]]
             ... cycle;
       else:
          % für m = 1 entstünden seltsame Schlaufen
          draw one[TOP] -- one[BOTTOM];
       fi
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = 0131 upto 0159:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-0130)/30;
       m := advanced(f);

       draw m[one[TOP],one[BEGIN]]
            -- one[TOP]
            -- one[BOTTOM];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% Eins
%
beginfig(1200);
   draw_grid(u);
   pickup pc;

   draw one[BEGIN]
        -- one[TOP]
        -- one[BOTTOM];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;
% 1 -> 0
beginfig(1000);
   draw tmppic;
endfig;

%
% Eins -> Zwei
%
two[BEGIN] = one[BEGIN];
two[TOP]   = one[TOP];
two[R_ARC] = (0.225u,0.55u);
two[JOINT] = (-0.25u,0);
two[END]   = (0.25u,0);

for i = 1201 upto 1230:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-1200)/30;
       m := retarded(f);

       draw one[BEGIN]
            -- m[one[TOP],two[R_ARC]]
            -- m[one[BOTTOM],two[JOINT]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = 1231 upto 1259:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-1230)/30;
       m := advanced(f);
       t := 1/sqrt(sqrt(m)); % zur Vermeidung einer Spitze im Scheitel der 2

       aux[MID] := (1/2)[two[BEGIN],two[R_ARC]];
       aux[TOP] := m[aux[MID],two[TOP]];

       draw two[BEGIN]
            .. tension  t .. aux[TOP]
            .. tension  t .. two[R_ARC]
            .. tension 2t .. two[JOINT]
          & two[JOINT]
            -- m[two[JOINT],two[END]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% Zwei
%
beginfig(2300);
   draw_grid(u);
   pickup pc;

   draw two[BEGIN]
        .. two[TOP]
        .. two[R_ARC]
        .. tension 2 .. two[JOINT]
      & two[JOINT] -- two[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;
% 2 -> 0
beginfig(2000);
   draw tmppic;
endfig;
% 2 -> 1
beginfig(2100);
   draw tmppic;
endfig;

%
% Zwei -> Drei
%
three[BEGIN] = (-0.25u,0.65u);
three[TOP]   = two[TOP];
three[U_ARC] = (0.25u,0.5u);
three[JOINT] = (-0.15u,0);
three[D_ARC] = (0.3u,-0.625u);
three[END]   = three[D_ARC] xscaled -1;

for i = 2301 upto 2330:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-2300)/30;
       m := retarded(f);
       phi1 := -90m;

       draw two[BEGIN]
            .. two[TOP]
            .. two[R_ARC]
            .. tension 2 .. two[JOINT]
          & two[JOINT]
            -- two[END] rotatedaround (two[JOINT],phi1);
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = 2331 upto 2359:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-2330)/30;
       m := advanced(f);
       t := 1/m;

       aux[END] := two[END] rotatedaround (two[JOINT],-90);

       draw m[two[BEGIN],three[BEGIN]]
            .. three[TOP]
            .. m[two[R_ARC],three[U_ARC]]
            .. tension (2-m) .. m[two[JOINT],three[JOINT]]
          & m[two[JOINT],three[JOINT]]
            .. m[two[JOINT],three[D_ARC]]
            .. m[aux[END],three[END]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% Drei
%
beginfig(3400);
   draw_grid(u);
   pickup pc;

   draw three[BEGIN]
        .. three[TOP]
        .. three[U_ARC]
        .. three[JOINT]
      & three[JOINT]
        .. three[D_ARC]
        .. three[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;
% 3 -> 0
beginfig(3000);
   draw tmppic;
endfig;

%
% Drei -> Vier
%
four[LEFT]   = (-0.25u,0);
four[TOP]    = (0.25u,0.85u);
four[MID]    = four[LEFT] xscaled -1;
four[BOTTOM] = (0.25u,-0.75u);
four[RIGHT]  = (0.4u,0);

for i = 3401 upto 3430:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-3400)/30;
       m := retarded(f);
       t := max(15f*f,1);

       % Der "Austrittswinkel" des unteren Bogens an der "Spitze"
       % wird ermittelt und wandert langsam gegen 0.
       tmppath0 := three[JOINT] .. three[D_ARC] .. three[END];
       aux0 := direction 0 of tmppath0;
       phi1 := (1-m)*angle(aux0);

       draw m[three[BEGIN],four[LEFT]]
            .. tension t .. m[three[TOP],four[TOP]]
            .. tension t .. m[three[U_ARC],four[MID]]
            .. tension t .. three[JOINT]
          & three[JOINT]{dir phi1}
            .. three[D_ARC]
            .. three[END];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = 3431 upto 3459:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-3430)/30;
       m := advanced(f);
       t := max(15*f*f*f,1);

       draw four[LEFT]
            -- four[TOP]
            -- four[MID]
            -- m[three[JOINT],four[LEFT]]{right}
            .. tension t .. m[three[D_ARC],four[MID]]
            .. tension t .. m[three[END],four[BOTTOM]];
       draw four[MID]
            -- m[four[MID],four[RIGHT]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% Vier
%
beginfig(4500);
   draw_grid(u);
   pickup pc;

   draw four[RIGHT]
        -- four[LEFT]
        -- four[TOP]
        -- four[BOTTOM];
   setbounds currentpicture to boundingpath;
endfig;

%
% Vier -> Fünf
%
five[BEGIN] = four[TOP];
five[LEFT]  = five[BEGIN] xscaled -1;
five[JOINT] = four[LEFT];
five[U_ARC] = (0,0.1u);
five[R_ARC] = (0.3u,-0.425u);
five[END]   = (-0.3u,-0.75u);

for i = 4501 upto 4530:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-4500)/30;
       m := retarded(f);

       draw four[TOP]
            -- four[LEFT]
            -- m[four[RIGHT],four[MID]];
       draw m[four[TOP],four[MID]]
            -- four[BOTTOM];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = 4531 upto 4559:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-4530)/30;
       m := advanced(f);
       t := max(5(1-m),1);

       % Der Pfad soll bei five[END] maximal waagrecht werden
       % und nicht nach rechts unten zeigen. Weil hier angle(...)
       % einen Vorzeichenwechsel hat, muss eine if-Anweisung her.
       tmppath0 := five[JOINT]
                   .. tension t .. m[four[MID],five[U_ARC]]
                   .. tension 1 .. m[four[MID],five[R_ARC]]
                   .. tension t .. m[four[BOTTOM],five[END]];
       aux4 := direction 4 of tmppath0;
       phi1 := angle(aux4); if phi1 > 0 : phi1 := -180; fi

       draw five[BEGIN]
            -- m[four[TOP],five[LEFT]]
            -- five[JOINT]
            .. tension t .. m[four[MID],five[U_ARC]]
            .. tension 1 .. m[four[MID],five[R_ARC]]
            .. tension t .. {dir phi1}m[four[BOTTOM],five[END]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% Fünf
%
beginfig(5600);
   draw_grid(u);
   pickup pc;

   draw five[BEGIN]
        -- five[LEFT]
        -- five[JOINT]
        .. five[U_ARC]
        .. five[R_ARC]
        .. {left}five[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;
% 5-> 0
beginfig(5000);
   draw tmppic;
endfig;

%
% Fünf -> Sechs
%
six[BEGIN]  = (0.25u,1.5u);
six[LEFT]   = zero[LEFT] xscaled 3/2;
six[RIGHT]  = zero[RIGHT] xscaled 3/2;
six[TOP]    = zero[TOP];
six[BOTTOM] = zero[BOTTOM];

for i = 5601 upto 5630:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-5600)/30;
       m := retarded(f);

       % die linke Ecke five[LEFT] wandert genauso schnell nach oben wie
       % five[BEGIN], aber die x-Koordinate bleibt unverändert:

       aux[LEFT] := (xpart(five[LEFT]),ypart(m[five[BEGIN],six[BEGIN]]));

       draw m[five[BEGIN],six[BEGIN]]
            -- aux[LEFT]
            -- m[five[JOINT],six[LEFT]];
       draw m[five[JOINT],six[LEFT]]
            .. m[five[U_ARC],six[TOP]]
            .. m[five[R_ARC],six[RIGHT]]
            .. {left}m[five[END],six[BOTTOM]]
            .. if i < 5630:
                  m[five[END],six[LEFT]]
               else:
                  cycle
               fi;
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = 5631 upto 5659:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-5630)/30;
       m := advanced(f);
       t := 1/m;

       % wir ermitteln den Punkt, der auf 2/3 des abschließenden Bogens liegt;
       % aux[MID] wandert von der linken Ecke der nach oben geschobenen "5"
       % zum Zielpunkt.
       % Weil er dann auf dem Bogen liegt, kann er bei der "6" einfach
       % weggelassen weden.

       tmppath0   := six[LEFT]{up} .. six[BEGIN];
       aux[END]   := point 2/3 of tmppath0;
       aux[BEGIN] := (xpart(five[LEFT]),ypart(six[BEGIN]));
       aux[MID]   := m[aux[BEGIN],aux[END]];

       draw six[LEFT]{up}
            .. tension t .. aux[MID]
            .. tension t .. six[BEGIN];
       draw six[TOP]
            .. six[RIGHT]
            .. six[BOTTOM]
            .. six[LEFT]
            .. cycle;
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% Sechs
%
beginfig(6700);
   draw_grid(u);
   pickup pc;

   draw six[TOP]
        .. six[RIGHT]
        .. six[BOTTOM]
        .. six[LEFT]
        .. cycle;
   draw six[LEFT]{up} .. six[BEGIN];
   setbounds currentpicture to boundingpath;
endfig;

%
% Sechs -> Sieben
%
seven[BEGIN] = (-0.3u,0.75u);
seven[LEFT]  = (-0.3u,0.85u);
seven[JOINT] = seven[LEFT] xscaled -1;
seven[MID]   = (0.1u,0.15u);
seven[END]   = (0,-0.75u);
% Hilfspunkt:
seven[TOP]   = (1/2)[seven[LEFT],seven[JOINT]];

for i = 6701 upto 6730:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-6700)/30;
       m := retarded(f);
       q := 2m*m-2*m+1;
         % Parabelabschnitt y = 1 .. 1/2 .. 1 für x = 0 .. 0.5 .. 1;
       phi1 := 180m;

       aux[MID]   := six[LEFT]   rotatedaround (C,phi1);
       aux[END]   := (six[BEGIN] yscaled q) rotatedaround (C,phi1);
       aux[TOP]   := six[RIGHT]  rotatedaround (C,phi1/2);
       aux[LEFT]  := six[TOP]    rotatedaround (C,phi1/4);
       aux[JOINT] := six[BOTTOM] rotatedaround (C,3phi1/4);
       aux[BEGIN] := six[LEFT] shifted (0.125m*u,0.075m*u);

       draw aux[BEGIN]
            ... aux[LEFT]
            ... aux[TOP]
            ... aux[JOINT]
            .. aux[MID]{dir (phi1+90)}
            .. aux[END];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = 6731 upto 6759:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-6730)/30;
       m := advanced(f);
       t := max(30m*m,1);

       % Der Tangentenwinkel an JOINT beträgt
       % näherungsweise -45° und soll zu -90°=down wandern
       % TODO: korrekt berechnen!
       phi1 := -45(m+1);

       draw m[aux[BEGIN],seven[BEGIN]]
            .. tension t .. m[aux[LEFT],seven[LEFT]]
            .. tension t .. m[aux[TOP],seven[TOP]]{right}
            .. tension t .. m[aux[JOINT],seven[JOINT]]{dir phi1}
            .. m[aux[MID],seven[MID]]
            .. m[aux[END],seven[END]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% Sieben
%
beginfig(7800);
   draw_grid(u);
   pickup pc;

   draw seven[BEGIN]
        -- seven[LEFT]
        -- seven[JOINT]{down}
        .. seven[MID]
        .. seven[END];
   setbounds currentpicture to boundingpath;
endfig;

%
% Sieben -> Acht
%
eight[MID]    = (0,0.85u);
eight[L_ARC]  = (-0.3u,1.25u);
eight[R_ARC]  = eight[L_ARC] xscaled -1;
eight[LEFT]   = (-0.4u,0.35u);
eight[RIGHT]  = eight[LEFT] xscaled -1;
eight[BOTTOM] = zero[BOTTOM];

for i = 7801 upto 7830:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-7800)/30;
       m := retarded(f);

       tmppath1 := m[seven[BEGIN],seven[LEFT]]
                   -- seven[LEFT]
                   -- seven[JOINT]{down}
                   .. seven[MID]
                   .. seven[END];

       aux[MID]   := ((-infinity,0)--(infinity,0)) intersectionpoint tmppath1;
       aux[LEFT]  := aux[MID] - (0.15u,0);
       aux[RIGHT] := aux[MID] + (0.15u,0);

       draw tmppath1;
       draw m[aux[MID],aux[LEFT]] -- m[aux[MID],aux[RIGHT]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = 7831 upto 7859:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-7830)/30;
       m := advanced(f);
       t := 1/f;
       tt := max(t/2,1);

       draw m[seven[END],eight[RIGHT]]
            .. m[seven[MID],eight[LEFT]]
            .. m[seven[JOINT],eight[R_ARC]]{up}
            .. tension t .. m[seven[LEFT],eight[L_ARC]];
       draw m[aux[LEFT],eight[L_ARC]]{down}
            .. tension tt .. m[aux[MID],eight[MID]]
            .. tension tt .. {down}m[aux[RIGHT],eight[RIGHT]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% Acht
%
beginfig(8900);
   draw_grid(u);
   pickup pc;

   draw eight[R_ARC]
        .. eight[MID]
        .. eight[LEFT]
        .. eight[BOTTOM]
        .. eight[RIGHT]
        .. eight[MID]
        .. eight[L_ARC]
        .. cycle;
   setbounds currentpicture to boundingpath;
endfig;

%
% Acht -> Neun
%
nine[TOP]    = six[TOP];
nine[LEFT]   = six[LEFT];
nine[RIGHT]  = six[RIGHT];
nine[BOTTOM] = six[BOTTOM];
nine[END]    = (-0.25u,-0.75u);

for i = 8901 upto 8930:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-8900)/30;
       m := retarded(f);
       phi1 := -90m*m;

       % Die Acht kippt um 90° nach rechts,
       % aus eight[MID] wird nine[RIGHT] etc.
       % Um zu skalieren, drehen wir daher
       % nine[RIGHT|LEFT|TOP|BOTTOM] um 90° nach links:

       aux[MID]    := nine[RIGHT]  rotatedaround (C,90);
       aux[BOTTOM] := nine[LEFT]   rotatedaround (C,90);
       aux[LEFT]   := nine[TOP]    rotatedaround (C,90);
       aux[RIGHT]  := nine[BOTTOM] rotatedaround (C,90);

       % Wir ändern die Punktreihenfolge, um bei i=830
       % eine geschlossene Schleife zu bekommen:

       tmppath1 := m[eight[LEFT],aux[LEFT]]
                   .. m[eight[BOTTOM],aux[BOTTOM]]
                   .. m[eight[RIGHT],aux[RIGHT]]
                   .. m[eight[MID],aux[MID]]
                   if i < 8930:
                      .. m[eight[L_ARC],aux[MID]]
                      .. m[eight[R_ARC],aux[MID]]
                      .. m[eight[MID],aux[MID]]
                   fi
                   .. cycle;

       draw tmppath1 rotatedaround (C,phi1);
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = 8931 upto 8959:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-8930)/30;
       m := advanced(f);

       % Der Endpunkt des Bogens wandert von nine[RIGHT] ausgehend am
       % tatsächlichen Bogen entlang:

       tmppath0 := nine[RIGHT]{down} .. nine[END];
       aux[END] := point m of tmppath0;

       draw nine[TOP]
            .. nine[RIGHT]
            .. nine[BOTTOM]
            .. nine[LEFT]
            .. cycle;
       draw nine[RIGHT]{down} .. aux[END];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% Neun
%
beginfig(9000);
   draw_grid(u);
   pickup pc;

   draw nine[TOP]
        .. nine[RIGHT]
        .. nine[BOTTOM]
        .. nine[LEFT]
        .. cycle;
   draw nine[RIGHT]{down} .. nine[END];
   setbounds currentpicture to boundingpath;
endfig;

%
% Neun -> Null
%
for i = 9001 upto 9030:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-9000)/30;
       m := retarded(f);

       % Der Bogen der Neun soll beim Aufwickeln ein bisschen
       % nach links gestreckt werden:

       q := -2m*m+2m+1; % durchläuft 1 .. 3/2 .. 1 für x = 0 .. 0.5 .. 1;
       aux[END] := m[nine[END],nine[LEFT]] xscaled q;

       % wir legen einen Hilfspunkt dort an, wo der untere Bogen die
       % y-Achse schneidet. Steigt der y-Wert des Hilfspunktes über
       % die Unterkante der geschlossenen Schleife, wird als y-Koordinate
       % die Unterkante der Schleife gewählt, um zu verhindern, dass
       % der Bogen beim "Aufwickeln" ins Innere der geschlossenen Schleife
       % ragt.

       tmppath0 := nine[RIGHT]{down} .. aux[END];
       aux0 := ((0,-infinity)--(0,infinity)) intersectionpoint tmppath0;
       tmp0 := ypart(aux0);
       tmp1 := ypart(nine[BOTTOM]);
       aux[MID] := (0,min(tmp0,tmp1));

       draw nine[TOP]
            .. nine[RIGHT]
            .. nine[BOTTOM]
            .. nine[LEFT]
            .. cycle;
       draw nine[RIGHT]{down}
            .. aux[MID]
            .. aux[END];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = 9031 upto 9059:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-9030)/30;
       m := advanced(f);

       draw zero[TOP]
            .. m[nine[RIGHT],zero[RIGHT]]
            .. zero[BOTTOM]
            .. m[nine[LEFT],zero[LEFT]]
            .. cycle;
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Spezielle Ziffernübergänge: 1 -> 0, 2 -> 0, 2 -> 1, 3 -> 0, 5 -> 0
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%
% Eins -> Null
%
for i = 1001 upto 1030:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-1000)/30;
       m := retarded(f);
       t := 1/m;

       tmppath1 := C -- one [TOP] -- one[BEGIN];

       draw subpath (0,2*(1-m)) of tmppath1;
       draw C -- m[one[BOTTOM],C];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = 1031 upto 1059:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-1030)/30;
       m := advanced(f);
       t := 1/m;

       draw m[C,zero[TOP]]
            .. m[C,zero[RIGHT]]
            .. m[C,zero[BOTTOM]]
            .. m[C,zero[LEFT]]
            .. cycle;
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% Zwei -> Null
%
for i = 2001 upto 2030:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-2000)/30;
       m := retarded(f);
       t := 2-m;

       tmppath0 := two[BEGIN] .. two[TOP] .. two[R_ARC];
       aux0     := direction 0 of tmppath0;
       phi1     := m[angle(aux0),90];

       draw m[two[BEGIN],zero[LEFT]]{dir phi1}
            .. m[two[TOP],zero[TOP]]
            .. m[two[R_ARC],zero[RIGHT]]
            .. tension t .. m[two[JOINT],zero[BOTTOM]];
       draw two[JOINT] -- two[END];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Ursprünglicher Winkel bei zero[BOTTOM] ist nicht
% von einem Parameter abhängig:
tmppath0 := zero[LEFT]{up}
                  .. zero[TOP]
                  .. zero[RIGHT]
                  .. zero[BOTTOM];
aux3 := direction 3 of tmppath0;

for i = 2031 upto 2059:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-2030)/30;
       m := advanced(f);

       phi1 := m[angle(aux3),-180];

       tmppath0 := zero[BOTTOM]{left} .. m[two[JOINT],zero[LEFT]];
       aux1     := direction 1 of tmppath0;
       phi2     := max(angle(aux1),90);

       draw zero[LEFT]{up}
            .. zero[TOP]
            .. zero[RIGHT]
            .. zero[BOTTOM]{dir phi1};
       draw m[two[END],zero[BOTTOM]]
            -- zero[BOTTOM]{left}
            .. m[two[JOINT],zero[LEFT]]{dir phi2};
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% Zwei -> Eins
%
for i = 2101 upto 2130:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-2100)/30;
       m := retarded(f);
       t := 10*m*m+1;

       %aux[TOP] entspricht dem Startpunkt der Eins, heruntergeklappt
       % an den Mittelstrich:
       aux[TOP]    := one[TOP] shifted (0,-length(one[BEGIN]-one[TOP]));
       % two[R_ARC] und two[JOINT|END] wandern waagrecht zum Mittelstrich:
       aux[MID]    := (xpart(one[TOP]),ypart(two[R_ARC]));
       aux[BOTTOM] := (xpart(one[TOP]),ypart(two[END]));

       if m < 1:
          draw m[two[BEGIN],aux[TOP]]
               .. tension t .. two[TOP]
               .. tension t .. m[two[R_ARC],aux[MID]]
               .. tension (t+1) .. m[two[JOINT],aux[BOTTOM]]
               -- m[two[END],aux[BOTTOM]];
       else:
          draw one[TOP] -- one[BOTTOM];
       fi
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = 2131 upto 2159:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-2130)/30;
       m := advanced(f);

       phi0 := -90-angle(one[BEGIN]-one[TOP]);
       phi1 := (1-m)*phi0;

       draw one[BEGIN] rotatedaround (one[TOP],phi1)
            -- one[TOP]
            -- one[BOTTOM];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% Drei -> Null
%
for i = 3001 upto 3030:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-3000)/30;
       m := retarded(f);

       % Übergang oberer Bogen Drei zur Dreiviertel-Null
       tmppath0 := three[BEGIN]
                   .. three[TOP]
                   .. three[U_ARC]
                   .. three[JOINT];
       aux0 := direction 0 of tmppath0;
       phi1 := m[angle(aux0),90];
       aux3 := direction 3 of tmppath0;
       phi2 := m[angle(aux3),-180];

       % Der untere Bogen soll zu einem senkrecht nach unten geklappten
       % Viertelsegment der Null werden:

       tmppath1 := zero[BOTTOM]{left} .. zero[LEFT]{up};
       phi0     := 270-angle(zero[LEFT]-zero[BOTTOM]);

       aux[JOINT] := m[three[JOINT],zero[BOTTOM]];
       aux[D_ARC] := (point 0.5 of tmppath1) rotatedaround (zero[BOTTOM],phi0);
       aux[END]   := zero[LEFT] rotatedaround (zero[BOTTOM],phi0);

       draw m[three[BEGIN],zero[LEFT]]{dir phi1}
            .. m[three[TOP],zero[TOP]]
            .. m[three[U_ARC],zero[RIGHT]]
            .. aux[JOINT]{dir phi2}
          & aux[JOINT]
            .. m[three[D_ARC],aux[D_ARC]]
            .. m[three[END],aux[END]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = 3031 upto 3059:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-3030)/30;
       m := advanced(f);

       phi1 := (1-m)*phi0;

       draw zero[LEFT]{up}
            .. zero[TOP]
            .. zero[RIGHT]
            .. zero[BOTTOM]{left}
            % Der Viertelbogen klappt nach oben:
          & tmppath1 rotatedaround (zero[BOTTOM],phi1);
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% Fünf -> Null
%
for i = 5001 upto 5030:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-5000)/30;
       m := retarded(f);

       tmppath0 := m[five[JOINT],zero[LEFT]]
                   .. m[five[U_ARC],zero[TOP]]
                   .. m[five[R_ARC],zero[RIGHT]]
                   .. {left}m[five[END],zero[BOTTOM]]
                   .. m[five[END],zero[LEFT]]{up};

       aux0 := direction 0 of tmppath0;
       phi1 := min(angle(aux0),90);

       draw m[five[BEGIN],five[LEFT]]
            -- five[LEFT]
            -- m[five[JOINT],zero[LEFT]]
          & m[five[JOINT],zero[LEFT]]{dir phi1}
            .. m[five[U_ARC],zero[TOP]]
            .. m[five[R_ARC],zero[RIGHT]]
            .. {left}m[five[END],zero[BOTTOM]]
            .. if i < 5630:
                  m[five[END],zero[LEFT]]{up}
               else:
                  cycle
               fi;
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = 5031 upto 5059:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-5030)/30;
       m := advanced(f);
       t := 1/m;

       draw zero[LEFT]
            -- m[five[LEFT],zero[LEFT]];
       draw zero[TOP]
            .. zero[RIGHT]
            .. zero[BOTTOM]
            .. zero[LEFT]
            .. cycle;
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Weitere Übergänge: a -> p, p -> a,
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%
% a
%

_a_[BEGIN]  = (-0.25u,0.6u);
_a_[TOP]    = zero[TOP];
_a_[R_ARC]  = _a_[BEGIN] xscaled -1;
_a_[JOINT]  = (0.25u,0.15u);
_a_[END]    = (0.325u,0);
_a_[L_ARC]  = _a_[JOINT] xscaled -1;
_a_[BOTTOM] = zero[BOTTOM];

beginfig(10100);
   draw_grid(u);
   pickup pc;

   tmppath1 := _a_[BEGIN]
               ..  _a_[TOP]
               ..  _a_[R_ARC]
               --- _a_[JOINT]
               .. _a_[END];
   aux0 := direction 2 of tmppath1;
   phi[R_ARC] := angle(aux0);
   % phi[R_ARC] wird für a -> p UND p -> a benötigt!

   tmppath2 := _a_[R_ARC]{dir phi[R_ARC]}
               .. _a_[L_ARC]
               .. _a_[BOTTOM]
               .. _a_[JOINT];
   % Der Schnitpunkt von a-"Bauch" und y-Achse wird
   % beim Übergang p -> a benötigt:
   _a_[MID] := tmppath2 intersectionpoint ((0,0.01u)--(0,infinity));

   draw tmppath1;
   draw tmppath2;
   setbounds currentpicture to boundingpath;
endfig;

_p_[BEGIN]  = (-0.325u,0.85u);
_p_[END]    = (-0.325u,-0.75u);
_p_[U_ARC]  = (-0.325u,0.6u); % [u]pper end of [arc]
_p_[D_ARC]  = (-0.325u,0.15u);
_p_[TOP]    = zero[TOP];
_p_[BOTTOM] = zero[BOTTOM];
_p_[RIGHT]  = (0.325u,0.425u);

%
% a -> p
%
for i = 10101 upto 10130:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-10100)/30;
       m := retarded(f);

       % Der Startpunkt vom "a" wandert nach links
       aux[BEGIN] := (xpart(m[_a_[BEGIN],_p_[END]]),ypart(_a_[BEGIN]));
       % Der "Bauch" wird im ersten Drittel der Frames eingezogen,
       % damit die Linie vorbeilaufen kann, ohne ihn zu berühren.

       tmp := 3m; if tmp >1 : tmp := 1; fi
       aux[L_ARC] := _a_[L_ARC] xscaled (1-(2/5)*tmp);

       tmppath1 := m[aux[BEGIN],_p_[END]]
                   ..  aux[BEGIN]{up}
                   ..  _a_[TOP]
                   ..  _a_[R_ARC]
                   --- _a_[JOINT]
                   ..  _a_[END];
       draw  subpath (0,5-m) of tmppath1;
       draw _a_[R_ARC]{dir phi[R_ARC]}
            .. aux[L_ARC]
            .. _a_[BOTTOM]
            .. _a_[JOINT];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = 10131 upto 10159:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-10130)/30;
       m := advanced(f);

       aux[BEGIN] := (xpart(_p_[END]),ypart(_a_[BEGIN]));
       aux[L_ARC] := _a_[L_ARC] xscaled 3/5;

       % Der Ansatzpunkt wandert am p-Bogen entlang bis zum
       % unteren Ansatz am senkrechten Stamm:
       tmppath1   := _p_[D_ARC]
                     --  m[aux[BEGIN],_p_[U_ARC]]
                     ..  _a_[TOP]
                     ..  m[_a_[R_ARC],_p_[RIGHT]]
                     --- m[_a_[JOINT],_p_[RIGHT]];
       aux[R_ARC] := point 3-3m of tmppath1;

       % Wir brauchen den Winkel am unteren Ansatz des p-Bogens:
       tmppath0 := _p_[D_ARC]
                   .. _p_[BOTTOM]
                   .. _p_[RIGHT]
                   .. _p_[TOP]
                   .. _p_[U_ARC];
       aux0 := direction 0 of tmppath0;
       phi[D_ARC] := angle(aux0);
       % phi[D_ARC] wird auch für die Transformation p -> a benötigt!

       % Ein Hilfspfad beschreibt den Weg von aux[L_ARC] -> _a_[BOTTOM]
       tmppath2    := aux[L_ARC] .. _a_[BOTTOM]{right};
       aux[BOTTOM] := point m of tmppath2;

       draw _p_[END] -- m[aux[BEGIN],_p_[BEGIN]];
       draw tmppath1;
       % Während der Ansatzpunkt wandert, verändert sich der Winkel:
       draw aux[R_ARC]{dir m[phi[R_ARC],phi[D_ARC]]}
            .. aux[BOTTOM]
            .. _a_[BOTTOM]
            .. m[_a_[JOINT],_p_[RIGHT]]{up};
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% p
%

beginfig(11000);
   draw_grid(u);
   pickup pc;

   draw _p_[BEGIN] -- _p_[END];
   draw _p_[U_ARC]
        .. _p_[TOP]
        .. _p_[RIGHT]
        .. _p_[BOTTOM]
        .. _p_[D_ARC];
   setbounds currentpicture to boundingpath;
endfig;

%
% a -> p
%
for i = 11001 upto 11030:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-11000)/30;
       m := retarded(f);
       phi0 := 180m;

       % nach einer Vierteldrehung hat der p-Strich bereits die
       % gewünschte Länge:
       tmp1 := 2m; if tmp1 > 1: tmp1 := 1; fi

       aux[END] := (xpart(_p_[END]),0);

       tmppath1 := _p_[BEGIN]
                   -- tmp1[_p_[END],aux[END]];
       tmppath2 := _p_[U_ARC]
                   .. _p_[TOP]
                   .. _p_[RIGHT]
                   .. _p_[BOTTOM]
                   .. _p_[D_ARC];

       draw tmppath1 rotatedaround (C,phi0);
       draw tmppath2 rotatedaround (C,phi0);
       setbounds currentpicture to boundingpath;
    endfig;
endfor

aux[MID]    := _p_[D_ARC]  rotatedaround (C,180);
aux[BEGIN]  := aux[END]    rotatedaround (C,180);
aux[R_ARC]  := _p_[U_ARC]  rotatedaround (C,180);
aux[JOINT]  := _p_[BEGIN]  rotatedaround (C,180);
aux[L_ARC]  := _p_[RIGHT]  rotatedaround (C,180);
aux[BOTTOM] := _p_[TOP]    rotatedaround (C,180);
aux[TOP]    := _p_[BOTTOM] rotatedaround (C,180);

for i = 11031 upto 11059:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-11030)/30;
       m := advanced(f);
       t := 10m+1;

       % phi[D_ARC] ist der Winkel am unteren Bogenansatz des P
       % und muss daher um 180° gedreht werden;
       % phi[R_ARC] ist der Winkel am Ansatzpunkt vom "a" (s.o.)
       phi0 := m[phi[D_ARC]-180,phi[R_ARC]];

       % der gedrehte und verkürzte p-"Stamm" wird zum oberen Bogen:
       tmppath1 := m[aux[JOINT],_a_[END]]
                   .. m[aux[JOINT],_a_[JOINT]]{up} % up/tension/up entspricht ---
                   .. tension t .. m[aux[R_ARC],_a_[R_ARC]]{up}
                   .. m[aux[MID],_a_[TOP]]
                   .. m[aux[BEGIN],_a_[BEGIN]];

       % der gedrehte p-Bogen wird zum a-"Bauch":
       tmppath2 := m[aux[MID],_a_[R_ARC]]{dir phi0}
                   .. m[aux[TOP],_a_[MID]]
                   .. m[aux[L_ARC],_a_[L_ARC]]
                   .. m[aux[BOTTOM],_a_[BOTTOM]]
                   .. m[aux[R_ARC],_a_[JOINT]];

       % die beiden Pfade überschneiden sich am Anfang sichtbar, daher
       % kürzen wir den "Bauch"-Pfad:
       aux0 := tmppath1 intersectiontimes tmppath2;

       draw tmppath1;
       draw subpath (ypart(aux0),4) of tmppath2;
       setbounds currentpicture to boundingpath;
    endfig;
endfor

end;
