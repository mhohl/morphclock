<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="last-modified" content="2017-03-02@09:07:06 CET" />
    <title>morphclock: glyphs</title>
    <style>

    .morph-svg-path {
      fill: none;
      stroke: black;
      stroke-linejoin: round;
      stroke-linecap: round;
      opacity: inherit;
    }
    </style>
  </head>
  <body>
    <script type='text/javascript' language='javascript' src='morphpaths.js'></script>
    <svg style="position:absolute; width:0; height:0">
      <defs>
        <linearGradient id="Gradient-1" x1="0" y1="0" x2="0" y2="100%" gradientUnits="userSpaceOnUse">
            <stop offset="0%" stop-color="red" />
            <stop offset="100%" stop-color="blue" />
        </linearGradient>
      </defs>
    </svg>
    <h1>morphclock: glyphs</h1>
        <h2>Die statischen Glyphen</h2>
            <div id="standalone"></div>
        <h2>Die Übergänge</h2>
            <div id="transition"></div>
        <h2>Die Uhr</h2>
            <div id="clock"></div>
    <h1>morphclock: Anwendungen</h1>
        <h2>morphlogo</h2>
            <div data-type="morphlogo"></div>
        <h2>morphdate</h2>
            <div data-type="morphdate" data-format="d/m/y"></div>
            <div data-type="morphdate"></div> <!-- ohne data-format -> default -->
        <h2>morphclock</h2>
            <div data-type="morphclock" data-format="hhmmss24"></div>
            <div data-type="morphclock" data-format="hhmm24"></div>
            <div data-type="morphclock"></div><!-- ohne data-format -> default -->

    <script type='text/javascript' language='javascript'>
       // der svg-namespace
       const xmlns = "http://www.w3.org/2000/svg";

       var currentTime;
       var h, m, s, t;

       /*
          das Glyph-Objekt:
          'type' bestimmt die Art des Glyphen (einzelner Buchstabe, Übergang oder Uhr),
          'div' das übergeordnete <div>-Element,
          'width' die Breite, sowie optimonal 'xpos' und/oder 'ypos', die – falls gesetzt –
          eine absolute Positionierung der Glyphen erlauben
       */
       var Glyph = class Glyph {
         constructor(type, div, width, xpos, ypos) {
           this.type  = type; this.prevtype  = type;
           this.morph = null; this.prevmorph = null;
           this.div = div;
           this.width = width;
           this.xpos = xpos; this.ypos = ypos;

           let svg = document.createElementNS (xmlns, "svg");
           svg.setAttribute('width', width);
           svg.setAttribute('viewBox', "0 0 " + morphpath.metainfo.width
                                        + " " + morphpath.metainfo.height);
           if (xpos || ypos ) {
              svg.setAttribute('style', "position: absolute; " +
                               "top: " + (ypos || "0px") + "; " +
                               "left: " + (xpos || "0px"));
           }
           div.appendChild(svg);
           morphpath[calcIdx(type, this.morph)].forEach(p => {
             svg.appendChild(buildPath(p));
           });
           this.svg = svg;
         }
       }
       /*
          update() verändert die path-Information nur, wenn dies wirklich
          notwendig ist
       */
       Glyph.prototype.update = function() {
         if (this.type  != this.prevtype ||
             this.morph != this.prevmorph) {
            let svg = this.svg;
            while (svg.firstChild) {
                  svg.removeChild(svg.firstChild);
            }
            morphpath[calcIdx(this.type, this.morph)].forEach(p => {
              svg.appendChild(buildPath(p));
            });
            this.svg = svg;
            this.prevtype  = this.type;
            this.prevmorph = this.morph;
         }
       }

       /*
          erstelle aus den gespeicherten Pfadinformationen ein
          <path>-Element
       */
       let buildPath = function (p) {
         const path = document.createElementNS (xmlns, "path");
         path.setAttribute('class', "morph-svg-path");
         path.setAttribute('stroke-width',
                           morphpath.metainfo['stroke-width']);
         path.setAttribute('stroke-linecap',
                           morphpath.metainfo['stroke-linecap']);
         path.setAttribute('stroke-linejoin',
                           morphpath.metainfo['stroke-linejoin']);
         path.setAttribute('stroke-miterlimit',
                           morphpath.metainfo['stroke-miterlimit']);
         path.setAttribute('fill:',
                           morphpath.metainfo['fill']);
         path.setAttribute ('d', p);
         return path;
       }
       /*
          Berechne den Index, unter dem das Element 'type'/'morph'
          zu finden ist;
          standalone-Glyphen haben ein einzelnes Zeichen als Index;
          Übergänge haben die Form ft-nn mit
             f als Startzeichen,
             t als Zielzeichen und der immer(!)
             zweistelligen Nummer nn nach dem Bindestrich als
             Morphfaktor;
          die Uhr ist unter clock-n indiziert, wobei n = 0...719
       */
       var calcIdx = function (type, morph) {
           let result = type;
           if (morph) {
               result = result + "-" + morph;
           }
           else if (type.length == 2) {
              // type zweistellig, kein morph
              result = result + "-00";
           }
           else if (type.length == 5) {
              // clock ohne morph
              result = result + "-0";
           }
           return result;
       }

       /*
          Einfache Beispiele:
          Wir verteilen die gesamten Pfade auf die drei Bereiche
          standalone, transition und clock:
       */
       const standalone = {};
       const transition = {};
       const clock = {};
       const exampleWidth = "12.5%";
       for (let key of Object.keys(morphpath)) {
           if (key.length == 1)
              standalone[key] = morphpath[key];
           else if (key.slice(4) == "clock")
              clock[key] = morphpath[key];
           else if (key.slice(2,5) == "-00")
              transition[key.slice(0,2)] = morphpath[key];
       }

       // die standalone-Glyphen
       const skeys = Object.keys(standalone).sort();
       const sglyphs = [];
       const sdiv = document.getElementById('standalone');
       for (let key of skeys) {
           sglyphs.push (new Glyph(key, sdiv, exampleWidth));
       }

       // die transition-Glyphen
       var tkeys = Object.keys(transition).sort();
       const tglyphs = [];
       const tdiv = document.getElementById('transition');
       for (let key of tkeys) {
           var tglyph = new Glyph(key, tdiv, exampleWidth);
           tglyphs.push(tglyph);
       }

       // die Uhr
       const cdiv = document.getElementById('clock');
       const cglyph = new Glyph('clock', cdiv, exampleWidth);
       // wir stellen die Uhr auf die aktuelle Zeit:
       currentTime = new Date;
       h = currentTime.getHours();
       m = currentTime.getMinutes();
       let clockstart = (h * 60 + m) % 720;
       cglyph.morph = clockstart;
       cglyph.update();

       /*
          Auswertung der morph-Elemente
       */
       const morphElements = {}; // Container für *alle* morph...-Objekte

       const morphDefault = { // Defaultwerte, falls data-format nicht angegeben ist
          format: {
            clock: "hhmmss12",
            date: "d.m.y",
            logo: "default",
          }
       }

       morphElements.clock = [];
       morphElements.date = [];
       morphElements.logo = [];

       let divs = document.body.getElementsByTagName("div");
       // wir durchsuchen alle <div>-Elements nach data-type="morph..."
       for (let i = 0; i < divs.length; i++ ) {

           let datatype = divs[i].getAttribute("data-type");

           // Zur Sicherheit genauer Check:
           if (datatype == "morphclock" ||
               datatype == "morphdate" ||
               datatype == "morphlogo") {
              let slot = datatype.slice(5); // morphclock -> clock etc.

              let entry = {
                  'format': divs[i].getAttribute("data-format") ||
                            morphDefault.format[slot],
                  'div': divs[i],
                  'glyphs': []
              };

              // dummy fill routine
              for (let j = 0; j < 10; j++) {
                  entry.glyphs.push(i*j);
              }

              // speichere entry im passenden slot
              morphElements[slot].push(entry);
           }
       }
       console.log(morphElements);

       // dummy-Schleife
       for (let slot in morphElements) {
           morphElements[slot].forEach(entry => {
             let div = entry.div;
             let format = entry.format;
             let glyphs = entry.glyphs;
             console.log(format, glyphs);
           });
       }

       function renderTime() {
         currentTime = new Date();
         s = currentTime.getSeconds();
         t = currentTime.getMilliseconds();

         var morph ="";

         setTimeout('renderTime()',10);

         tglyphs.forEach(g => {
           if (s % 3 == 0) morph = "00";
           if (s % 3 == 1) morph = quickMorph();
           if (s % 3 == 2) morph = "99";
           g.morph = morph;
           g.update();
         });
         // die Uhr läuft 60× schneller als gewöhnlich
         cglyph.morph = ((m * 60 + s) + clockstart) % 720;
         cglyph.update();
       }

      function quickMorph() {
        return doubleDigit(Math.floor(t/10));
      }

      function slowMorph(x) {
        return doubleDigit(Math.floor(((xS-x)*1000+t)/((10-x)*10)));
      }

      function doubleDigit(x) {
        return x < 10 ? x = "0" + x : x ;
      }
      renderTime();
    </script>

  </body>
</html>
