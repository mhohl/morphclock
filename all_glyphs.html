<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="last-modified" content="2017-03-02@09:07:06 CET" />
    <title>morphclock: glyphs</title>
    <link rel="stylesheet" type="text/css" href="morph.css">
  </head>
  <body>
    <script type='text/javascript' language='javascript' src='morphpaths.js'></script>
    <svg style="position:absolute; width:0; height:0">
      <defs>
        <linearGradient id="Gradient-1" x1="0" y1="0" x2="0" y2="100%" gradientUnits="userSpaceOnUse">
            <stop offset="0%" stop-color="red" />
            <stop offset="100%" stop-color="blue" />
        </linearGradient>
      </defs>
    </svg>
    <h1>morphclock: glyphs</h1>
        <h2>Die statischen Glyphen</h2>
            <div id="standalone"></div>
        <h2>Die Übergänge</h2>
            <div id="transition"></div>
        <h2>Die Uhr</h2>
            <div id="clock"></div>
    <h1>morphclock: Anwendungen</h1>
        <h2>morphlogo</h2>
            <div data-type="morphlogo"></div>
        <h2>morphdate</h2>
            <div data-type="morphdate" data-format="D/M/Y"></div>
            <div data-type="morphdate" data-format="Month D,Y"></div>
            <div data-type="morphdate" data-format="full"></div>
            <div data-type="morphdate"></div> <!-- ohne data-format -> default -->
        <h2>morphclock</h2>
            <div data-type="morphclock" data-format="hhmmss24"></div>
            <div data-type="morphclock" data-format="hhmm24"></div>
            <div data-type="morphclock"></div><!-- ohne data-format -> default -->

    <script type='text/javascript' language='javascript'>
       // der svg-namespace
       const xmlns = "http://www.w3.org/2000/svg";

       var currentTime;
       var h, m, s, t;
       /* MorphData enthält die Struktur der angezeigten Daten/Zeiten;
          in den Slots steht 'x' als Platzhalter für die unbeteiligte
          Stelle, und ein Buchstabe für:
          s Sekunde
          m Minute
          h Stunde
          c Doppelpunkt (colon)
          d Wechsel am/pm (day time)
          D Tag
          M Monat (zweistellig: in Ziffern, dreistellig: Abkürzung)
          Y Jahr
          W Wochentag (dreistellig als Abkürzung)

          Unter 'default' sind die Formate angegeben, die ohne explizite
          Vorgabe angezeigt werden.
       */

       const MorphData = {
             default: {
                clock: 'hhmmss24',
                date:  'D.M.Y',
                logo:  'default'
             },

             clock: {
                hhmmss24: [
                   { glyph: '20-00', slot: 'hx' },
                   { glyph: '30-00', slot: 'xh' },
                   { glyph: '::-00', slot: 'cx' },
                   { glyph: '50-00', slot: 'mx' },
                   { glyph: '90-00', slot: 'xm' },
                   { glyph: '::-00', slot: 'xc' },
                   { glyph: '50-00', slot: 'sx' },
                   { glyph: '90-00', slot: 'xs' }
                ],
                hhmm24: [
                   { glyph: '20-00', slot: 'hx' },
                   { glyph: '30-00', slot: 'xh' },
                   { glyph: '::-00', slot: 'xc' },
                   { glyph: '50-00', slot: 'mx' },
                   { glyph: '90-00', slot: 'xm' },
                ],
                hhmmss12: [
                   { glyph: '10-00', slot: 'hx' },
                   { glyph: '21-00', slot: 'xh' },
                   { glyph: '::-00', slot: 'cx' },
                   { glyph: '50-00', slot: 'mx' },
                   { glyph: '90-00', slot: 'xm' },
                   { glyph: '::-00', slot: 'xc' },
                   { glyph: '50-00', slot: 'sx' },
                   { glyph: '90-00', slot: 'xs' },
                   { glyph: '~',     slot: null },
                   { glyph: 'ap-00', slot: 'dx' },
                   { glyph: 'mm-00', slot: 'xd' }
                ],
                hhmm12: [
                   { glyph: '10-00', slot: 'hx' },
                   { glyph: '21-00', slot: 'xh' },
                   { glyph: '::-00', slot: 'xc' },
                   { glyph: '50-00', slot: 'mx' },
                   { glyph: '90-00', slot: 'xm' },
                   { glyph: '~',     slot: null },
                   { glyph: 'ap-00', slot: 'dx' },
                   { glyph: 'mm-00', slot: 'xd' }
                ],
             },

             date: {
                'D/M/Y': [
                   { glyph: '30-00', slot: 'Dx' },
                   { glyph: '11-00', slot: 'xD' },
                   { glyph: '/',     slot: null },
                   { glyph: '10-00', slot: 'Mx' },
                   { glyph: '21-00', slot: 'xM' },
                   { glyph: '/',     slot: null },
                   { glyph: '12-00', slot: 'Yxxx' },
                   { glyph: '90-00', slot: 'xYxx' },
                   { glyph: '90-00', slot: 'xxYx' },
                   { glyph: '90-00', slot: 'xxxY' },
                ],
                'D.M.Y': [
                   { glyph: '30-00', slot: 'Dx' },
                   { glyph: '11-00', slot: 'xD' },
                   { glyph: '.',     slot: null },
                   { glyph: '10-00', slot: 'Mx' },
                   { glyph: '21-00', slot: 'xM' },
                   { glyph: '.',     slot: null },
                   { glyph: '12-00', slot: 'Yxxx' },
                   { glyph: '90-00', slot: 'xYxx' },
                   { glyph: '90-00', slot: 'xxYx' },
                   { glyph: '90-00', slot: 'xxxY' },
                ],
                'D-M-Y': [
                   { glyph: '30-00', slot: 'Dx' },
                   { glyph: '11-00', slot: 'xD' },
                   { glyph: '-',     slot: null },
                   { glyph: '10-00', slot: 'Mx' },
                   { glyph: '21-00', slot: 'xM' },
                   { glyph: '-',     slot: null },
                   { glyph: '12-00', slot: 'Yxxx' },
                   { glyph: '90-00', slot: 'xYxx' },
                   { glyph: '90-00', slot: 'xxYx' },
                   { glyph: '90-00', slot: 'xxxY' },
                ],
                'Y/M/D': [
                   { glyph: '12-00', slot: 'Yxxx' },
                   { glyph: '90-00', slot: 'xYxx' },
                   { glyph: '90-00', slot: 'xxYx' },
                   { glyph: '90-00', slot: 'xxxY' },
                   { glyph: '/',     slot: null },
                   { glyph: '10-00', slot: 'Mx' },
                   { glyph: '21-00', slot: 'xM' },
                   { glyph: '/',     slot: null },
                   { glyph: '30-00', slot: 'Dx' },
                   { glyph: '11-00', slot: 'xD' }
                ],
                'Y-M-D': [
                   { glyph: '12-00', slot: 'Yxxx' },
                   { glyph: '90-00', slot: 'xYxx' },
                   { glyph: '90-00', slot: 'xxYx' },
                   { glyph: '90-00', slot: 'xxxY' },
                   { glyph: '-',     slot: null },
                   { glyph: '10-00', slot: 'Mx' },
                   { glyph: '21-00', slot: 'xM' },
                   { glyph: '-',     slot: null },
                   { glyph: '30-00', slot: 'Dx' },
                   { glyph: '11-00', slot: 'xD' }
                ],
                'Month D,Y': [
                   { glyph: 'dj-00', slot: 'Mxx' },
                   { glyph: 'ea-00', slot: 'xMx' },
                   { glyph: 'cn-00', slot: 'xxM' },
                   { glyph: '~',     slot: null },
                   { glyph: '30-00', slot: 'Dx' },
                   { glyph: '11-00', slot: 'xD' },
                   { glyph: ',',     slot: null },
                   { glyph: '12-00', slot: 'Yxxx' },
                   { glyph: '90-00', slot: 'xYxx' },
                   { glyph: '90-00', slot: 'xxYx' },
                   { glyph: '90-00', slot: 'xxxY' },
                ],
                'full': [
                   { glyph: 'fs-00', slot: 'Wxx' },
                   { glyph: 'ra-00', slot: 'xWx' },
                   { glyph: 'it-00', slot: 'xxW' },
                   { glyph: ',', slot: null },
                   { glyph: 'dj-00', slot: 'Mxx' },
                   { glyph: 'ea-00', slot: 'xMx' },
                   { glyph: 'cn-00', slot: 'xxM' },
                   { glyph: '~',     slot: null },
                   { glyph: '30-00', slot: 'Dx' },
                   { glyph: '11-00', slot: 'xD' },
                   { glyph: ',',     slot: null },
                   { glyph: '12-00', slot: 'Yxxx' },
                   { glyph: '90-00', slot: 'xYxx' },
                   { glyph: '90-00', slot: 'xxYx' },
                   { glyph: '90-00', slot: 'xxxY' },
                ],
             },

             logo: {
                default: [
                   { glyph: 'm',       slot: null },
                   { glyph: 'o',       slot: null },
                   { glyph: 'r',       slot: null },
                   { glyph: 'p',       slot: null },
                   { glyph: 'h',       slot: null },
                   { glyph: 'c',       slot: null },
                   { glyph: 'l',       slot: null },
                   { glyph: 'clock-0', slot: 'clock' },
                   { glyph: 'c',       slot: null },
                   { glyph: 'k',       slot: null }
                ]
             }
       };

       /*
          das MorphDisplay-Objekt
          'type' bestimmt den dargestellten Typ (clock, date, logo),
          'div' das <div>-Element, das die Glyphen aufnimmt, sowie
          'glyphs' ein Array der einzelnen Glyph-Objekte
       */

       var MorphDisplay = class MorphDisplay {
         constructor(type, div, glyphs, slots) {
           this.type = type;
           this.div = div;
           this.format = div.getAttribute("data-format") ||
                         MorphData.default[type];
           this.glyphs = glyphs || [];
           this.slots = slots || [];

           this.smallOverlap = 0.2;
           this.bigOverlap = 2 * this.smallOverlap;
         }

         get charWidth() {
           let n_of_chars = MorphData[this.type][this.format].length; // number of chars
           let n_of_sover = 0; // number of small overlaps
           let n_of_bover = 0; // number of big overlaps
           if (this.type == "logo") {
              n_of_sover = n_of_chars - 1; // n Zeichen -> n-1 Überlappungen
              n_of_bover = 0;
              console.log("calcCharWidth: logo", n_of_chars, n_of_sover, n_of_bover);
           }
           else if (this.type == "clock") {
              n_of_sover = 2; // zwei small overlaps, je einer für Stunden und Minuten
              n_of_bover = 2; // zwei big overlaps für den ':' vor den Minuten
              if (this.showDaytime) {
                 n_of_sover += 1; // small overlap zwischen 'a|p' and 'm'
                 n_of_bover += 2; // zwei big overlaps für das Leerzeichen vor 'am|pm'
              }
              if (this.showSeconds) {
                 n_of_sover += 1; // small overlap für die Sekunden
                 n_of_bover += 2; // zwei big overlaps für den ':' vor den Sekunden
              }
              console.log("calcCharWidth: clock", this.format, n_of_chars, n_of_sover, n_of_bover);
           }
           else if (this.type == "date" ) { // TODO: korrekte Berechnung
              n_of_sover = 2;
              n_of_bover = 2;
              console.log("calcCharWidth: date", this.format, n_of_chars, n_of_sover, n_of_bover);
           }
           return 100/(n_of_chars -
                  n_of_sover * this.smallOverlap -
                  n_of_bover * this.bigOverlap);
         }

         get charPos() {
           let positions = [];
           let pos = 0;
           let width = this.charWidth;
           positions.push(pos);
           let data = MorphData[this.type][this.format];
           if (this.type == "logo") {
              for (let i = 1, dlen = data.length; i < dlen; i++ ) {
                  pos += width*(1 - this.smallOverlap);
                  positions.push(pos);
              }
           }
           else if (this.type == "clock") { // TODO: korrekte Berechnung
              for (let i = 1, dlen = data.length; i < dlen; i++ ) {
                  pos += width*(1 - this.smallOverlap);
                  positions.push(pos);
              }
           }
           else if (this.type == "date") { // TODO: korrekte Berechnung
              for (let i = 1, dlen = data.length; i < dlen; i++ ) {
                  pos += width*(1 - this.smallOverlap);
                  positions.push(pos);
              }
           }
           return positions;
         }

         get height() {
             let children = this.div.children;
             if (children.length > 0)
                return children[0].getBoundingClientRect().height;
             return 0;
         }

         get showDaytime() {
             return (this.type == "clock") &&
                    (this.format.indexOf("12") > -1);
         }

         get showSeconds() {
             return (this.type == "clock") &&
                    (this.format.indexOf("ss") > -1);
         }

         get showMonth() {
             return (this.type == "date") &&
                    (this.slots.some(x => x == 'xMx'));
         }

         get showWeekday() {
             return (this.type == "date") &&
                    (this.slots.some(x => x == 'xWx'));
         }
       }

       MorphDisplay.prototype.createGlyphs = function() {
         let width = this.charWidth;
         let xpos = this.charPos;
         let data = MorphData[this.type][this.format];

         for (let i = 0, dlen = data.length; i < dlen; i++ ){
             let newglyph = new Glyph(data[i].glyph,
                                      this.div,
                                      width + "%",
                                      xpos.shift()+"%");

             let slot = data[i].slot || data[i].glyph;
             // data[i].slot ist null bei ungemorphten Glyphen
             newglyph.svg.setAttribute('class', this.type + "-" +
                                                this.format + "-" +
                                                slot);

             this.glyphs.push(newglyph);
             this.slots.push(slot);
         }
         // setze die Höhe des parent-div:
         this.div.style.height = this.height;
         return this;
       }

       /*
          das Glyph-Objekt:
          'type' bestimmt die Art des Glyphen,
          'div' das übergeordnete <div>-Element,
          'width' die Breite, sowie optimonal 'xpos', das – falls gesetzt –
          eine absolute Positionierung der Glyphen erlaubt

          '_glyphtype' ist die interne Variable, die den 'type'-Wert hält,
          während 'type' als setter definiert ist und 'prefix' den festen
          Anteil des Glyphtypen inkl. Bindestrich zurückliefert; somit
          kann der neue Glyph durch glyph.type = glyph.prefix + morph
          leicht geändert werden.
       */
       var Glyph = class Glyph {
         constructor(_glyphtype, div, width, xpos) {
           this._glyphtype = _glyphtype;
           this.div = div;
           this.width = width;
           this.xpos = xpos;

           let svg = document.createElementNS (xmlns, "svg");
           svg.setAttribute('width', width);
           svg.setAttribute('viewBox', "0 0 " + morphpath.metainfo.width
                                        + " " + morphpath.metainfo.height);
           if (xpos) {
              svg.setAttribute('style', "position: absolute; " +
                               "top: " + "0px" + "; " +
                               "left: " + xpos);
           }
           div.appendChild(svg);
           morphpath[_glyphtype].forEach(p => {
             svg.appendChild(buildPath(p));
           });
           this.svg = svg;
         }

         get prefix() {
             // der Teil des Glyphnamen ohne Morphanteil,
             //  z.B. 'am-00' -> 'am-'
             let idx = this._glyphtype.indexOf('-');
             if (idx > -1 ) {
                return this._glyphtype.slice(0,idx+1);
             }
             return this._glyphtype; // kein Morphanteil
         }

         set type(t) {
             // wir ändern die Pfadinformation nur wenn nötig!
             if (t != this._glyphtype) {
                let svg = this.svg;
                while (svg.firstChild) {
                      svg.removeChild(svg.firstChild);
                }
                morphpath[t].forEach(p => {
                   svg.appendChild(buildPath(p));
                });
                this.svg = svg;
                this._glyphtype  = t;
            }
         }
       }

       /*
          erstelle aus den gespeicherten Pfadinformationen ein
          <path>-Element
       */
       let buildPath = function (p) {
         const path = document.createElementNS (xmlns, "path");
         const attrs = ['stroke-width', 'stroke-linecap',
                        'stroke-linejoin', 'stroke-miterlimit',
                        'fill'];
         path.setAttribute('class', "morph-svg-path");
         for (let i = 0, alen = attrs.length; i < alen; i++ ) {
             let attr=attrs[i];
             path.setAttribute(attr,morphpath.metainfo[attr]);
         }
         path.setAttribute ('d', p);
         return path;
       }
       //*************************************************************************************************
       /*
          Einfache Beispiele:
          Wir verteilen die gesamten Pfade auf die drei Bereiche
          standalone, transition und clock:
       */
       const standalone = {};
       const transition = {};
       const clock = {};
       const exampleWidth = "12.5%";

       for (let key of Object.keys(morphpath)) {
           if (key.length == 1)
              standalone[key] = morphpath[key];
           else if (key.slice(4) == "clock")
              clock[key] = morphpath[key];
           else if (key.slice(2,5) == "-00")
              transition[key] = morphpath[key];
       }

       // die standalone-Glyphen
       const skeys = Object.keys(standalone).sort();
       const sglyphs = [];
       const sdiv = document.getElementById('standalone');
       for (let key of skeys) {
           sglyphs.push (new Glyph(key, sdiv, exampleWidth));
       }

       // die transition-Glyphen
       var tkeys = Object.keys(transition).sort();
       const tglyphs = [];
       const tdiv = document.getElementById('transition');
       for (let key of tkeys) {
           var tglyph = new Glyph(key, tdiv, exampleWidth);
           tglyphs.push(tglyph);
       }

       // die Uhr
       const cdiv = document.getElementById('clock');
       const cglyph = new Glyph('clock-0', cdiv, exampleWidth);
       // wir stellen die Uhr auf die aktuelle Zeit:
       currentTime = new Date;
       h = currentTime.getHours();
       m = currentTime.getMinutes();
       s = currentTime.getSeconds();
       let clockstart = (h * 60 + m) % 720;
       let startmin = m;
       let startsec = s;
       cglyph.type = cglyph.prefix + clockstart;
       //**************************************************************************************************
       /*
          Auswertung der morph-Elemente
       */
       const morphElements = []; // Container für *alle* morphDisplay-Objekte

       morphElements.clock = [];
       morphElements.date = [];
       morphElements.logo = [];

       let divs = document.body.getElementsByTagName("div");
       // wir durchsuchen alle <div>-Elements nach data-type="morph..."
       for (let i = 0; i < divs.length; i++ ) {

           let datatype = divs[i].getAttribute("data-type");

           // Zur Sicherheit genauer Check:
           if (datatype == "morphclock" ||
               datatype == "morphdate" ||
               datatype == "morphlogo") {
              let type = datatype.slice(5); // morphclock -> clock etc.

              morphElements[type].push(new MorphDisplay(type, divs[i]).createGlyphs());
           }
       }
       /*
       console.log(morphElements); console.log("Test:eins.zwo/drei,vier".replace(/[.,\/:]/g,".").split(""));
       var d = new Date(); console.log(d.toUTCString());
       var dd = new Date(2018, 2, 25, 01, 59, 30, 0); console.log(dd.toUTCString());
       var ddd = new Date(2018, 2, 25, 03, 59, 30, 0); console.log(ddd.toUTCString());
       */
       // dummy-Schleife
       for (let type in morphElements) {
           morphElements[type].forEach(entry => {
             let div = entry.div;
             let format = entry.format;
             let glyphs = entry.glyphs;
             let slots = entry.slots;
             console.log(format, glyphs, slots, entry.showSeconds, entry.showDaytime, entry.showWeekday, entry.showMonth);
           });
       }

       function renderTime() {
         currentTime = new Date();
         m = currentTime.getMinutes();
         s = currentTime.getSeconds();
         t = currentTime.getMilliseconds();

         var morph ="";

         setTimeout('renderTime()',10);

         tglyphs.forEach(g => {
           if (s % 3 == 0) morph = "00";
           if (s % 3 == 1) morph = quickMorph();
           if (s % 3 == 2) morph = "99";
           g.type = g.prefix + morph;
         });
         // die Uhr läuft 60× schneller als gewöhnlich
         let offset = ((m-startmin) * 60 + (s-startsec));
         morph = (offset + clockstart ) % 720;
         cglyph.type = cglyph.prefix + morph;
       }

      function quickMorph() {
        return doubleDigit(Math.floor(t/10));
      }

      function slowMorph(x) {
        return doubleDigit(Math.floor(((xS-x)*1000+t)/((10-x)*10)));
      }

      function doubleDigit(x) {
        return x < 10 ? x = "0" + x : x ;
      }
      renderTime();
    </script>

  </body>
</html>
