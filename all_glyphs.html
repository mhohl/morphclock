<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="last-modified" content="2017-03-02@09:07:06 CET" />
    <title>morphclock: glyphs</title>
    <style>
    [data-type^=morph] {
      position: relative;
      white-space: nowrap;
      stroke: black;
    }
    .morph-svg-path {
      fill: none;
      stroke: black;
      stroke-linejoin: round;
      stroke-linecap: round;
      opacity: inherit;
    }
    </style>
  </head>
  <body>
    <script type='text/javascript' language='javascript' src='morphpaths.js'></script>
    <svg style="position:absolute; width:0; height:0">
      <defs>
        <linearGradient id="Gradient-1" x1="0" y1="0" x2="0" y2="100%" gradientUnits="userSpaceOnUse">
            <stop offset="0%" stop-color="red" />
            <stop offset="100%" stop-color="blue" />
        </linearGradient>
      </defs>
    </svg>
    <h1>morphclock: glyphs</h1>
        <h2>Die statischen Glyphen</h2>
            <div id="standalone"></div>
        <h2>Die Übergänge</h2>
            <div id="transition"></div>
        <h2>Die Uhr</h2>
            <div id="clock"></div>
    <h1>morphclock: Anwendungen</h1>
        <h2>morphlogo</h2>
            <div data-type="morphlogo"></div>
        <h2>morphdate</h2>
            <div data-type="morphdate" data-format="d/m/y"></div>
            <div data-type="morphdate"></div> <!-- ohne data-format -> default -->
        <h2>morphclock</h2>
            <div data-type="morphclock" data-format="hhmmss24"></div>
            <div data-type="morphclock" data-format="hhmm24"></div>
            <div data-type="morphclock"></div><!-- ohne data-format -> default -->

    <script type='text/javascript' language='javascript'>
       // der svg-namespace
       const xmlns = "http://www.w3.org/2000/svg";

       var currentTime;
       var h, m, s, t;

       /*
          das MorphDisplay-Objekt
          'type' bestimmt den dargestellten Typ (clock, date, logo),
          'div' das <div>-Element, das die Glyphen aufnimmt, sowie
          'glyphs' ein Array der einzelnen Glyph-Objekte
       */

       var MorphDisplay = class MorphDisplay {
         constructor(type, div, glyphs) {
           this.type = type;
           this.div = div;
           this.format = div.getAttribute("data-format") ||
                         morphDefault.format[type];
           this.glyphs = glyphs || [];

           this.smallOverlap = 0.2;
           this.bigOverlap = 0.4;
         }

         get charWidth() {
           let n_of_chars = 0; // number of chars
           let n_of_sover = 0; // number of small overlaps
           let n_of_bover = 0; // number of big overlaps
           if (this.type == "logo") {
              n_of_chars = "morphclock".length;
              n_of_sover = n_of_chars - 1;
              n_of_bover = 0;
              console.log("calcCharWidth: logo");
           }
           else if (this.type == "clock") {
              n_of_chars = 4;
              n_of_sover = 2;
              n_of_bover = 2;
              console.log("calcCharWidth: clock");
           }
           else {
              n_of_chars = 10;
              n_of_sover = 2;
              n_of_bover = 2;
              console.log("calcCharWidth: date");
           }
           return 100/(n_of_chars -
                  n_of_sover * this.smallOverlap -
                  n_of_bover * this.bigOverlap);
         }

         get charPos() {
           let positions = [];
           let pos = 0;
           let width = this.charWidth;
           positions.push(pos);
           if (this.type == "logo") {
              for (let i = 1; i < "morphclock".length; i++ ) {
                  pos += width*(1 - this.smallOverlap);
                  positions.push(pos);
              }
           }
           return positions;
         }

       }

       //MorphDisplay.prototype.smallOverlap = 0.2;
       //MorphDisplay.prototype.bigOverlap = 0.4;

       MorphDisplay.prototype.createGlyphs = function() {
         let width = this.charWidth;
         let xpos = this.charPos;

         if (this.type == "logo") {
            ['m', 'o', 'r', 'p', 'h', 'c', 'l', 'clock', 'c', 'k'].forEach(g =>
              this.glyphs.push(new Glyph(g, this.div, width + "%", xpos.shift()+"%")));

            this.div.style.height = this.div.children[0].getBoundingClientRect().height;
         }
         /*
           the morphclock div's height is set to the height of the first
           child, i.e. the first svg element
         */
         // sollte hier stehen, aber erst, wenn clock und date implementiert sind
         //this.div.style.height = this.div.children[0].getBoundingClientRect().height || 0;
         return this;
       }

       /*
          das Glyph-Objekt:
          'type' bestimmt die Art des Glyphen (einzelner Buchstabe, Übergang oder Uhr),
          'div' das übergeordnete <div>-Element,
          'width' die Breite, sowie optimonal 'xpos', das – falls gesetzt –
          eine absolute Positionierung der Glyphen erlaubt
       */
       var Glyph = class Glyph {
         constructor(type, div, width, xpos) {
           this.type  = type; this.prevtype  = type;
           this.morph = null; this.prevmorph = null;
           this.div = div;
           this.width = width;
           this.xpos = xpos;

           let svg = document.createElementNS (xmlns, "svg");
           svg.setAttribute('width', width);
           svg.setAttribute('viewBox', "0 0 " + morphpath.metainfo.width
                                        + " " + morphpath.metainfo.height);
           if (xpos) {
              svg.setAttribute('style', "position: absolute; " +
                               "top: " + "0px" + "; " +
                               "left: " + xpos);
           }
           div.appendChild(svg);
           morphpath[calcIdx(type, this.morph)].forEach(p => {
             svg.appendChild(buildPath(p));
           });
           this.svg = svg;
         }
       }
       /*
          update() verändert die path-Information nur, wenn dies wirklich
          notwendig ist
       */
       Glyph.prototype.update = function() {
         if (this.type  != this.prevtype ||
             this.morph != this.prevmorph) {
            let svg = this.svg;
            while (svg.firstChild) {
                  svg.removeChild(svg.firstChild);
            }
            morphpath[calcIdx(this.type, this.morph)].forEach(p => {
              svg.appendChild(buildPath(p));
            });
            this.svg = svg;
            this.prevtype  = this.type;
            this.prevmorph = this.morph;
         }
       }

       /*
          erstelle aus den gespeicherten Pfadinformationen ein
          <path>-Element
       */
       let buildPath = function (p) {
         const path = document.createElementNS (xmlns, "path");
         path.setAttribute('class', "morph-svg-path");
         path.setAttribute('stroke-width',
                           morphpath.metainfo['stroke-width']);
         path.setAttribute('stroke-linecap',
                           morphpath.metainfo['stroke-linecap']);
         path.setAttribute('stroke-linejoin',
                           morphpath.metainfo['stroke-linejoin']);
         path.setAttribute('stroke-miterlimit',
                           morphpath.metainfo['stroke-miterlimit']);
         path.setAttribute('fill:',
                           morphpath.metainfo['fill']);
         path.setAttribute ('d', p);
         return path;
       }
       /*
          Berechne den Index, unter dem das Element 'type'/'morph'
          zu finden ist;
          standalone-Glyphen haben ein einzelnes Zeichen als Index;
          Übergänge haben die Form ft-nn mit
             f als Startzeichen,
             t als Zielzeichen und der immer(!)
             zweistelligen Nummer nn nach dem Bindestrich als
             Morphfaktor;
          die Uhr ist unter clock-n indiziert, wobei n = 0...719
       */
       var calcIdx = function (type, morph) {
           let result = type;
           if (morph) {
               result = result + "-" + morph;
           }
           else if (type.length == 2) {
              // type zweistellig, kein morph
              result = result + "-00";
           }
           else if (type.length == 5) {
              // clock ohne morph
              result = result + "-0";
           }
           return result;
       }

       /*
          Einfache Beispiele:
          Wir verteilen die gesamten Pfade auf die drei Bereiche
          standalone, transition und clock:
       */
       const standalone = {};
       const transition = {};
       const clock = {};
       const exampleWidth = "12.5%";
       for (let key of Object.keys(morphpath)) {
           if (key.length == 1)
              standalone[key] = morphpath[key];
           else if (key.slice(4) == "clock")
              clock[key] = morphpath[key];
           else if (key.slice(2,5) == "-00")
              transition[key.slice(0,2)] = morphpath[key];
       }

       // die standalone-Glyphen
       const skeys = Object.keys(standalone).sort();
       const sglyphs = [];
       const sdiv = document.getElementById('standalone');
       for (let key of skeys) {
           sglyphs.push (new Glyph(key, sdiv, exampleWidth));
       }

       // die transition-Glyphen
       var tkeys = Object.keys(transition).sort();
       const tglyphs = [];
       const tdiv = document.getElementById('transition');
       for (let key of tkeys) {
           var tglyph = new Glyph(key, tdiv, exampleWidth);
           tglyphs.push(tglyph);
       }

       // die Uhr
       const cdiv = document.getElementById('clock');
       const cglyph = new Glyph('clock', cdiv, exampleWidth);
       // wir stellen die Uhr auf die aktuelle Zeit:
       currentTime = new Date;
       h = currentTime.getHours();
       m = currentTime.getMinutes();
       let clockstart = (h * 60 + m) % 720;
       cglyph.morph = clockstart;
       cglyph.update();

       /*
          Auswertung der morph-Elemente
       */
       const morphElements = []; // Container für *alle* morphDisplay-Objekte

       const morphDefault = { // Defaultwerte, falls data-format nicht angegeben ist
          format: {
            clock: "hhmmss12",
            date: "d.m.y",
            logo: "default",
          }
       }

       morphElements.clock = [];
       morphElements.date = [];
       morphElements.logo = [];

       let divs = document.body.getElementsByTagName("div");
       // wir durchsuchen alle <div>-Elements nach data-type="morph..."
       for (let i = 0; i < divs.length; i++ ) {

           let datatype = divs[i].getAttribute("data-type");

           // Zur Sicherheit genauer Check:
           if (datatype == "morphclock" ||
               datatype == "morphdate" ||
               datatype == "morphlogo") {
              let type = datatype.slice(5); // morphclock -> clock etc.

              let entry = new MorphDisplay(type, divs[i]).createGlyphs();

              //entry.createGlyphs();

              /* dummy fill routine
              for (let j = 0; j < 10; j++) {
                  entry.glyphs.push(i*j);
              }*/

              // speichere entry im passenden slot
              morphElements[type].push(entry);
           }
       }
       console.log(morphElements); console.log("Test:eins.zwo/drei,vier".replace(/[.,\/:]/g,".").split(""));
       var d = new Date(); console.log(d.toUTCString());
       var dd = new Date(2018, 2, 25, 01, 59, 30, 0); console.log(dd.toUTCString());
       var ddd = new Date(2018, 2, 25, 03, 59, 30, 0); console.log(ddd.toUTCString());

       // dummy-Schleife
       for (let type in morphElements) {
           morphElements[type].forEach(entry => {
             let div = entry.div;
             let format = entry.format;
             let glyphs = entry.glyphs;
             console.log(format, glyphs);
           });
       }

       function renderTime() {
         currentTime = new Date();
         s = currentTime.getSeconds();
         t = currentTime.getMilliseconds();

         var morph ="";

         setTimeout('renderTime()',10);

         tglyphs.forEach(g => {
           if (s % 3 == 0) morph = "00";
           if (s % 3 == 1) morph = quickMorph();
           if (s % 3 == 2) morph = "99";
           g.morph = morph;
           g.update();
         });
         // die Uhr läuft 60× schneller als gewöhnlich
         cglyph.morph = ((m * 60 + s) + clockstart) % 720;
         cglyph.update();
       }

      function quickMorph() {
        return doubleDigit(Math.floor(t/10));
      }

      function slowMorph(x) {
        return doubleDigit(Math.floor(((xS-x)*1000+t)/((10-x)*10)));
      }

      function doubleDigit(x) {
        return x < 10 ? x = "0" + x : x ;
      }
      renderTime();
    </script>

  </body>
</html>
