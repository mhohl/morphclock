<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="last-modified" content="2017-03-02@09:07:06 CET" />
    <title>morphclock: glyphs</title>
    <style>
    [data-type^=morph] {
      position: relative;
      white-space: nowrap;
      stroke: black;
    }
    .morph-svg-path {
      fill: none;
      stroke: black;
      stroke-linejoin: round;
      stroke-linecap: round;
      opacity: inherit;
    }
    </style>
  </head>
  <body>
    <script type='text/javascript' language='javascript' src='morphpaths.js'></script>
    <svg style="position:absolute; width:0; height:0">
      <defs>
        <linearGradient id="Gradient-1" x1="0" y1="0" x2="0" y2="100%" gradientUnits="userSpaceOnUse">
            <stop offset="0%" stop-color="red" />
            <stop offset="100%" stop-color="blue" />
        </linearGradient>
      </defs>
    </svg>
    <h1>morphclock: glyphs</h1>
        <h2>Die statischen Glyphen</h2>
            <div id="standalone"></div>
        <h2>Die Übergänge</h2>
            <div id="transition"></div>
        <h2>Die Uhr</h2>
            <div id="clock"></div>
    <h1>morphclock: Anwendungen</h1>
        <h2>morphlogo</h2>
            <div data-type="morphlogo"></div>
        <h2>morphdate</h2>
            <div data-type="morphdate" data-format="d/m/y"></div>
            <div data-type="morphdate"></div> <!-- ohne data-format -> default -->
        <h2>morphclock</h2>
            <div data-type="morphclock" data-format="hhmmss24"></div>
            <div data-type="morphclock" data-format="hhmm24"></div>
            <div data-type="morphclock"></div><!-- ohne data-format -> default -->

    <script type='text/javascript' language='javascript'>
       // der svg-namespace
       const xmlns = "http://www.w3.org/2000/svg";

       var currentTime;
       var h, m, s, t;

       const MorphData = {
             default: {
                clock: 'hhmmss24',
                date: 'd.m.y',
                logo: 'default'
             },
             clock: {
                hhmmss24: {
                   glyph: [ '20-00', '30-00', '::-00', '50-00', '90-00', '::-00', '50-00', '90-00' ],
                   slot:  [ 'Hx', 'xH', 'Cx', 'Mx', 'xM', 'xC', 'Sx', 'xS' ]
                },
                hhmm24: {
                   glyph: [ '20-00', '30-00', '::-00', '50-00', '90-00' ],
                   slot:  [ 'Hx', 'xH', 'xC', 'Mx', 'xM' ]
                },
                hhmmss12: {
                   glyph: [ '10-00', '21-00', '::-00', '50-00', '90-00', '::-00', '50-00', '90-00', '~', 'ap-00', 'mm-00' ],
                   slot:  [ 'hx', 'xh', 'Cx', 'Mx', 'xM', 'xC', 'Sx', 'xS', null, 'Dx', 'xD' ]
                }
             },
             date: {
                'd/m/y': {
                   glyph: [],
                   slot:  []
                },
                'd.m.y': {
                   glyph: [],
                   slot:  []
                }
             },
             logo: {
                default: {
                   glyph: [ 'm', 'o', 'r', 'p', 'h', 'c', 'l', 'clock-0', 'c', 'k' ],
                   slot:  [ null, null, null, null, null, null, null, 'clock', null ]
                }
             }
       };

       /*
          das MorphDisplay-Objekt
          'type' bestimmt den dargestellten Typ (clock, date, logo),
          'div' das <div>-Element, das die Glyphen aufnimmt, sowie
          'glyphs' ein Array der einzelnen Glyph-Objekte
       */

       var MorphDisplay = class MorphDisplay {
         constructor(type, div, glyphs) {
           this.type = type;
           this.div = div;
           this.format = div.getAttribute("data-format") ||
                         MorphData.default[type];
           this.glyphs = glyphs || [];

           this.smallOverlap = 0.2;
           this.bigOverlap = 2 * this.smallOverlap;
         }

         get charWidth() {
           let n_of_chars = 0; // number of chars
           let n_of_sover = 0; // number of small overlaps
           let n_of_bover = 0; // number of big overlaps
           if (this.type == "logo") {
              n_of_chars = "morphclock".length;
              n_of_sover = n_of_chars - 1;
              n_of_bover = 0;
              console.log("calcCharWidth: logo", n_of_chars, n_of_sover, n_of_bover);
           }
           else if (this.type == "clock") {
              n_of_chars = MorphData.clock[this.format].glyph.length;
              n_of_sover = 2;
              n_of_bover = 2;
              if (this.showDaytime) {
                 // n_of_chars += 1; // add the space before 'am/pm'
                 n_of_sover += 1; // one more small overlap between 'a|p' and 'm'
                 n_of_bover += 2; // two more big overlaps for the additional space
              }
              if (this.showSeconds) {
                 n_of_sover += 1; // one more small overlap for the seconds
                 n_of_bover += 2; // two more big overlaps for the ':' before the seconds
              }
              console.log("calcCharWidth: clock", this.format, n_of_chars, n_of_sover, n_of_bover);
           }
           else {
              n_of_chars = 10;
              n_of_sover = 2;
              n_of_bover = 2;
              console.log("calcCharWidth: date", this.format, n_of_chars, n_of_sover, n_of_bover);
           }
           return 100/(n_of_chars -
                  n_of_sover * this.smallOverlap -
                  n_of_bover * this.bigOverlap);
         }

         get charPos() {
           let positions = [];
           let pos = 0;
           let width = this.charWidth;
           positions.push(pos);
           if (this.type == "logo") {
              for (let i = 1; i < "morphclock".length; i++ ) {
                  pos += width*(1 - this.smallOverlap);
                  positions.push(pos);
              }
           }
           return positions;
         }

         get height() {
             let children = this.div.children;
             if (children.length > 0)
                return children[0].getBoundingClientRect().height;
             return 0;
         }

         get showSeconds() {
             return (this.type == "clock") &&
                    (this.format.indexOf("ss") > -1);
         }

         get showDaytime() {
             return (this.type == "clock") &&
                    (this.format.indexOf("12") > -1);
         }
       }

       MorphDisplay.prototype.createGlyphs = function() {
         let width = this.charWidth;
         let xpos = this.charPos;
         let morph = MorphData[this.type][this.format];

         for (let i = 0; i < morph.glyph.length; i++ ){
             let newglyph = new Glyph(morph.glyph[i],
                                      this.div,
                                      width + "%",
                                      xpos.shift()+"%");

             let slot = morph.slot[i] || morph.glyph[i];
             // slot[i] ist null bei ungemorphten Glyphen
             newglyph.svg.setAttribute('class', this.type + "-" +
                                                this.format + "-" +
                                                slot);

             this.glyphs.push(newglyph);
         }
         // setze die Höhe des parent-div:
         this.div.style.height = this.height;
         return this;
       }

       /*
          das Glyph-Objekt:
          'type' bestimmt die Art des Glyphen,
          'div' das übergeordnete <div>-Element,
          'width' die Breite, sowie optimonal 'xpos', das – falls gesetzt –
          eine absolute Positionierung der Glyphen erlaubt

          '_glyphtype' ist die interne Variable, die den 'type'-Wert hält,
          während 'type' als getter/setter definiert ist
       */
       var Glyph = class Glyph {
         constructor(_glyphtype, div, width, xpos) {
           this._glyphtype = _glyphtype;
           this.div = div;
           this.width = width;
           this.xpos = xpos;

           let svg = document.createElementNS (xmlns, "svg");
           svg.setAttribute('width', width);
           svg.setAttribute('viewBox', "0 0 " + morphpath.metainfo.width
                                        + " " + morphpath.metainfo.height);
           if (xpos) {
              svg.setAttribute('style', "position: absolute; " +
                               "top: " + "0px" + "; " +
                               "left: " + xpos);
           }
           div.appendChild(svg);
           morphpath[_glyphtype].forEach(p => {
             svg.appendChild(buildPath(p));
           });
           this.svg = svg;
         }

         get type() {
             return this._glyphtype;
         }

         set type(t) {
             // wir ändern die Pfadinformation nur wenn nötig!
             if (t != this._glyphtype) {
                let svg = this.svg;
                while (svg.firstChild) {
                      svg.removeChild(svg.firstChild);
                }
                morphpath[t].forEach(p => {
                   svg.appendChild(buildPath(p));
                });
                this.svg = svg;
                this._glyphtype  = t;
            }
         }
       }

       /*
          erstelle aus den gespeicherten Pfadinformationen ein
          <path>-Element
       */
       let buildPath = function (p) {
         const path = document.createElementNS (xmlns, "path");
         const attrs = ['stroke-width', 'stroke-linecap',
                        'stroke-linejoin', 'stroke-miterlimit',
                        'fill'];
         path.setAttribute('class', "morph-svg-path");
         for (var i = 0, alen = attrs.length; i < alen; i++ ) {
             let attr=attrs[i];
             path.setAttribute(attr,morphpath.metainfo[attr]);
         }
         path.setAttribute ('d', p);
         return path;
       }

       /*
          Einfache Beispiele:
          Wir verteilen die gesamten Pfade auf die drei Bereiche
          standalone, transition und clock:
       */
       const standalone = {};
       const transition = {};
       const clock = {};
       const exampleWidth = "12.5%";

       for (let key of Object.keys(morphpath)) {
           if (key.length == 1)
              standalone[key] = morphpath[key];
           else if (key.slice(4) == "clock")
              clock[key] = morphpath[key];
           else if (key.slice(2,5) == "-00")
              transition[key] = morphpath[key];
       }

       // die standalone-Glyphen
       const skeys = Object.keys(standalone).sort();
       const sglyphs = [];
       const sdiv = document.getElementById('standalone');
       for (let key of skeys) {
           sglyphs.push (new Glyph(key, sdiv, exampleWidth));
       }

       // die transition-Glyphen
       var tkeys = Object.keys(transition).sort();
       const tglyphs = [];
       const tdiv = document.getElementById('transition');
       for (let key of tkeys) {
           var tglyph = new Glyph(key, tdiv, exampleWidth);
           tglyphs.push(tglyph);
       }

       // die Uhr
       const cdiv = document.getElementById('clock');
       const cglyph = new Glyph('clock-0', cdiv, exampleWidth);
       // wir stellen die Uhr auf die aktuelle Zeit:
       currentTime = new Date;
       h = currentTime.getHours();
       m = currentTime.getMinutes();
       s = currentTime.getSeconds();
       let clockstart = (h * 60 + m) % 720;
       let startmin = m;
       let startsec = s;
       cglyph.type = cglyph.type.slice(0,6) + clockstart;

       /*
          Auswertung der morph-Elemente
       */
       const morphElements = []; // Container für *alle* morphDisplay-Objekte

       morphElements.clock = [];
       morphElements.date = [];
       morphElements.logo = [];

       let divs = document.body.getElementsByTagName("div");
       // wir durchsuchen alle <div>-Elements nach data-type="morph..."
       for (let i = 0; i < divs.length; i++ ) {

           let datatype = divs[i].getAttribute("data-type");

           // Zur Sicherheit genauer Check:
           if (datatype == "morphclock" ||
               datatype == "morphdate" ||
               datatype == "morphlogo") {
              let type = datatype.slice(5); // morphclock -> clock etc.

              morphElements[type].push(new MorphDisplay(type, divs[i]).createGlyphs());
           }
       }
       /*
       console.log(morphElements); console.log("Test:eins.zwo/drei,vier".replace(/[.,\/:]/g,".").split(""));
       var d = new Date(); console.log(d.toUTCString());
       var dd = new Date(2018, 2, 25, 01, 59, 30, 0); console.log(dd.toUTCString());
       var ddd = new Date(2018, 2, 25, 03, 59, 30, 0); console.log(ddd.toUTCString());
       */
       // dummy-Schleife
       for (let type in morphElements) {
           morphElements[type].forEach(entry => {
             let div = entry.div;
             let format = entry.format;
             let glyphs = entry.glyphs;
             console.log(format, glyphs, entry.showSeconds, entry.showDaytime);
           });
       }

       function renderTime() {
         currentTime = new Date();
         m = currentTime.getMinutes();
         s = currentTime.getSeconds();
         t = currentTime.getMilliseconds();

         var morph ="";

         setTimeout('renderTime()',10);

         tglyphs.forEach(g => {
           if (s % 3 == 0) morph = "00";
           if (s % 3 == 1) morph = quickMorph();
           if (s % 3 == 2) morph = "99";
           g.type = g.type.slice(0,3) + morph;
         });
         // die Uhr läuft 60× schneller als gewöhnlich
         let offset = ((m-startmin) * 60 + (s-startsec));
         morph = (offset + clockstart ) % 720;
         cglyph.type = cglyph.type.slice(0,6) + morph;
       }

      function quickMorph() {
        return doubleDigit(Math.floor(t/10));
      }

      function slowMorph(x) {
        return doubleDigit(Math.floor(((xS-x)*1000+t)/((10-x)*10)));
      }

      function doubleDigit(x) {
        return x < 10 ? x = "0" + x : x ;
      }
      renderTime();
    </script>

  </body>
</html>
