%
% glyph.mpost
%
% die Ziffern und Buchstaben werden
% a) als Einzelzeichen
% b) als Übergänge in der Form ft-nn erzeugt:
% f = "from": Startglyph
% t = "to":   Endglyph
% nn : laufende Nummer
%
% Als Ziffernübergänge benötigen wir
% 0 -> 1, 1 -> 2, 2 -> 3, 3 -> 4, 4 -> 5,
% 5 -> 6, 6 -> 7, 7 -> 8, 8 -> 9, 9 -> 0 sowie
% 1 -> 0, 1 -> 1, 2 -> 0, 2 -> 1, 3 -> 0,
% 5 -> 0, 6 -> 0, 8 -> 1, 9 -> 1, 0 -> 0,
% 1 -> 2a, 2a -> 2b, 2b -> 3
%
% Als Interpunktionen haben wir ":", ",", ".", "-", "/"
% sowie "~" als Leerzeichen
% und den Übergang : -> :
%
% Für die Anzeige des Monats
% (jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)
% und des Wochentages (mon|tue|wed|thu|fri|sat|sun)
% sind folgende Übergänge notwendig:
%
% a -> e, a -> m, a -> p, a -> s, a -> u,
% b -> r, c -> n, c -> o, d -> j, d -> u,
% e -> a, e -> c, e -> d, e -> h, f -> m,
% f -> s, g -> p, h -> r, i -> t, j -> a,
% j -> f, j -> j, l -> g, m -> a, m -> j,
% m -> m, m -> t, n -> b, n -> d, n -> e,
% n -> l, n -> n, o -> e, o -> n, o -> u,
% p -> a, p -> t, r -> a, r -> r, r -> y,
% s -> m, s -> o, s -> s, t -> f, t -> n,
% t -> v, t -> w, u -> e, u -> i, u -> o,
% u -> u, v -> c, w -> t, y -> n
%
% Speziell für die deutschen Abkürzungen
% (jan|feb|mär|apr|mai|jun|jul|aug|sep|okt|nov|dez)
% und die Wochentage (mo|di|mi|do|fr|sa|so) sind
% zusätzlich notwendig:
%
% a -> o, ä -> p, d -> f, d -> m, e -> ä,
% e -> k, i -> i, i -> n, i -> o, k -> o,
% m -> d, o -> i, o -> o, o -> r, r -> i,
% v -> z, z -> n
%
% Das Uhr-O schließlich ist unter clock-n
% n := hour*60+min (also n = 0 ... 719)
% abgelegt.

% Versionsnummer:
string version;
version := "Version: 1.51";
show(version);

outputformat := "eps";

numeric f;      % [f]rame index
numeric start;  % [start] of transition;
start = 0;
numeric m;      % [m]orph factor
numeric t;      % [t]ension
numeric phi[];  % angle [phi]
numeric q;      % [q]uadratic factor
path tmppath[]; % [t]e[mp]orary [path]
numeric tmp[];  % [t]e[mp]orary variable
pair aux[];     % [aux]iliary points;
picture tmppic; % [t]e[mp]orary [pic]ture

% vordefinierte Einheiten
numeric u;      % [u]nit
u := 5cm;

numeric pendia; % [pen] [dia]meter
pendia := 0.1u;
pen pc;         % [p]en[c]ircle
pc := pencircle scaled pendia;

numeric fpht;   % [f]rames [p]er [h]alf [t]ransition
fpht := 50;

numeric asc;    % [asc]ender
asc := 1.2u;

numeric dsc;    % [d]e[sc]ender
dsc := -0.5u;

numeric xh;     % [x]-[h]eight
xh := 0.85u;

numeric dy;     % [d]elta [y]
dy := 0.15u;

numeric sw;     % [s]mall [w]idth
sw := 0.25u;
numeric mw;     % [m]edium [w]idth
mw := 11/10*sw;
numeric iw;     % [i]ntermediate [w]idth
iw := 13/10*sw;
numeric lw;     % [l]arge [w]idth
lw := 3/2*sw;

numeric corr;   % [corr]ection for f/i/j/l/r/t
corr := iw - sw;

pair C;         % [C]enter of rotation
C := (0,xh/2);

% symbolische Variablen
numeric LEFT, RIGHT, TOP, BOTTOM;
numeric BEGIN, END, JOINT, MID;
numeric L_ARC, R_ARC, U_ARC, D_ARC;
LEFT   = 1000;
RIGHT  = 1001;
TOP    = 1002;
BOTTOM = 1003;
BEGIN  = 1004;
END    = 1005;
JOINT  = 1006;
MID    = 1007;
L_ARC  = 1008; % [l]eft (part of) [arc]
R_ARC  = 1009; % [r]ight (part of) [arc]
U_ARC  = 1010; % [u]pright (part of) [arc]
D_ARC  = 1011; % [d]ownright (part of) [arc]
INTER  = 1012; % [inter]section point
TEMP   = 1013; % [temp]orary point
DIR    = 1014; % [dir]ection vector
DIFF   = 1015;
CENTER = 1016;
% spezielle Indizes:
A_LOOP     = 2000;
A_SWEEP    = 2001;
G_LOOP     = 2002;
TWO_HOOK   = 2003;
THREE_UARC = 2004;
THREE_LARC = 2005;


% Arrays für die Koordinaten der Ziffern:
pair zero[], one[],   two[], three[], four[];
pair five[], six[], seven[], eight[], nine[];

% spezielle Arrays für die doppelte Zwei:
pair twoA[], twoB[];

% Array für die Interpunktionen:

pair asterisk[], comma[], dash[], dot[], slash[], colon[];

% Arrays für die Buchstaben:
pair _a_[], _b_[], _c_[], _d_[],
     _e_[], _f_[], _g_[], _h_[],
     _i_[], _j_[], _k_[], _l_[],
     _m_[], _n_[], _o_[], _p_[],
     _q_[], _r_[], _s_[], _t_[],
     _u_[], _v_[], _w_[], _x_[],
     _y_[], _z_[];

% draft kennzeichnet den Entwurfsmodus:
numeric draft; draft := 1;

def draw_grid(expr u) =
    if draft > 0:
      draw (-0.6u,-0.75u)
           -- (-0.6u,1.5u)
           -- (0.6u,1.5u)
           -- (0.6u,-0.75u)
           -- cycle;
      draw (-0.6u,0) -- (0.6u,0);
      draw (-0.6u,xh) -- (0.6u,xh);
      draw (-sw,-0.75u)--(-sw,1.5u);
      draw (sw,-0.75u)--(sw,1.5u);
    fi
enddef;

def TODO(expr u) =
      draw (-sw,xh);
      draw (sw,xh);
      draw (-sw,0.15u) .. (0,0) .. (sw,0.15u);
enddef;

path boundingpath;
boundingpath := (-0.6u,-0.75u)
                -- (-0.6u,1.5u)
                -- (0.6u,1.5u)
                -- (0.6u,-0.75u)
                -- cycle;

vardef advanced(expr xx) = sind(90xx) enddef;
vardef retarded(expr xx) = 1-cosd(90xx) enddef;

% Die Exponentialfunktion ist standardmäßig nicht definiert:
vardef exp(expr xx) = (mexp(256)**xx) enddef;

% Wir definieren ein "yshifted" für den Buchstaben "m":
primarydef z yshifted yy = z shifted (0,yy) enddef;

%
% Zur Animation des m benutzen wir folgende Funktion:
%
%  1.5 +-+---------+----------+-----------+----------+-----------+--------+-+
%      +           +          +           +          +           +          +
%      |                                sqrt(2*exp(1))*x*exp(-x**2) ******* |
%    1 +-+                                      ****                      +-+
%      |                                       *    ***                     |
%      |                                     **       **                    |
%  0.5 +-+                                   *          **                +-+
%      |                                   **             **                |
%      |                                   *                ***             |
%    0 +-+                                *                    **************
%      **************                    *                                  |
%      |             ***                *                                   |
%      |                **             **                                   |
% -0.5 +-+                **          *                                   +-+
%      |                    **       **                                     |
%      |                     ***    *                                       |
%   -1 +-+                      ****                                      +-+
%      |                                                                    |
%      +           +          +           +          +           +          +
% -1.5 +-+---------+----------+-----------+----------+-----------+--------+-+
%     -3          -2         -1           0          1           2          3
%
% Wir substituieren:
% x => scale*(x-shift*(2*t-1)), somit  [0 .. t .. 1] => [-1 .. 2t-1 .. 1]
% "shift" gibt die Lage des Nullpunktes der Funktion an,
% "scale" komprimiert den Funktionsverlauf für scale > 1
% "amplitude" ist selbsterklärend
%
% Die Verzerrung läuft somit für t=[0..1] von links nach rechts durch das
% Bild

def wiggle(expr x, t) =
    begingroup
    save scale, shift, amplitude, res;
    scale := 2;
    shift := 1.25;
    amplitude := 0.15;
    res := scale*(x-shift*(2*t-1));
    res := amplitude*sqrt(2*exp(1))*res*exp(-res*res);
    res
    endgroup
enddef;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Part I: Ziffern
%
%   ###          ###
%  #   #        #   #
%  #   #   ###   ####
%  #   #           #
%   ###          ##
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 0
zero[TOP]    = (0,xh);
zero[BOTTOM] = (0,0);
zero[LEFT]   = (-mw,xh/2);
zero[RIGHT]  = zero[LEFT] xscaled -1;

% 1
one[BEGIN]  = (-sw,xh/2);
one[TOP]    = (sw,xh);
one[BOTTOM] = (sw,0);
% Hilfspunkt für Übergänge
one[MID]    = 1/2[one[TOP],one[BOTTOM]];

% 2
two[BEGIN] = (-sw,3/4*xh);
two[TOP]   = zero[TOP];
two[R_ARC] = (sw,2/3*xh);
two[JOINT] = (-sw,0);
two[END]   = (sw,0);

% 2a
twoA[BEGIN] = (corr,dsc/2);
twoA[TOP]   = (sw,-dsc/2+corr);
twoA[END]   = (2sw-corr,dsc/2);
%
twoA[MID]   = ((0,0) -- (2sw,0))
              intersectionpoint (twoA[TOP] -- twoA[END]);

% 2b
twoB[TOP]    = twoA[TOP];
twoB[BOTTOM] = (xpart(twoA[TOP]),ypart(twoA[BEGIN]));
twoB[MID]    = twoA[MID];
twoB[U_ARC]  = (7/4sw,-dsc/4);
twoB[D_ARC]  = (2sw,dsc/4);

% 3
three[BEGIN]  = (-sw,xh-dy);
three[TOP]    = two[TOP];
three[U_ARC]  = (sw,2/3*xh);
three[JOINT]  = (-0.15u,dy);
three[D_ARC]  = (iw,1/2*dsc);
three[BOTTOM] = (0,dsc);
three[END]    = (-iw,2/3*dsc);

% 4
four[LEFT]   = (-sw,0);
four[TOP]    = (sw,xh);
four[BOTTOM] = (sw,dsc);
four[RIGHT]  = (lw,dy);

four[INTER]  = (four[LEFT] -- four [RIGHT])
               intersectionpoint
               (four[TOP] -- four[BOTTOM]);

% 5
five[BEGIN] = four[TOP];
five[LEFT]  = five[BEGIN] xscaled -1;
five[JOINT] = (-sw,dy);
five[U_ARC] = (0,2dy);
five[R_ARC] = (mw,-dy);
five[END]   = (-mw,dsc);

% 6
six[BEGIN]  = (sw,asc);
six[LEFT]   = (-iw,(xh-dy)/2);
six[RIGHT]  = six[LEFT] xscaled -1;
six[TOP]    = (0,xh-dy);
six[BOTTOM] = zero[BOTTOM];

% 7
seven[BEGIN] = (-0.3u,0.75u);
seven[LEFT]  = (-0.3u,xh);
seven[JOINT] = seven[LEFT] xscaled -1;
seven[MID]   = (0.1u,0.15u);
seven[END]   = (0,dsc);
% Hilfspunkt:
seven[TOP]   = (1/2)[seven[LEFT],seven[JOINT]];

% 8
eight[TOP]    = (0,asc);
eight[MID]    = (0,xh-dy);
eight[L_ARC]  = (-sw,(asc+xh-dy)/2);
eight[R_ARC]  = eight[L_ARC] xscaled -1;
eight[LEFT]   = (-lw,(xh-dy)/2);
eight[RIGHT]  = eight[LEFT] xscaled -1;
eight[BOTTOM] = zero[BOTTOM];

% 9
nine[TOP]    = zero[TOP];
nine[LEFT]   = (-iw,(xh+dy)/2);
nine[RIGHT]  = nine[LEFT] xscaled -1;
nine[BOTTOM] = (0,dy);
nine[END]    = (-sw,dsc);

%
%%%%%%%%%%%% Ziffern/Übergänge
%

%
% 0 -> ()
%

outputtemplate := "0.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw zero[TOP]
        .. zero[RIGHT]
        .. zero[BOTTOM]
        .. zero[LEFT]
        .. cycle;
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% 0 -> 0
%

outputtemplate := "00-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

tmppath0 := zero[TOP]
            .. zero[RIGHT]
            .. zero[BOTTOM]
            .. zero[LEFT]
            .. cycle;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-start)/fpht;
       m := retarded(f);

       aux[R_ARC] := point 2m of tmppath0;

       draw m[zero[TOP],aux[R_ARC]]
            .. m[zero[RIGHT],aux[R_ARC]]
            .. m[zero[BOTTOM],aux[R_ARC]]
            .. m[zero[LEFT],aux[R_ARC]]
            .. cycle;
       % um Artefakte bei kleinen Schlaufen zu vermeiden:
       if ypart(m[zero[TOP],aux[R_ARC]]) - ypart(zero[BOTTOM]) < pendia:
          draw m[zero[TOP],aux[R_ARC]];
       fi
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-start-fpht)/fpht;
       m := advanced(f);

       aux[L_ARC] := point 2m + 2 of tmppath0;

       draw m[aux[L_ARC],zero[TOP]]
            .. m[aux[L_ARC],zero[RIGHT]]
            .. m[aux[L_ARC],zero[BOTTOM]]
            .. m[aux[L_ARC],zero[LEFT]]
            .. cycle;
       % um Artefakte bei kleinen Schlaufen zu vermeiden:
       if ypart(m[aux[L_ARC],zero[TOP]]) - ypart(zero[BOTTOM]) < pendia:
          draw m[aux[L_ARC],zero[TOP]];
       fi
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 0 -> 1
%

outputtemplate := "01-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-start)/fpht;
       m := retarded(f);

       if m < 1:
          draw m[zero[TOP],one[TOP]]
               ... m[zero[RIGHT],one[MID]]
               ... m[zero[BOTTOM],one[BOTTOM]]
             ... m[zero[LEFT],one[MID]]
             ... cycle;
       else:
          % für m = 1 entstünden seltsame Schlaufen
          draw one[TOP] -- one[BOTTOM];
       fi
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[one[TOP],one[BEGIN]]
            -- one[TOP]
            -- one[BOTTOM];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 1 -> ()
%

outputtemplate := "1.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw one[BEGIN]
        -- one[TOP]
        -- one[BOTTOM];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% 1 -> 2
%

outputtemplate := "12-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw m[one[BEGIN],two[BEGIN]]
            -- m[one[TOP],two[R_ARC]]
            -- m[one[BOTTOM],two[JOINT]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);
       t := 1/sqrt(sqrt(m)); % zur Vermeidung einer Spitze im Scheitel der 2

       aux[MID] := (1/2)[two[BEGIN],two[R_ARC]];
       aux[TOP] := m[aux[MID],two[TOP]];

       draw two[BEGIN]
            .. tension  t .. aux[TOP]
            .. tension  t .. two[R_ARC]
            .. tension 2t .. two[JOINT]
          & two[JOINT]
            -- m[two[JOINT],two[END]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 1 -> 0
%

outputtemplate := "10-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       tmppath1 := one[MID] -- one [TOP] -- one[BEGIN];

       draw subpath (0,2-2m) of tmppath1;
       draw one[MID] -- m[one[BOTTOM],one[MID]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-start-fpht)/fpht;
       m := advanced(f);

       % Der horizontale Abstand zwischen dem linken und rechten Rand:
       tmp0 := xpart(m[one[MID],zero[RIGHT]])-xpart(m[one[MID],zero[LEFT]]);

       draw m[one[MID],zero[TOP]]
            .. m[one[MID],zero[RIGHT]]
            .. m[one[MID],zero[BOTTOM]]
            .. m[one[MID],zero[LEFT]]
            .. cycle;
       % Bei engen Schlaufen gibt es Artefakte, daher setzen wir
       % einen Punkt in die Mitte, der diese überdeckt:
       if tmp0 < 0.1u : draw one[MID]; fi
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 1 -> 1
%

outputtemplate := "11-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

aux[BEGIN] := one[BOTTOM] shifted -(one[BEGIN]-one[TOP]);
tmppath0 := one[BEGIN]
            -- one[TOP]
            -- one[BOTTOM]
            -- aux[BEGIN];

tmppath[LEFT]  := ((0,0) -- (0,infinity)) shifted (-sw,0);
tmppath[RIGHT] := ((0,0) -- (0,infinity)) shifted  (sw,0);

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       tmppath1 := tmppath0 shifted (-2sw*m,0);

       draw tmppath1 cutbefore tmppath[LEFT] cutafter tmppath[RIGHT];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       tmppath1 := tmppath0 shifted (-2sw*(1-m),0);

       draw tmppath1 cutbefore tmppath[LEFT] cutafter tmppath[RIGHT];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 1 -> 3
%

outputtemplate := "13-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw m[one[BEGIN],three[BEGIN]]
            -- m[one[TOP],three[TOP]]
            -- m[one[BOTTOM],three[BOTTOM]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Die Bögen der 3:
tmppath[THREE_UARC] := three[BEGIN]
                       .. three[TOP]
                       .. three[U_ARC]
                       .. three[JOINT]{left};
tmppath[THREE_LARC] := three[JOINT]{right}
                       .. three[D_ARC]
                       .. three[BOTTOM]
                       .. three[END];

% Die Winkel der 3er-Kurve:
phi[TOP]    := angle(direction 1 of tmppath[THREE_UARC]);
phi[BOTTOM] := angle(direction 2 of tmppath[THREE_LARC]);
% die Winkel an der Spitze der verschobenen Eins:
phi[BEGIN]  := angle(three[TOP]-three[BEGIN]);

aux[U_ARC]  := (xpart(three[TOP]),ypart(three[U_ARC]));
aux[JOINT]  := (xpart(three[TOP]),ypart(three[JOINT]));
aux[D_ARC]  := (xpart(three[TOP]),ypart(three[D_ARC]));


for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       tmppath0 := three[BEGIN]
                   .. {dir m[phi[BEGIN],phi[TOP]]}
                      three[TOP]
                      {dir m[-90,phi[TOP]]}
                   .. m[aux[U_ARC],three[U_ARC]]
                   .. m[aux[JOINT],three[JOINT]]{dir m[-90,-180]}
                 & m[aux[JOINT],three[JOINT]]{dir m[-90,0]}
                   .. m[aux[D_ARC],three[D_ARC]]
                   .. three[BOTTOM]{dir m[-90,phi[BOTTOM]]}
                   .. three[END];
       draw subpath (0,5+m) of tmppath0;
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 1 -> 2a
%

outputtemplate := "12a-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw m[one[BEGIN],two[JOINT]]
            -- one[TOP]
            -- one[BOTTOM];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

aux[R_ARC] := ((0,ypart(two[R_ARC])) -- (infinity,ypart(two[R_ARC])))
              intersectionpoint
              (one[TOP] -- two[JOINT]);
aux[TOP]   := 1/2[one[TOP],aux[R_ARC]];

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw min(2m,1)[one[TOP],two[BEGIN]]
            .. m[aux[TOP],two[TOP]]
            .. m[aux[R_ARC],two[R_ARC]]
            .. tension 2
            .. two[JOINT];
       draw two[JOINT] -- m[two[JOINT],twoA[MID]];
       draw m[one[TOP],twoA[END]]
            -- m[one[MID],twoA[TOP]]
            -- m[one[BOTTOM],twoA[BEGIN]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 2 -> ()
%

outputtemplate := "2.mps";

tmppath[TWO_HOOK] := two[BEGIN]
                     .. two[TOP]
                     .. two[R_ARC]
                     .. tension 2 .. two[JOINT];
phi[JOINT] := angle(direction 3 of tmppath[TWO_HOOK]);

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw tmppath[TWO_HOOK]
      & two[JOINT] -- two[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% 2 -> 3
%

outputtemplate := "23-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw tmppath[TWO_HOOK]
          & two[JOINT]
            -- two[END] rotatedaround (two[JOINT],-90m);
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       aux[END] := two[END] rotatedaround (two[JOINT],-90);
       aux[BOTTOM] := 2/3[two[JOINT],aux[END]];
       aux[D_ARC]  := 1/3[two[JOINT],aux[END]];

       draw m[two[BEGIN],three[BEGIN]]
            .. m[two[TOP],three[TOP]]
            .. m[two[R_ARC],three[U_ARC]]
            .. tension (2-m)
            .. m[two[JOINT],three[JOINT]]{dir m[phi[JOINT],-180]}
          & m[two[JOINT],three[JOINT]]{dir m[-90,0]}
            .. m[aux[D_ARC],three[D_ARC]]
            .. m[aux[BOTTOM],three[BOTTOM]]
            .. m[aux[END],three[END]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 2 -> 0
%

outputtemplate := "20-%c.mps";
beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       phi[BEGIN] := angle(direction 0 of tmppath[TWO_HOOK]);

       draw m[two[BEGIN],zero[LEFT]]{dir m[phi[BEGIN],90]}
            .. m[two[TOP],zero[TOP]]
            .. m[two[R_ARC],zero[RIGHT]]
            .. tension (2-m) .. m[two[JOINT],zero[BOTTOM]];
       draw two[JOINT] -- two[END];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Ursprünglicher Winkel bei zero[BOTTOM] ist nicht
% von einem Parameter abhängig:
tmppath0 := zero[LEFT]{up}
                  .. zero[TOP]
                  .. zero[RIGHT]
                  .. zero[BOTTOM];
phi[BOTTOM] := angle(direction 3 of tmppath0);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       tmppath0 := zero[BOTTOM]{left} .. m[two[JOINT],zero[LEFT]];
       phi[JOINT] := angle(direction 1 of tmppath0);

       draw zero[LEFT]{up}
            .. zero[TOP]
            .. zero[RIGHT]
            .. zero[BOTTOM]{dir m[phi[BOTTOM],-180]};
       draw m[two[END],zero[BOTTOM]]
            -- zero[BOTTOM]{left}
            .. m[two[JOINT],zero[LEFT]]{dir max(phi[JOINT],90)};
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 2 -> 1
%

outputtemplate := "21-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

tmppath0 := tmppath[TWO_HOOK]
            & two[JOINT] -- two[END];

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw tmppath0 rotatedaround (C,180m);
       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Die rotierte Zwei wird auf Hilfspunkte verteilt:
aux[BEGIN]  := two[END]   rotatedaround (C,180);
aux[TOP]    := two[JOINT] rotatedaround (C,180);
aux[MID]    := two[R_ARC] rotatedaround (C,180);
aux[BOTTOM] := two[BEGIN] rotatedaround (C,180);
% zusätzlich:
aux[TEMP]   := two[TOP]   rotatedaround (C,180);
one[TEMP]   := 1/2[one[MID],one[BOTTOM]];

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[aux[BEGIN],one[BEGIN]]
            -- m[aux[TOP],one[TOP]]
          & m[aux[TOP],one[TOP]]
            .. tension (2-m) .. m[aux[MID],one[MID]]
            .. m[aux[TEMP],one[TEMP]]
            .. m[aux[BOTTOM],one[BOTTOM]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor


%
% 3 -> ()
%

outputtemplate := "3.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw tmppath[THREE_UARC]
      & tmppath[THREE_LARC];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% 3 -> 4
%

outputtemplate := "34-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% die Ansgangswinkel im oberen Bogen der 3:
phi[BEGIN] := angle(direction 0 of tmppath[THREE_UARC]);
phi[TOP]   := angle(direction 1 of tmppath[THREE_UARC]);
phi[U_ARC] := angle(direction 2 of tmppath[THREE_UARC]);
% die Zielwinkel in der 4:
phi[LEFT]  := angle(four[TOP]-four[LEFT]);
phi[INTER] := angle(four[INTER]-four[LEFT]);


for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw m[three[BEGIN],four[LEFT]]
            {dir m[phi[BEGIN],phi[LEFT]]}
            .. {dir m[phi[TOP],phi[LEFT]]}
               m[three[TOP],four[TOP]]
               {dir m[phi[TOP],-90]}
            .. {dir m[phi[U_ARC],-90]}
               m[three[U_ARC],four[INTER]]
               {dir m[phi[U_ARC],phi[INTER]-180]}
            .. {dir m[180,phi[INTER]+180]}
               m[three[JOINT],four[LEFT]]
          & m[three[JOINT],four[LEFT]]{right}
            .. three[D_ARC]
            .. three[BOTTOM]
            .. three[END];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Winkel am verbliebenen unteren Bogen:
tmppath0 := four[LEFT]{right}
            .. three[D_ARC]
            .. three[BOTTOM]
            .. three[END];
phi[D_ARC]  := angle(direction 1 of tmppath0);
phi[BOTTOM] := angle(direction 2 of tmppath0);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       tmppath0 := four[LEFT]{dir m[0,phi[INTER]]}
                   .. {dir m[phi[D_ARC],phi[INTER]]}
                      m[three[D_ARC],four[INTER]]
                      {dir m[phi[D_ARC],-90]}
                   .. m[three[BOTTOM],four[BOTTOM]]
                      {dir m[phi[BOTTOM],270]}
                   .. m[three[END],three[BOTTOM]];
                   % wir ziehen den Endpunkt zum tiefsten Punkt,
                   % um einen schöneren Bogen zu erhalten.

       draw four[LEFT]
            -- four[TOP]
            -- four[INTER]
            -- cycle;

       draw subpath (0,3-m) of tmppath0;

       draw four[INTER]
            -- m[four[INTER],four[RIGHT]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 3 -> 0
%

outputtemplate := "30-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Übergang oberer Bogen Drei zur Dreiviertel-Null
phi[BEGIN] := angle(direction 0 of tmppath[THREE_UARC]);

% Der untere Bogen soll zu einem senkrecht nach unten geklappten
% Viertelsegment der Null werden:
tmppath1  := zero[BOTTOM]{left} .. zero[LEFT]{up};
phi[TEMP] := 270-angle(zero[LEFT]-zero[BOTTOM]);

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       aux[JOINT]  := m[three[JOINT],zero[BOTTOM]];
       aux[BOTTOM] := (point 2/3 of tmppath1) rotatedaround (zero[BOTTOM],phi[TEMP]);
       aux[D_ARC]  := (point 1/3 of tmppath1) rotatedaround (zero[BOTTOM],phi[TEMP]);
       aux[END]    := zero[LEFT]              rotatedaround (zero[BOTTOM],phi[TEMP]);

       draw m[three[BEGIN],zero[LEFT]]{dir m[phi[BEGIN],90]}
            .. m[three[TOP],zero[TOP]]
            .. m[three[U_ARC],zero[RIGHT]]
            .. aux[JOINT]{left}
          & aux[JOINT]{right}
            .. m[three[D_ARC],aux[D_ARC]]
            .. m[three[BOTTOM],aux[BOTTOM]]
            .. m[three[END],aux[END]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw zero[LEFT]{up}
            .. zero[TOP]
            .. zero[RIGHT]
            .. zero[BOTTOM]{left}
            % Der Viertelbogen klappt nach oben:
          & tmppath1 rotatedaround (zero[BOTTOM],(1-m)*phi[TEMP]);
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 4 -> ()
%

outputtemplate := "4.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw four[RIGHT]
        -- four[LEFT]
        -- four[TOP]
        -- four[BOTTOM];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% 4 -> 5
%

outputtemplate := "45-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw four[TOP]
            -- four[LEFT]
            -- m[four[RIGHT],four[INTER]];
       draw m[four[TOP],four[INTER]]
            -- four[BOTTOM];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Einige Winkel:
tmppath0 := five[JOINT]
            .. five[U_ARC]
            .. five[R_ARC]
            .. {left}five[END];
phi[U_ARC] := angle(direction 1 of tmppath0);
phi[INTER] := angle(four[INTER]-four[LEFT]);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw five[BEGIN]
            -- m[four[TOP],five[LEFT]]
            -- m[four[LEFT],five[JOINT]]
            .. m[four[INTER],five[U_ARC]]{dir m[phi[INTER],phi[U_ARC]]}
            .. m[four[INTER],five[R_ARC]]
            .. m[four[BOTTOM],five[END]]{dir m[-90,-180]};
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 5 -> ()
%

outputtemplate := "5.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw five[BEGIN]
        -- five[LEFT]
        -- five[JOINT]
        .. five[U_ARC]
        .. five[R_ARC]
        .. {left}five[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% 5 -> 6
%

outputtemplate := "56-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% wir gehen hier nur bis fpht-1, weil bei fpht die Schleife geschlossen wäre
% und sich die Zeichenrichtung umdreht:
for i = start+1 upto start+fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       % die linke Ecke five[LEFT] wandert genauso schnell nach oben wie
       % five[BEGIN], aber die x-Koordinate bleibt unverändert:

       aux[LEFT] := (xpart(five[LEFT]),ypart(m[five[BEGIN],six[BEGIN]]));

       draw m[five[BEGIN],six[BEGIN]]
            -- aux[LEFT]
            -- m[five[JOINT],six[LEFT]];
       draw m[five[JOINT],six[LEFT]]
            .. m[five[U_ARC],six[TOP]]
            .. m[five[R_ARC],six[RIGHT]]
            .. {left}m[five[END],six[BOTTOM]]
            .. m[five[END],six[LEFT]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);
       t := 1/(m+0.001); % m kann Null werden

       % wir ermitteln den Punkt, der auf 2/3 des abschließenden Bogens liegt;
       % aux[TEMP] wandert von der linken Ecke der nach oben geschobenen "5"
       % zum Zielpunkt.
       % Weil er dann auf dem Bogen liegt, kann er bei der "6" einfach
       % weggelassen weden.

       tmppath0   := six[LEFT]{up} .. six[BEGIN];
       aux[END]   := point 2/3 of tmppath0;
       aux[BEGIN] := (xpart(five[LEFT]),ypart(six[BEGIN]));
       aux[TEMP]   := m[aux[BEGIN],aux[END]];

       draw six[LEFT]{up}
            .. six[TOP]
            .. six[RIGHT]
            .. six[BOTTOM]
            .. six[LEFT]{up}
            .. tension t .. aux[TEMP]
            .. tension t .. six[BEGIN];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 5 -> 0
%

outputtemplate := "50-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% wir gehen hier nur bis fpht-1, weil bei fpht die Schleife geschlossen wäre
% und sich die Zeichenrichtung umdreht (siehe Übergang 5 -> 6):
for i = start+1 upto start+fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       tmppath0 := m[five[JOINT],zero[LEFT]]
                   .. m[five[U_ARC],zero[TOP]]
                   .. m[five[R_ARC],zero[RIGHT]]
                   .. {left}m[five[END],zero[BOTTOM]]
                   .. m[five[END],zero[LEFT]]{up};

       phi1 := min(angle(direction 0 of tmppath0),90);

       draw m[five[BEGIN],five[LEFT]]
            -- five[LEFT]
            -- m[five[JOINT],zero[LEFT]]
          & m[five[JOINT],zero[LEFT]]{dir phi1}
            .. m[five[U_ARC],zero[TOP]]
            .. m[five[R_ARC],zero[RIGHT]]
            .. {left}m[five[END],zero[BOTTOM]]
            .. m[five[END],zero[LEFT]]{up};
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw zero[LEFT]{up}
            .. zero[TOP]
            .. zero[RIGHT]
            .. zero[BOTTOM]
            .. zero[LEFT]{up}
            -- m[five[LEFT],zero[LEFT]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 6 -> ()
%

outputtemplate := "6.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw six[LEFT]{up}
        .. six[TOP]
        .. six[RIGHT]
        .. six[BOTTOM]
        .. six[LEFT]{up}
        .. six[BEGIN];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% 6 -> 7
%

outputtemplate := "67-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       q := 2m*m-2*m+1;
         % Parabelabschnitt y = 1 .. 1/2 .. 1 für x = 0 .. 0.5 .. 1;

       aux[MID]   := six[LEFT]              rotatedaround (C,180m);
       aux[END]   := (six[BEGIN] yscaled q) rotatedaround (C,180m);
       aux[TOP]   := six[RIGHT]             rotatedaround (C, 90m);
       aux[LEFT]  := six[TOP]               rotatedaround (C, 45m);
       aux[JOINT] := six[BOTTOM]            rotatedaround (C,135m);
       aux[BEGIN] := (-sw,xh/2);

       draw m[six[LEFT],aux[BEGIN]]
            ... aux[LEFT]
            ... aux[TOP]
            ... aux[JOINT]
            .. aux[MID]{dir m[90,270]}
            .. aux[END];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Die Ausgangswinkel werden bestimmt:
tmppath0 := aux[BEGIN]
            ... aux[LEFT]
            ... aux[TOP]
            ... aux[JOINT]
            .. aux[MID]{down}
            .. aux[END];
phi[LEFT]  := angle(direction 1 of tmppath0);
phi[TOP]   := angle(direction 2 of tmppath0);
phi[JOINT] := angle(direction 3 of tmppath0);
% Ein Endwinkel ist notwendig:
tmppath1 :=seven[JOINT]{down}
           .. seven[MID]
           .. seven[END];
phi[MID] := angle(direction 1 of tmppath1);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);
       t := max(30m*m,1);

       draw m[aux[BEGIN],seven[BEGIN]]
            .. {dir m[phi[LEFT],90]}
               m[aux[LEFT],seven[LEFT]]
               {dir m[phi[LEFT],0]}
            .. m[aux[TOP],seven[TOP]]{dir m[phi[TOP],0]}
            .. {dir m[phi[JOINT],0]}
               m[aux[JOINT],seven[JOINT]]
               {dir m[phi[JOINT],-90]}
            .. m[aux[MID],seven[MID]]{dir min(2m,1)[-90,phi[MID]]}
            .. m[aux[END],seven[END]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 6 -> 0
%

outputtemplate := "60-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw m[six[LEFT],C]{up}
        .. m[six[TOP],C]
        .. m[six[RIGHT],C]
        .. m[six[BOTTOM],C]
        .. m[six[LEFT],C]{up}
        .. m[six[BEGIN],C];

       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw min(2m,1)[C,zero[TOP]]{dir max(2m-1,0)[-90,0]}
            .. {dir max(2m-1,0)[0,-90]}
               min(2m,1)[C,zero[RIGHT]]
               {dir max(2m-1,0)[-180,-90]}
            .. {dir max(2m-1,0)[-90,-180]}
               min(2m,1)[C,zero[BOTTOM]]
               {dir max(2m-1,0)[90,180]}
            .. {dir max(2m-1,0)[180,90]}
               min(2m,1)[C,zero[LEFT]]
               {dir max(2m-1,0)[0,90]}
            .. {dir max(2m-1,0)[90,0]}cycle;
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 7 -> ()
%

outputtemplate := "7.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw seven[BEGIN]
        -- seven[LEFT]
        -- seven[JOINT]{down}
        .. seven[MID]
        .. seven[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% 7 -> 8
%

outputtemplate := "78-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       tmppath1 := m[seven[BEGIN],seven[LEFT]]
                   -- seven[LEFT]
                   -- seven[JOINT]{down}
                   .. seven[MID]
                   .. seven[END];

       % der Mittelstrich wächst aus der Mitte der Höhe der Sieben:
       tmp0 := 1/2[ypart(seven[LEFT]),ypart(seven[END])];
       aux[INTER] := ((-infinity,tmp0)--(infinity,tmp0)) intersectionpoint tmppath1;
       aux[LEFT]  := aux[INTER] - (0.15u,0);
       aux[RIGHT] := aux[INTER] + (0.15u,0);

       draw tmppath1;
       draw m[aux[INTER],aux[LEFT]] -- m[aux[INTER],aux[RIGHT]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor


% aux[BOTTOM] wandert zu eight[BOTTOM];
% weil aux[LEFT] schon belegt ist, nennen wir den
% zweiten Hilfspunkt aux[TEMP];
tmppath0 := seven[JOINT]{down}
            .. seven[MID]
            .. seven[END];
aux[BOTTOM] := point 1.75 of tmppath0;
aux[TEMP]   := point 1.5  of tmppath0;
phi[END]    := 180+angle(direction 2 of tmppath0);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[seven[END],eight[RIGHT]]{dir m[phi[END],270]}
            .. m[aux[BOTTOM],eight[BOTTOM]]
            .. m[aux[TEMP],eight[LEFT]]
            .. m[seven[MID],eight[MID]]
            .. {up}m[seven[JOINT],eight[R_ARC]]{dir m[180,90]}
            .. m[seven[TOP],eight[TOP]]{left}
            .. m[seven[LEFT],eight[L_ARC]]{dir m[180,270]};
       draw m[aux[LEFT],eight[L_ARC]]{dir m[0,-90]}
            .. m[aux[INTER],eight[MID]]
            .. m[aux[RIGHT],eight[RIGHT]]{dir m[0,-90]};
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 8 -> ()
%

outputtemplate := "8.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw eight[TOP]
        .. eight[R_ARC]
        .. eight[MID]
        .. eight[LEFT]
        .. eight[BOTTOM]
        .. eight[RIGHT]
        .. eight[MID]
        .. eight[L_ARC]
        .. cycle;
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% 8 -> 9
%

outputtemplate := "89-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Die Acht kippt um 90° nach rechts,
% aus eight[MID] wird nine[RIGHT] etc.
% Um zu skalieren, drehen wir daher
% nine[RIGHT|LEFT|TOP|BOTTOM] um 90° nach links:

aux[MID]    := nine[RIGHT]  rotatedaround (C,90);
aux[BOTTOM] := nine[LEFT]   rotatedaround (C,90);
aux[LEFT]   := nine[TOP]    rotatedaround (C,90);
aux[RIGHT]  := nine[BOTTOM] rotatedaround (C,90);

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       % Wir ändern die Punktreihenfolge, um bei i=830
       % eine geschlossene Schleife zu bekommen:

       tmppath1 := m[eight[LEFT],aux[LEFT]]
                   .. m[eight[BOTTOM],aux[BOTTOM]]
                   .. m[eight[RIGHT],aux[RIGHT]]
                   .. m[eight[MID],aux[MID]]
                   if i < start+fpht:
                      .. m[eight[L_ARC],aux[MID]]
                      .. m[eight[TOP],aux[MID]]
                      .. m[eight[R_ARC],aux[MID]]
                      .. m[eight[MID],aux[MID]]
                   fi
                   .. cycle;

       draw tmppath1 rotatedaround (C,-90m*m);
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       % Der Endpunkt des Bogens wandert von nine[RIGHT] ausgehend am
       % tatsächlichen Bogen entlang:

       tmppath0 := nine[RIGHT]{down} .. nine[END];
       aux[END] := point m of tmppath0;

       draw nine[RIGHT]{down}
            .. nine[BOTTOM]
            .. nine[LEFT]
            .. nine[TOP]
            .. nine[RIGHT]{down}
            .. aux[END];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 8 -> 1
%

outputtemplate := "81-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% die Schlaufen werden schmäler:
aux[U_ARC] := 1/2[eight[L_ARC],eight[R_ARC]];
aux[D_ARC] := 1/2[eight[LEFT],eight[RIGHT]];

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw eight[MID]
            .. m[eight[LEFT],aux[D_ARC]]
            .. {dir max(2m-1,0)[0,-90]}
               eight[BOTTOM]
               {dir max(2m-1,0)[0,90]}
            .. m[eight[RIGHT],aux[D_ARC]]
            .. eight[MID]
            .. m[eight[L_ARC],aux[U_ARC]]
            .. {dir max(2m-1,0)[0,90]}
               eight[TOP]
               {dir max(2m-1,0)[0,-90]}
            .. m[eight[R_ARC],aux[U_ARC]]
            ..cycle;
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[eight[TOP],one[BEGIN]]
            -- m[eight[MID],one[TOP]]
            -- m[eight[BOTTOM],one[BOTTOM]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 9 -> ()
%

outputtemplate := "9.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw nine[RIGHT]{down}
        .. nine[BOTTOM]
        .. nine[LEFT]
        .. nine[TOP]
        .. nine[RIGHT]{down}
        .. nine[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% 9 -> 0
%

outputtemplate := "90-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       % Der Bogen der Neun soll beim Aufwickeln ein bisschen
       % nach links gestreckt werden:

       q := -2m*m+2m+1; % durchläuft 1 .. 3/2 .. 1 für x = 0 .. 0.5 .. 1;
       aux[END] := m[nine[END],nine[LEFT]] xscaled q;

       % wir legen einen Hilfspunkt dort an, wo der untere Bogen die
       % y-Achse schneidet. Steigt der y-Wert des Hilfspunktes über
       % die Unterkante der geschlossenen Schleife, wird als y-Koordinate
       % die Unterkante der Schleife gewählt, um zu verhindern, dass
       % der Bogen beim "Aufwickeln" ins Innere der geschlossenen Schleife
       % ragt.

       tmppath0 := nine[RIGHT]{down} .. aux[END];
       aux[INTER] := ((0,-infinity)--(0,infinity)) intersectionpoint tmppath0;
       tmp0 := ypart(aux[INTER]);
       tmp1 := ypart(aux[BOTTOM]);
       aux[MID] := (0,min(tmp0,tmp1));

       draw nine[RIGHT]{down}
            .. nine[BOTTOM]
            .. nine[LEFT]
            .. nine[TOP]
            .. nine[RIGHT]{down}
            .. aux[MID]
            .. aux[END];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[nine[TOP],zero[TOP]]
            .. m[nine[RIGHT],zero[RIGHT]]
            .. m[nine[BOTTOM],zero[BOTTOM]]
            .. m[nine[LEFT],zero[LEFT]]
            .. cycle;
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 9 -> 1
%

outputtemplate := "91-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

aux[END] := (xpart(nine[RIGHT]),ypart(nine[END]));
% Verschiebung: wir schieben die Neun so, dass sie rechts und oben
% mit der oberen Spitze konform liegt:
aux[DIFF] := (xpart(one[TOP])-xpart(nine[RIGHT]),
              ypart(one[TOP])-ypart(nine[TOP]));

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       tmppath0 := nine[RIGHT]{down}
                   .. nine[BOTTOM]
                   .. nine[LEFT]
                   .. nine[TOP]
                   .. nine[RIGHT]{down}
                   .. m[nine[END],aux[END]];
       draw tmppath0 shifted m[(0,0),aux[DIFF]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

% die verschobene Neun:
aux[RIGHT]  := nine[RIGHT]  shifted aux[DIFF];
aux[BOTTOM] := nine[BOTTOM] shifted aux[DIFF];
aux[LEFT]   := nine[LEFT]   shifted aux[DIFF];
aux[TOP]    := nine[TOP]    shifted aux[DIFF];
aux[END]    := aux[END]     shifted aux[DIFF];

% der Winkel der Eins:
phi[TOP]    := angle(one[TOP]-aux[BEGIN]);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       tmppath0 := aux[RIGHT]{down}
                   .. aux[BOTTOM]
                   .. m[aux[LEFT],one[BEGIN]]{dir m[90,phi[TOP]]}
                   .. {dir max(2m-1,0)[0,phi[TOP]]}
                      m[aux[TOP],one[TOP]]
                      {dir max(2m-1,0)[0,-90]}
                   .. aux[RIGHT]{down}
                   .. m[aux[END],one[BOTTOM]];
       draw subpath (2m,5) of tmppath0;
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 2a -> ()
%

outputtemplate := "2a.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw tmppath[TWO_HOOK]
      & two[JOINT] -- twoA[MID];
   draw twoA[BEGIN]
        -- twoA[TOP]
        -- twoA[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% 2a -> 2b
%

outputtemplate := "2a2b-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Hilfspunkte: aux[MID] ist der Schnittpunkt vom
% verlängerten 2-"Fuß" zum senkrechten rechten A-Strich,
% aux[END] das Ende des rechten A-Strichs:
aux[MID] := (xpart(twoB[U_ARC]),ypart(two[JOINT]));
aux[END] := (xpart(twoB[U_ARC]),ypart(twoB[BOTTOM]));

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw tmppath[TWO_HOOK]
          & two[JOINT] -- twoA[MID];
       draw m[twoA[BEGIN],twoB[BOTTOM]]
            -- m[twoA[TOP],twoB[TOP]]
            -- m[twoA[TOP],twoB[U_ARC]]
            -- m[twoA[END],aux[END]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

aux[D_ARC] := 2/3[twoB[U_ARC],aux[END]];

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);
       t := 1/m;

       draw tmppath[TWO_HOOK]
          & two[JOINT]
            -- m[aux[MID],twoB[MID]];
       draw twoB[TOP] -- twoB[BOTTOM];
       draw twoB[TOP]
            .. tension t .. twoB[U_ARC]
            .. tension t .. m[aux[MID],twoB[MID]];
       draw m[aux[MID],twoB[MID]]
            .. m[aux[D_ARC],twoB[D_ARC]]
            .. m[aux[END],twoB[BOTTOM]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 2b -> ()
%

outputtemplate := "2b.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw tmppath[TWO_HOOK]
      & two[JOINT] -- twoB[MID];
   draw twoB[TOP]
        .. twoB[U_ARC]
        .. twoB[MID];
   draw twoB[MID]
        .. twoB[D_ARC]
        .. twoB[BOTTOM];
   draw twoB[TOP] -- twoB[BOTTOM];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% 2b -> 3
%

outputtemplate := "2b3-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       tmppath0 := twoB[TOP]
                   .. twoB[U_ARC]
                   .. twoB[MID];
       draw tmppath[TWO_HOOK]
          & two[JOINT] -- twoB[MID];
       draw subpath (2m,2) of tmppath0;
       draw twoB[MID]
            .. twoB[D_ARC]
            .. twoB[BOTTOM];
       draw twoB[TOP] -- twoB[BOTTOM];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Der Übergang des 2-Bogens zum oberen 3-Bogen
% läuft analog zum Übergang 2 -> 3, wir brauchen
% daher nochmal den Winkel an der Spitze:
phi[JOINT] := angle(direction 3 of tmppath[TWO_HOOK]);

% Ein Hilfspunkt im unteren B-Bogen, der zu
% three[BOTTOM] wandert:
tmppath0 := twoB[MID]
            .. twoB[D_ARC]
            .. twoB[BOTTOM];
aux[BOTTOM] := point 1.5 of tmppath0;
phi[MID]    := angle(direction 0 of tmppath0);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       aux[END] := m[twoB[BOTTOM],three[END]];
       draw m[two[BEGIN],three[BEGIN]]
            .. m[two[TOP],three[TOP]]
            .. m[two[R_ARC],three[U_ARC]]
            .. tension (2-m)
            .. m[two[JOINT],three[JOINT]]{dir m[phi[JOINT],-180]};
       draw m[two[JOINT],three[JOINT]]
            -- m[twoB[MID],three[JOINT]];
       draw m[twoB[MID],three[JOINT]]{dir m[phi[MID],0]}
            .. m[twoB[D_ARC],three[D_ARC]]
            .. m[aux[BOTTOM],three[BOTTOM]]
            .. aux[END];
       draw m[twoB[TOP],aux[END]]
            -- aux[END];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Part II: Interpunktion
%
%  #  #   #  #####  #####  ####   ####   #   #  #   #  #   #  #####
%  #  ##  #    #    #      #   #  #   #  #   #  ##  #  #  #     #
%  #  # # #    #    ###    ####   ####   #   #  # # #  ###      #
%  #  #  ##    #    #      #  #   #      #   #  #  ##  #  #     #
%  #  #   #    #    #####  #   #  #       ###   #   #  #   #    #    #
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% "*"
asterisk[TOP] = (0,xh-dy);
asterisk[BOTTOM] = (0,xh/2+dy);

% ","
comma[TOP]    = (-sw/2,corr);
comma[BOTTOM] = (-sw,-dy);

% "-"
dash[LEFT]  = (-sw/2,xh/2);
dash[RIGHT] = dash[LEFT] xscaled -1;

% "."
dot[CENTER] = comma[TOP];

% "/"
slash[BEGIN] = (-sw/2,2dy);
slash[END]   = (sw/2,xh-2dy);

% ":"
colon[TOP]    = (0,xh-dy);
colon[BOTTOM] = (0,dy);



%
%%%%%%%%%%%% Interpunktion/Übergänge
%

%
% * -> ()
%

outputtemplate := "asterisk.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   tmppath0 := asterisk[TOP]
               -- asterisk[BOTTOM];

   for i = 0 upto 4:
      draw tmppath0 rotatedaround (C,72*i);
   endfor

   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% , -> ()
%

outputtemplate := ",.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw comma[TOP]{down}
        .. comma[BOTTOM];

   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% - -> ()
%

outputtemplate := "dash.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw dash[LEFT] -- dash[RIGHT];

   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% . -> ()
%

outputtemplate := "dot.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw dot[CENTER];

   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% / -> ()
%

outputtemplate := "slash.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw slash[BEGIN] -- slash[END];

   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% : -> ()
%

outputtemplate := ":.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw colon[TOP];
   draw colon[BOTTOM];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% ":" -> ":"
%

outputtemplate := "::-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

aux[TOP]    := (0,(xh+pendia)/2);
aux[BOTTOM] := (0,(xh-pendia)/2);

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw m[colon[TOP],aux[TOP]];
       draw m[colon[BOTTOM],aux[BOTTOM]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[aux[TOP],colon[TOP]];
       draw m[aux[BOTTOM],colon[BOTTOM]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% ~ -> ()
%

outputtemplate := "tilde.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Part III: Buchstaben
%
%   ###         #####
%  #   #           #
%  #####   ###    #
%  #   #         #
%  #   #        #####
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% a
_a_[BEGIN]  = (-sw,12/17*xh);
_a_[TOP]    = zero[TOP];
_a_[R_ARC]  = (mw,12/17*xh);
_a_[JOINT]  = (mw,0.15u);
_a_[END]    = (iw,0);
_a_[L_ARC]  = _a_[JOINT] xscaled -1;
_a_[BOTTOM] = zero[BOTTOM];

% b
_b_[BEGIN]  = (xpart(_p_[BEGIN]),asc);
_b_[END]    = (xpart(_p_[END]),0);
_b_[U_ARC]  = _p_[U_ARC];
_b_[D_ARC]  = _p_[D_ARC];
_b_[TOP]    = _p_[TOP];
_b_[BOTTOM] = _p_[BOTTOM];
_b_[RIGHT]  = _p_[RIGHT];

% c
_c_[LEFT]   = (-iw,xh/2);
_c_[RIGHT]  = _c_[LEFT] xscaled -1;
_c_[TOP]    = zero[TOP];
_c_[BOTTOM] = zero[BOTTOM];
% Schnittpunkt zwischen o-Bogen und einer Halbgeraden
_c_[BEGIN] = (_c_[RIGHT]{up} .. _c_[TOP]{left})
             intersectionpoint
             (((0,0) -- (infinity,0)) rotated 35 shifted C);
_c_[END]   = (_c_[RIGHT]{down} .. _c_[BOTTOM]{left})
             intersectionpoint
             (((0,0) -- (infinity,0)) rotated -35 shifted C);

% d
_d_[BEGIN]  = _b_[BEGIN] xscaled -1;
_d_[END]    = _b_[END] xscaled -1;
_d_[U_ARC]  = _b_[U_ARC] xscaled -1;
_d_[D_ARC]  = _b_[D_ARC] xscaled -1;
_d_[TOP]    = _b_[TOP] xscaled -1;
_d_[BOTTOM] = _b_[BOTTOM] xscaled -1;
_d_[LEFT]  = _b_[RIGHT] xscaled -1;

% e
_e_[LEFT]   = _c_[LEFT];
_e_[RIGHT]  = _c_[RIGHT];
_e_[TOP]    = _c_[TOP];
_e_[BOTTOM] = _c_[BOTTOM];
_e_[END]    = _c_[END];

% f
_f_[BEGIN]  = (-iw+corr,0);
_f_[MID]    = (-iw+corr,asc-iw);
_f_[TOP]    = (corr, asc);
_f_[END]    = _f_[TOP] rotatedaround
              ((xpart(_f_[TOP]),ypart(_f_[MID])),-45);

_f_[LEFT]   = (-iw-0.10u+corr,xh-dy);
_f_[RIGHT]  = (-iw+0.15u+corr,xh-dy);

% g
_g_[TOP]    = (0,xh);
_g_[LEFT]   = (-iw,1/2*(xh+dy));
_g_[RIGHT]  = _g_[LEFT] xscaled -1;
_g_[BOTTOM] = (0,dy);

_g_[BEGIN]  = (sw,xh); % "Schwänzchen" oben rechts

_g_[U_ARC]  = (-dy,-2/3*dy);
_g_[L_ARC]  = (-lw,-sw);
_g_[R_ARC]  = (lw,-sw);
_g_[D_ARC]  = (0,dsc);
_g_[END]    = (dy,-2/3*dy);

% Wir berechnen den Schnittpunkt der geschlossenen oberen Schlaufe
% mit einer Halbgeraden im Zentrum dieser Schlaufe unter einem
% Winkel von 135°:
tmppath[G_LOOP] := _g_[TOP]
                   .. _g_[LEFT]
                   .. _g_[BOTTOM]
                   .. _g_[RIGHT]
                   .. cycle;
_g_[CENTER] := (0,1/2[ypart(_g_[TOP]),ypart(_g_[BOTTOM])]);
tmppath1    := (_g_[CENTER] -- (0,infinity)) rotatedaround (_g_[CENTER],135);
_g_[JOINT]  := tmppath[G_LOOP] intersectionpoint tmppath1;
% Der Richtungsvektor in diesem Punkt:
tmp[JOINT]  := xpart(tmppath[G_LOOP] intersectiontimes tmppath1);
_g_[DIR]    := direction tmp[JOINT] of tmppath[G_LOOP];

% h
_h_[BEGIN] = (-mw,asc);
_h_[LEFT]  = (-mw,3/4*xh);
_h_[BOTTOM] = (-mw,0);
_h_[MID]   = (0,xh);
_h_[RIGHT] = _h_[LEFT] xscaled -1;
_h_[END]   = _h_[BOTTOM] xscaled -1;

% i
_i_[TOP]    = (-iw+corr,2/3[xh,asc]);
_i_[BEGIN]  = (-iw+corr,xh);
_i_[MID]    = (-iw+corr,iw);
_i_[BOTTOM] = (corr,0);
_i_[END]    = _i_[BOTTOM] rotatedaround
              ((xpart(_i_[BOTTOM]),ypart(_i_[MID])),45);

% j
_j_[TOP]    = _i_[TOP] xscaled -1;
_j_[BEGIN]  = _i_[BEGIN] xscaled -1;
_j_[MID]    = (iw-corr,dsc+iw);
_j_[BOTTOM] = (-corr,dsc);
_j_[END]    = _j_[BOTTOM] rotatedaround
              ((xpart(_j_[BOTTOM]),ypart(_j_[MID])),-45);

% k
_k_[BEGIN]  = (-sw,asc);
_k_[END]    = (-sw,0);
_k_[MID]    = (-sw,xh/2);
_k_[TOP]    = (sw,xh);
_k_[BOTTOM] = (sw,0);

% l
_l_[BEGIN]  = (-iw+corr,asc);
_l_[MID]    = _i_[MID];
_l_[BOTTOM] = _i_[BOTTOM];
_l_[END]    = _i_[END];

% m
_m_[BEGIN] = (-iw,xh);
_m_[LEFT]  = (-iw,3/4*xh);
_m_[BOTTOM] = (-iw,0);
_m_[L_ARC] = (-iw/2,xh);
_m_[JOINT] = (0,13/17*xh);
_m_[MID]   = (0,0);
_m_[R_ARC] = _m_[L_ARC] xscaled -1;
_m_[RIGHT] = _m_[LEFT] xscaled -1;
_m_[END]   = _m_[BOTTOM] xscaled -1;

% n
_n_[BEGIN] = (-mw,xh);
_n_[LEFT]  = (-mw,3/4*xh);
_n_[BOTTOM] = (-mw,0);
_n_[MID]   = (0,xh);
_n_[RIGHT] = _n_[LEFT] xscaled -1;
_n_[END]   = _n_[BOTTOM] xscaled -1;

% o
_o_[LEFT]   = _c_[LEFT];
_o_[RIGHT]  = _c_[RIGHT];
_o_[TOP]    = _c_[TOP];
_o_[BOTTOM] = _c_[BOTTOM];

% p
_p_[BEGIN]  = (-iw,xh);
_p_[END]    = (-iw,dsc);
_p_[U_ARC]  = (-iw,12/17*xh); % [u]pper end of [arc]
_p_[D_ARC]  = (-iw,0.15u);
_p_[TOP]    = zero[TOP];
_p_[BOTTOM] = zero[BOTTOM];
_p_[RIGHT]  = (iw,xh/2);

% q
_q_[BEGIN]  = _p_[BEGIN] xscaled -1;
_q_[END]    = _p_[END]   xscaled -1;
_q_[U_ARC]  = _p_[U_ARC] xscaled -1;
_q_[D_ARC]  = _p_[D_ARC] xscaled -1;
_q_[TOP]    = zero[TOP];
_q_[BOTTOM] = zero[BOTTOM];
_q_[LEFT]   = _p_[RIGHT] xscaled -1;

% r
_r_[BEGIN]  = (-iw+corr,xh);
_r_[BOTTOM] = (-iw+corr,0);
_r_[MID]    = (-iw+corr,xh-iw);
_r_[TOP]    = (corr,xh);
_r_[END]    = _r_[TOP] rotatedaround
              ((xpart(_r_[TOP]),ypart(_r_[MID])),-45);

% s
_s_[BEGIN]  = (sw,3/4*xh);
_s_[TOP]    = _o_[TOP];
_s_[U_ARC]  = _s_[BEGIN] xscaled -1;
_s_[MID]    = C;
_s_[D_ARC]  = (1/2(mw+iw),xh/4);
_s_[BOTTOM] = _o_[BOTTOM];
_s_[END]    = _s_[D_ARC] xscaled -1;

% t
_t_[LEFT]   = _f_[LEFT];
_t_[RIGHT]  = _f_[RIGHT];

_t_[BEGIN]  = _l_[BEGIN];
_t_[MID]    = _l_[MID];
_t_[BOTTOM] = _l_[BOTTOM];
_t_[END]    = _l_[END];

_t_[INTER]  = (_t_[LEFT] -- _t_[RIGHT]) intersectionpoint
              (_t_[BEGIN] -- _t_[MID]); % Schnittpunkt Querstrich/Stamm

% u
_u_[BOTTOM] = _n_[BEGIN]  rotatedaround(C,180);
_u_[RIGHT]  = _n_[LEFT]   rotatedaround(C,180);
_u_[BEGIN]  = _n_[END]    rotatedaround(C,180);
_u_[MID]    = _n_[MID]    rotatedaround(C,180);
_u_[LEFT]   = _n_[RIGHT]  rotatedaround(C,180);
_u_[END]    = _n_[BOTTOM] rotatedaround(C,180);

% v
_v_[LEFT] = (-mw,xh);
_v_[BOTTOM] = (0,0);
_v_[RIGHT] = _v_[LEFT] xscaled -1;

% w
_w_[BEGIN] = _m_[BEGIN];
_w_[LEFT]  = (1/2*xpart(_w_[BEGIN]),0);
_w_[MID]   = (0,xh);
_w_[RIGHT] = _w_[LEFT] xscaled -1;
_w_[END] = _w_[BEGIN] xscaled -1;

% x
_x_[LEFT]  = (-mw,xh);
_x_[RIGHT] = _x_[LEFT] xscaled -1;
_x_[BEGIN] = (-mw,0);
_x_[END]   = _x_[BEGIN] xscaled -1 ;

% y
_y_[BOTTOM] = _u_[BOTTOM];
_y_[D_ARC] = (-sw,dsc);
_y_[RIGHT]  = _u_[RIGHT];
_y_[BEGIN] = _u_[BEGIN];
_y_[MID] = _u_[MID];
_y_[LEFT] = _u_[LEFT];
_y_[END] = _u_[END];

% z
_z_[BEGIN] = _x_[LEFT];
_z_[U_ARC] = _x_[RIGHT];
_z_[D_ARC] = _x_[BEGIN];
_z_[END]   = _x_[END];

%
%%%%%%%%%%%% Buchstaben/Übergänge
%

%
% a -> ()
%

tmppath[A_SWEEP] := _a_[BEGIN]
                    ..  _a_[TOP]
                    ..  _a_[R_ARC]
                    --- _a_[JOINT]
                    .. _a_[END];
_a_[DIR] := direction 2 of tmppath[A_SWEEP];
phi[R_ARC] := angle(direction 2 of tmppath[A_SWEEP]);

tmppath[A_LOOP] := _a_[R_ARC]{_a_[DIR]}
                   .. _a_[L_ARC]
                   .. _a_[BOTTOM]
                   .. _a_[JOINT];

outputtemplate := "a.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw tmppath[A_SWEEP];
   draw tmppath[A_LOOP];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% a -> e
%

outputtemplate := "ae-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% weitere Winkel
phi[BEGIN] := angle(direction 0 of tmppath[A_SWEEP]);

tmppath3 := _a_[TOP]
            .. _a_[R_ARC]
           --- _a_[JOINT]
            .. _a_[BOTTOM]
            .. _a_[L_ARC]
            .. _a_[BEGIN]
            .. cycle;

% Wir nennen den Winkel an _a_[BEGIN]
% phi[U_ARC], weil phi[BEGIN] schon vergeben ist;
phi[U_ARC] := angle(direction 5 of tmppath3);

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       % der äußere Bogenzug wird nahezu unverändert
       % gezeichnet, nur der Winkel bei _a_[BEGIN]
       % nähert sich dem der geschlossenen a-Figur:
       tmppath1 := _a_[BEGIN]{dir m[phi[BEGIN],phi[U_ARC]]}
                   .. _a_[TOP]
                   .. _a_[R_ARC]
                  --- _a_[JOINT]
                   .. _a_[END];

       % der Hilfspunkt aux[R_ARC] wandert von _a_[R_ARC]
       % über _a_[TOP] zu _a_[BEGIN] am a-Bogen entlang;
       aux[R_ARC] := point (2-2m) of tmppath1;

       draw tmppath1;
       draw aux[R_ARC]{dir m[phi[R_ARC],phi[U_ARC]-180]}
            .. _a_[L_ARC]
            .. _a_[BOTTOM]
            .. _a_[JOINT];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

% wir setzen einen Hilfspunkt in der oberen Hälfte des
% e-Bogens: zwei zwischen _e_[LEFT] und _e_[TOP] sowie
% einen zwischen _e_[TOP] und _e_[RIGHT].
tmppath0 := (_e_[LEFT]{up}
            .. _e_[TOP]
            .. _e_[RIGHT]{down}) rotatedaround (C,90);
aux[L_ARC] := point 1/6 of tmppath0;
aux[U_ARC] := point 1/3 of tmppath0;
aux[R_ARC] := point 3/2 of tmppath0;

% Wir setzen dann die Zuordnungen
% aux[L_ARC] <-> _a_[BOTTOM]
% aux[U_ARC] <-> _a_[L_ARC]
% aux[R_ARC] <-> _a_[TOP]
% Zusätzlich rotieren wir das e, morphen das a
% zur rotierten Version und drehen gleichzeitig zurück:
aux[TOP]    := _e_[TOP]    rotatedaround (C,90);
aux[LEFT]   := _e_[LEFT]   rotatedaround (C,90);
aux[RIGHT]  := _e_[RIGHT]  rotatedaround (C,90);
aux[BOTTOM] := _e_[BOTTOM] rotatedaround (C,90);
aux[END]    := _e_[END]    rotatedaround (C,90);

% Ein Hilfspunkt im "Anhängsel":
tmppath2 := _a_[JOINT]{dir phi[R_ARC]}
            .. _a_[END];
aux[MID] := point 1/2 of tmppath2;
% Der Weg des "Anhängsels":
tmppath3 := aux[LEFT]{right}
            .. aux[BOTTOM]
            .. aux[END];

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       tmppath1 := m[_a_[BEGIN],aux[TOP]]
                   .. m[_a_[TOP],aux[R_ARC]]
                   .. {dir m[phi[R_ARC],0]}m[_a_[R_ARC],aux[RIGHT]]{dir m[phi[R_ARC],-90]}
                  --- {dir m[phi[R_ARC],-90]}m[_a_[JOINT],aux[LEFT]]{dir m[phi[R_ARC],-180]}
                   .. m[_a_[BOTTOM],aux[L_ARC]]
                   .. m[_a_[L_ARC],aux[U_ARC]]
                   .. cycle;
       draw tmppath1 rotatedaround (C,-90m);

       tmppath2 := m[_a_[JOINT],aux[LEFT]]{dir m[phi[R_ARC],0]}
                   .. m[aux[MID],(point m of tmppath3)]
                   .. m[_a_[END],(point 2m of tmppath3)];
       draw tmppath2 rotatedaround (C,-90m);
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% a -> m
%

outputtemplate := "am-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Der Schnittpunkt von a-"Bauch" und y-Achse:
_a_[INTER] := tmppath[A_LOOP] intersectionpoint ((0,0.01u)--(0,infinity));

% Winkel:
tmppath0 := _a_[R_ARC]{_a_[DIR]}
            .. _a_[INTER]
            .._a_[L_ARC]
            .. _a_[BOTTOM]
            .. _a_[JOINT];
phi[MID]    := angle(direction 1 of tmppath0);
phi[BOTTOM] := angle(direction 3 of tmppath0);
phi[JOINT]  := angle(direction 4 of tmppath0);
% Wir rotieren das m:
aux[BEGIN]  := _m_[BEGIN]  rotatedaround (C,90);
aux[BOTTOM] := _m_[BOTTOM] rotatedaround (C,90);
aux[LEFT]   := _m_[LEFT]   rotatedaround (C,90);
aux[RIGHT]  := _m_[RIGHT]  rotatedaround (C,90);
aux[MID]    := _m_[MID]    rotatedaround (C,90);
aux[L_ARC]  := _m_[L_ARC]  rotatedaround (C,90);
aux[R_ARC]  := _m_[R_ARC]  rotatedaround (C,90);
aux[JOINT]  := _m_[JOINT]  rotatedaround (C,90);
aux[END]    := _m_[END]    rotatedaround (C,90);
% noch zwei Hilfspunkte:
tmp0 := xpart(aux[RIGHT])-xpart(aux[R_ARC]);
aux[U_ARC]  := aux[END] shifted (-tmp0,0);
aux[D_ARC]  := (xpart(aux[END]),ypart(aux[R_ARC]));

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       tmppath1 := m[_a_[BEGIN],aux[R_ARC]]
                   .. m[_a_[TOP],aux[RIGHT]]{right}
                   .. m[_a_[TOP],aux[U_ARC]]
                   .. m[_a_[R_ARC],aux[D_ARC]]{dir m[phi[R_ARC],-90]}
                  --- m[_a_[JOINT],aux[BOTTOM]]
                   .. _a_[END];
       draw subpath (0,5-m) of tmppath1;

       draw m[_a_[R_ARC],aux[MID]]{dir m[phi[R_ARC],-180]}
            .. m[_a_[INTER],aux[JOINT]]{dir m[phi[MID],-180]}
            .. m[_a_[L_ARC],aux[L_ARC]]
            .. m[_a_[BOTTOM],aux[LEFT]]{dir m[phi[BOTTOM],0]}
            .. m[_a_[JOINT],aux[BOTTOM]]{dir m[phi[JOINT],0]};
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       tmppath0 := aux[MID]
                   -- aux[JOINT]{left}
                   .. aux[L_ARC]
                   .. aux[LEFT]{right}
                   -- aux[BOTTOM];
       tmppath1 := m[aux[BOTTOM],aux[MID]]
                   -- m[aux[D_ARC],aux[MID]];
       tmppath2 := aux[JOINT]{left}
                   .. aux[R_ARC]
                   .. aux[RIGHT]{right}
                   -- aux[U_ARC]
                   .. m[aux[D_ARC],aux[END]]{dir m[-90,0]};
       tmppath3 := aux[LEFT]
                   -- m[aux[LEFT],aux[BEGIN]];
       draw tmppath0 rotatedaround (C,-90m);
       draw tmppath1 rotatedaround (C,-90m);
       draw subpath (1-m,4) of tmppath2 rotatedaround (C,-90m);
       draw tmppath3 rotatedaround (C,-90m);
       setbounds currentpicture to boundingpath;
    endfig;
endfor


%
% a -> p
%

outputtemplate := "ap-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       % Der Startpunkt vom "a" wandert nach links
       aux[BEGIN] := (xpart(m[_a_[BEGIN],_p_[END]]),ypart(_a_[BEGIN]));
       % Der "Bauch" wird im ersten Drittel der Frames eingezogen,
       % damit die Linie vorbeilaufen kann, ohne ihn zu berühren.

       tmp0 := min(3m,1);
       aux[L_ARC] := _a_[L_ARC] xscaled (1-(2/5)*tmp0);

       tmppath1 := m[aux[BEGIN],_p_[END]]
                   ..  aux[BEGIN]{up}
                   ..  _a_[TOP]
                   ..  _a_[R_ARC]
                   --- _a_[JOINT]
                   ..  _a_[END];
       draw  subpath (0,5-m) of tmppath1;
       draw _a_[R_ARC]{dir phi[R_ARC]}
            .. aux[L_ARC]
            .. _a_[BOTTOM]
            .. _a_[JOINT];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Wir brauchen den Winkel am unteren Ansatz des p-Bogens:
tmppath0 := _p_[D_ARC]
            .. _p_[BOTTOM]
            .. _p_[RIGHT]
            .. _p_[TOP]
            .. _p_[U_ARC];
phi[D_ARC] := angle(direction 0 of tmppath0);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       aux[BEGIN] := (xpart(_p_[END]),ypart(_a_[BEGIN]));
       aux[L_ARC] := _a_[L_ARC] xscaled 3/5;

       % Der Ansatzpunkt wandert am p-Bogen entlang bis zum
       % unteren Ansatz am senkrechten Stamm:
       tmppath1   := _p_[D_ARC]
                     --  m[aux[BEGIN],_p_[U_ARC]]
                     ..  _a_[TOP]
                     ..  m[_a_[R_ARC],_p_[RIGHT]]
                     --- m[_a_[JOINT],_p_[RIGHT]];
       aux[R_ARC] := point 3-3m of tmppath1;

       % Ein Hilfspfad beschreibt den Weg von aux[L_ARC] -> _a_[BOTTOM]
       tmppath2    := aux[L_ARC] .. _a_[BOTTOM]{right};
       aux[BOTTOM] := point m of tmppath2;

       draw _p_[END] -- m[aux[BEGIN],_p_[BEGIN]];
       draw tmppath1;
       % Während der Ansatzpunkt wandert, verändert sich der Winkel:
       draw aux[R_ARC]{dir m[phi[R_ARC],phi[D_ARC]]}
            .. aux[BOTTOM]
            .. _a_[BOTTOM]
            .. m[_a_[JOINT],_p_[RIGHT]]{up};
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% a -> s
%

outputtemplate := "as-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw subpath (0,4-2m) of tmppath[A_SWEEP];
       draw tmppath[A_LOOP];

       setbounds currentpicture to boundingpath;
    endfig;
endfor

% der Winkel am a-"Bauch" und "Joint":
phi[L_ARC] := angle(direction 1 of tmppath[A_LOOP]);
phi[JOINT] := angle(direction 3 of tmppath[A_LOOP]);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       % Hilfspfad; wir benötigen den Winkel beim Punkt im Übergang
       % _a_[JOINT] -> _s_[D_ARC]:
       tmppath3 := m[_a_[L_ARC],_s_[END]]{dir m[phi[L_ARC],-90]}
                   .. _a_[BOTTOM]
                   .. m[_a_[JOINT],_s_[D_ARC]]
                   .. _s_[MID]
                   .. _s_[U_ARC]{up};
       % dieser Winkel soll 90 = up nicht überschreiten:
       phi[TEMP] := min(angle(direction 2 of tmppath3),90);

       % Der komplette Pfad, bestehend aus dem Rest von a und einem vollständigen s:
       tmppath4 := m[_a_[BEGIN],_s_[U_ARC]]
                   .. _a_[TOP]
                   .. _a_[R_ARC]{_a_[DIR]}
                   .. m[_a_[L_ARC],_s_[END]]{dir m[phi[L_ARC],-90]}
                      % Übergang vom ursprünglichen Winkel zu -90 = down
                   .. _a_[BOTTOM]
                   .. m[_a_[JOINT],_s_[D_ARC]]{dir m[phi[JOINT],phi[TEMP]]}
                   .. _s_[MID]
                   .. _s_[U_ARC]{up}
                   .. _s_[TOP]
                   .. _s_[BEGIN]{down};

       draw subpath (3m,5+4m) of tmppath4;

       setbounds currentpicture to boundingpath;
    endfig;
endfor


%
% a -> u
%

outputtemplate := "au-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

aux[MID] := point 1/2 of tmppath[A_LOOP];

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw _a_[BEGIN]
            ..  _a_[TOP]
            ..  _a_[R_ARC]
            --- _a_[JOINT]
            .. m[_a_[END],_u_[BOTTOM]];
       % wir zeichnen A_LOOP bis aux[MID]:
       draw subpath (m/2,4) of tmppath[A_LOOP];

       setbounds currentpicture to boundingpath;
    endfig;
endfor

% der Winkel am Ende des verkürzten a-Bauches:
phi[MID]   := angle(direction 1/2 of tmppath[A_LOOP]);
% Der Winkel am a-Bauch
phi[L_ARC] := angle(direction 1 of tmppath[A_LOOP]);
% der Winkel am "Joint":
phi[JOINT] := angle(direction 3 of tmppath[A_LOOP]);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       tmppath0 := _a_[BEGIN]
                   ..  _a_[TOP]
                   ..  m[_a_[R_ARC],_u_[END]]
                   --- m[_a_[JOINT],_u_[RIGHT]]
                   .. _u_[BOTTOM];

       draw subpath (2m,4) of tmppath0;
       draw m[aux[MID],_u_[BEGIN]]{dir m[phi[MID],-90]}
            .. m[_a_[L_ARC],_u_[LEFT]]{dir m[phi[L_ARC],-90]}
            .. m[_a_[BOTTOM],_u_[MID]]
            .. m[_a_[JOINT],_u_[RIGHT]]{dir m[phi[JOINT],90]};

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% b -> ()
%

outputtemplate := "b.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _b_[BEGIN] -- _b_[END];
   draw _b_[U_ARC]
        .. _b_[TOP]
        .. _b_[RIGHT]
        .. _b_[BOTTOM]
        .. _b_[D_ARC];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% b -> r
%

outputtemplate := "br-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Der b-Strich wird von oben her eingekürzt:
aux[BEGIN] := 1/3[_b_[BEGIN],_b_[END]];
% Der obere Teil des b-Bogens wandert zum
% (gedrehten) r-Zenit:
aux[TOP] := _r_[MID] rotatedaround (C,-90);

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       % Der Strich wird schnell verkürzt, damit er nicht aus der
       % Zeichenfläche ragt und im Browser abgeschnitten wird:
       tmppath0 := min(2m,1)[_b_[BEGIN],aux[BEGIN]]
                   -- _b_[END];
       tmppath1 := _b_[U_ARC]
                   .. m[_b_[TOP],aux[TOP]]
                   .. _b_[RIGHT]
                   .. _b_[BOTTOM]
                   .. _b_[D_ARC];

       draw tmppath0 rotatedaround (C,90m);
       draw tmppath1 rotatedaround (C,90m);

       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Der b-Strich liegt nun waagrecht:
aux[LEFT]  := aux[BEGIN] rotatedaround (C,90);
aux[RIGHT] := _b_[END]   rotatedaround (C,90);

% Er rotiert um den Schnittpunkt mit dem r-Strich:
aux[INTER]  := (aux[LEFT] -- aux[RIGHT]) 
               intersectionpoint (_r_[BEGIN] -- _r_[BOTTOM]);
aux[BEGIN]  := _r_[BEGIN]  rotatedaround (aux[INTER],-90);
aux[BOTTOM] := _r_[BOTTOM] rotatedaround (aux[INTER],-90);

% der rotierte b-Bogen:
aux[U_ARC] := _b_[U_ARC]  rotatedaround (C,90);
% der zweite Punkt liegt bereits auf _r_[MID]
aux[TOP]   := _b_[RIGHT]  rotatedaround (C,90);
aux[R_ARC] := _b_[BOTTOM] rotatedaround (C,90);
aux[D_ARC] := _b_[D_ARC]  rotatedaround (C,90);

% der Endwinkel am r:
tmppath0 := _r_[MID]{up}
            .. _r_[TOP]
            .. _r_[END];
phi[END] := angle(direction 2 of tmppath0);
% die aktuelle Winkel an den Punkten
% _r_[MID] und aux[R_ARC]:
tmppath1 := aux[U_ARC]
            .. _r_[MID]
            .. aux[TOP]
            .. aux[R_ARC]
            .. aux[D_ARC];
phi[MID]   := angle(direction 1 of tmppath1);
phi[R_ARC] := angle(direction 3 of tmppath1);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       tmppath0 := m[aux[LEFT],aux[BOTTOM]]
                   -- m[aux[RIGHT],aux[BEGIN]];

       tmppath1 := aux[U_ARC]
                   .. _r_[MID]{dir m[phi[MID],90]}
                   .. m[aux[TOP],_r_[TOP]]
                   .. m[aux[R_ARC],_r_[END]]{dir m[phi[R_ARC],phi[END]]}
                   .. aux[D_ARC];

       draw tmppath0 rotatedaround (aux[INTER],90m);
       draw subpath (m,4-m) of tmppath1;
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% c -> ()
%

outputtemplate := "c.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _c_[BEGIN]
        .. _c_[TOP]
        .. _c_[LEFT]
        .. _c_[BOTTOM]
        .. _c_[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% c -> n
%

outputtemplate := "cn-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Hilfspunkt für den n-Strich am c:
aux[TEMP] := (xpart(_c_[LEFT]),ypart(_c_[BOTTOM]));

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw _c_[BEGIN]
            .. _c_[TOP]
            .. _c_[LEFT]
            .. _c_[BOTTOM]
            .. _c_[END];

       draw _c_[BOTTOM]
            -- m[_c_[BOTTOM],aux[TEMP]];

       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Hilfspunkte für das gedrehte n:
aux[BEGIN]  := _n_[END]    rotatedaround (C,90);
aux[TOP]    := _n_[RIGHT]  rotatedaround (C,90);
aux[LEFT]   := _n_[MID]    rotatedaround (C,90);
aux[BOTTOM] := _n_[LEFT]   rotatedaround (C,90);
aux[END]    := _n_[BOTTOM] rotatedaround (C,90);

% aux[TEMP] wandert zu aux[JOINT]:
aux[JOINT]  := _n_[BEGIN]  rotatedaround (C,90);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       tmppath0 := m[_c_[BEGIN],aux[BEGIN]]
                   .. m[_c_[TOP],aux[TOP]]{left}
                   .. m[_c_[LEFT],aux[LEFT]]
                   .. m[_c_[BOTTOM],aux[BOTTOM]]{right}
                   .. m[_c_[END],aux[END]];
       tmppath1 := m[_c_[BOTTOM],aux[BOTTOM]]
                   -- m[aux[TEMP],aux[JOINT]];
       draw tmppath0 rotatedaround (C,270m);
       draw tmppath1 rotatedaround (C,270m);


       setbounds currentpicture to boundingpath;
    endfig;
endfor


%
% c -> o
%

outputtemplate := "co-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

tmppath0 := _c_[BEGIN]
            .. _c_[TOP]
            .. _c_[LEFT]
            .. _c_[BOTTOM]
            .. _c_[END];

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw tmppath0 rotatedaround (C,-90m);

       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Hilfspunkte im rotierten c:
aux[END]   := _c_[BEGIN]  rotatedaround (C,-90);
aux[RIGHT] := _c_[TOP]    rotatedaround (C,-90);
aux[TOP]   := _c_[LEFT]   rotatedaround (C,-90);
aux[LEFT]  := _c_[BOTTOM] rotatedaround (C,-90);
aux[BEGIN] := _c_[END]    rotatedaround (C,-90);

tmppath0 := aux[BEGIN]
            .. aux[LEFT]
            .. aux[TOP]
            .. aux[RIGHT]
            .. aux[END];
phi[BEGIN] := angle(direction 0 of tmppath0);
phi[END]   := angle(direction 4 of tmppath0);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[aux[BEGIN],_o_[BOTTOM]]{dir m[phi[BEGIN],180]}
            .. m[aux[LEFT],_o_[LEFT]]
            .. m[aux[TOP],_o_[TOP]]
            .. m[aux[RIGHT],_o_[RIGHT]]
            .. m[aux[END],_o_[BOTTOM]]{dir m[phi[END],-180]};
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% d -> ()
%

outputtemplate := "d.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _d_[BEGIN] -- _d_[END];
   draw _d_[U_ARC]
        .. _d_[TOP]
        .. _d_[LEFT]
        .. _d_[BOTTOM]
        .. _d_[D_ARC];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% d -> j
%

outputtemplate := "dj-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Die Mitte zwischen linkem Bauch und d-Stamm:
tmp0 := (xpart(_d_[END])-xpart(_d_[LEFT]))/2;
aux[MID]    := _d_[END] shifted (-tmp0,tmp0);
aux[TOP]    := aux[MID] shifted (0,tmp0);
aux[BOTTOM] := aux[MID] shifted (0,-tmp0);
aux[LEFT]   := aux[MID] shifted (-tmp0,0);
aux[RIGHT]  := aux[MID] shifted (tmp0,0);

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw _d_[BEGIN] -- _d_[END];
       draw m[_d_[U_ARC],aux[RIGHT]]
            .. m[_d_[TOP],aux[TOP]]
            .. m[_d_[LEFT],aux[LEFT]]
            .. m[_d_[BOTTOM],aux[BOTTOM]]
            .. m[_d_[D_ARC],aux[RIGHT]];

       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Als Erweiterung für den Bogen am d-Stamm definieren
% wir zwei Zusatzpunkte:

aux[D_ARC] := _d_[END] shifted (-0.15u,-0.15u);
aux[L_ARC] := aux[D_ARC] rotatedaround
              ((xpart(aux[D_ARC]),ypart(_d_[END])),-45);


for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       tmppath0 := m[_d_[BEGIN],_j_[BEGIN]]
                   -- m[_d_[END],_j_[MID]]{down}
                   .. m[aux[D_ARC],_j_[BOTTOM]]
                   .. m[aux[L_ARC],_j_[END]];

       draw subpath (0,1+2m) of tmppath0;

       draw m[aux[RIGHT],_j_[TOP]]
            .. m[aux[TOP],_j_[TOP]]
            .. m[aux[LEFT],_j_[TOP]]
            .. m[aux[BOTTOM],_j_[TOP]]
            .. cycle;

       % Um Artefakte in kleinen Schlaufen zu vermeiden:

       if m > 0.85: draw m[aux[MID],_j_[TOP]]; fi
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% d -> u
%

outputtemplate := "du-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Winkel
tmppath0 := _d_[U_ARC]
            .. _d_[TOP]
            .. _d_[LEFT]
            .. _d_[BOTTOM]
            .. _d_[D_ARC];
phi[TOP]    := angle(direction 1 of tmppath0);
phi[BOTTOM] := angle(direction 3 of tmppath0);

% Hilfspunkte gedrehtes u:
aux[BEGIN] := _u_[BEGIN] rotatedaround (C,-90);
aux[LEFT]  := _u_[LEFT]  rotatedaround (C,-90);
aux[MID]   := _u_[MID]   rotatedaround (C,-90);
aux[RIGHT] := _u_[RIGHT] rotatedaround (C,-90);
aux[END]   := _u_[END]   rotatedaround (C,-90);

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw _d_[BEGIN] -- _d_[END];
       draw m[_d_[U_ARC],aux[BEGIN]]
            .. m[_d_[TOP],aux[LEFT]]{dir m[phi[TOP],-180]}
            .. m[_d_[LEFT],aux[MID]]
            .. m[_d_[BOTTOM],aux[RIGHT]]{dir m[phi[BOTTOM],0]}
            .. m[_d_[D_ARC],aux[END]];

       setbounds currentpicture to boundingpath;
    endfig;
endfor


for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[_d_[BEGIN],_u_[END]]
            -- m[_d_[END],_u_[BOTTOM]];

       tmppath0 := aux[BEGIN]
            .. aux[LEFT]{left}
            .. aux[MID]
            .. aux[RIGHT]{right}
            .. aux[END];
       draw tmppath0 rotatedaround (C,90m);

       setbounds currentpicture to boundingpath;
    endfig;
endfor
%
% e -> ()
%

outputtemplate := "e.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _e_[LEFT]
        -- _e_[RIGHT]{up}
        .. _e_[TOP]
        .. _e_[LEFT]
        .. _e_[BOTTOM]
        .. _e_[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% e -> a
%

outputtemplate := "ea-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       aux[END] := (m[_e_[RIGHT],zero[RIGHT]]{down} .. _e_[BOTTOM]{left})
                   intersectionpoint
                   (((0,0) -- (infinity,0)) rotated -35 shifted C);

       tmppath0 := m[_e_[LEFT],zero[LEFT]]
                   -- m[_e_[RIGHT],zero[RIGHT]]{up}
                   .. _e_[TOP]
                   .. m[_e_[LEFT],zero[LEFT]]
                   .. _e_[BOTTOM]
                   .. aux[END];

       draw tmppath0 rotatedaround (C,180m);

       setbounds currentpicture to boundingpath;
    endfig;
endfor

% die Hilfspunkte für den Übergang vom gedrehten e zum a:
aux[BEGIN]  := aux[END]    rotatedaround (C,180);
aux[TOP]    := _e_[BOTTOM] rotatedaround (C,180);
aux[RIGHT]  := zero[LEFT]  rotatedaround (C,180);
aux[L_ARC]  := zero[RIGHT] rotatedaround (C,180);
aux[BOTTOM] := _e_[TOP]    rotatedaround (C,180);

% einige Winkel
tmppath1 := _a_[BEGIN]
            ..  _a_[TOP]
            ..  _a_[R_ARC]
            --- _a_[JOINT]
            .. _a_[END];
phi[R_ARC] := angle(direction 2 of tmppath1);
phi[END]   := angle(direction 4 of tmppath1);

tmppath2 := _a_[R_ARC]{dir phi[R_ARC]}
            .. _a_[L_ARC]
            .. _a_[BOTTOM]
            .. _a_[JOINT];
phi[L_ARC] := angle(direction 1 of tmppath2);
phi[JOINT] := angle(direction 3 of tmppath2);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       % Wir behandeln den e-Strich und den nach unten
       % gedrehten e-Boden als zwei zusammenhängende
       % Pfade und passen die Winkel sukzessive an,
       % sodass am Ende ein glatter Übergang im Punkt
       % _a_[L_ARC] entsteht:
       draw m[aux[RIGHT],_a_[R_ARC]]{dir m[-180,phi[R_ARC]]}
            .. m[aux[L_ARC],_a_[L_ARC]]{dir m[-180,phi[L_ARC]]}
         &  m[aux[L_ARC],_a_[L_ARC]]{dir m[-90,phi[L_ARC]]}
            .. m[aux[BOTTOM],_a_[BOTTOM]]
            .. m[aux[RIGHT],_a_[JOINT]]{dir m[90,phi[JOINT]]};

       draw m[aux[BEGIN],_a_[BEGIN]]
            .. m[aux[TOP],_a_[TOP]]
            .. m[aux[RIGHT],_a_[R_ARC]]
            --- m[aux[RIGHT],_a_[JOINT]]
            .. m[aux[BOTTOM],_a_[END]]{dir m[-180,phi[END]]};

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% e -> c
%

outputtemplate := "ec-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw m[_e_[LEFT],_e_[RIGHT]]
        -- _e_[RIGHT]{up}
        .. _e_[TOP]
        .. _e_[LEFT]
        .. _e_[BOTTOM]
        .. _e_[END];

       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       tmppath0 := _e_[RIGHT]{up}
                   .. _c_[BEGIN]
                   .. _e_[TOP]
                   .. _e_[LEFT]
                   .. _e_[BOTTOM]
                   .. _e_[END];

       draw subpath (m,5) of tmppath0;

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% e -> d
%

outputtemplate := "ed-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

tmppath0 := _e_[LEFT]
            -- _e_[RIGHT]{up}
            .. _e_[TOP]
            .. _e_[LEFT]
            .. _e_[BOTTOM]
            .. _e_[END];

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw (subpath (0,5-2m) of tmppath0) rotatedaround (C,90m);

       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Der waagrechte Strich ist um 90° gedreht und wird zum d-Strich
aux[BEGIN]  := _e_[RIGHT] rotatedaround (C,90);
aux[END]    := _e_[LEFT]  rotatedaround (C,90);
% Der obere Bogen vom e ist gedreht und wird zum d-Bauch:
aux[LEFT]   := _e_[TOP] rotatedaround (C,90);

% Wir definieren noch zwei Hilfspunkte auf dem Bogen:
tmppath1 := aux[END] .. aux[LEFT] .. aux[BEGIN];
aux[TOP] := point 1.75 of tmppath1;
aux[BOTTOM] := point 0.25 of tmppath1;

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[aux[BEGIN],_d_[BEGIN]]
            -- m[aux[END],_d_[END]];

       draw m[aux[BEGIN],_d_[U_ARC]]
            .. m[aux[TOP],_d_[TOP]]
            .. m[aux[LEFT],_d_[LEFT]]
            .. m[aux[BOTTOM],_d_[BOTTOM]]
            .. m[aux[END],_d_[D_ARC]];

       setbounds currentpicture to boundingpath;
    endfig;
endfor



%
% e -> h
%

outputtemplate := "eh-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

tmppath0 := _e_[RIGHT]{up}
            .. _e_[TOP]
            .. _e_[LEFT]
            .. _e_[BOTTOM]
            .. _e_[END];

% Wir klappen den waagrechten Strich nach oben und verkürzen den
% e-Bogen gleichzeitig;
for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw _e_[LEFT] -- _e_[RIGHT] rotatedaround (_e_[LEFT],90m);
       draw subpath (0,4-2m) of tmppath0;

       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Ein Hilfspunkt am Ende des rotierten e-Balkens:
aux[BEGIN] := _e_[RIGHT] rotatedaround (_e_[LEFT],90);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[aux[BEGIN],_h_[BEGIN]]
            -- m[_e_[LEFT],_h_[BOTTOM]];

       draw m[_e_[LEFT],_h_[LEFT]]{up}
            .. m[_e_[TOP],_h_[MID]]
            .. m[_e_[RIGHT],_h_[RIGHT]]{down}
            -- m[_e_[RIGHT],_h_[END]];


       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% f -> ()
%

tmppath0 :=  _f_[BEGIN]
             -- _f_[MID]{up}
             .. _f_[TOP]
             .. _f_[END];
% Wir brauchen den Winkel an der Spitze für den Übergang f -> s
phi[END] := 180+angle(direction 3 of tmppath0);

outputtemplate := "f.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _f_[LEFT] -- _f_[RIGHT];
   draw tmppath0;

   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% f -> m
%

outputtemplate := "fm-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Der Hilfspunkt in der Mitte des Bogens, der
% dann zu _m_[JOINT] wird:
aux[JOINT] := (xpart(_m_[JOINT]),ypart(_m_[L_ARC]));
% Der f-Strich wandert nach unten:
aux[LEFT]  := (xpart(_f_[LEFT]),ypart(_m_[JOINT]))
              shifted (xpart(_m_[BOTTOM])-xpart(_f_[BEGIN]),0);
aux[RIGHT] := (xpart(_f_[RIGHT]),ypart(_m_[JOINT]))
              shifted (xpart(_m_[BOTTOM])-xpart(_f_[BEGIN]),0);
aux[MID] := 1/2[aux[LEFT],aux[RIGHT]];

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw m[_f_[LEFT],aux[LEFT]]
            -- m[_f_[RIGHT],aux[RIGHT]];
       draw m[_f_[BEGIN],_m_[BOTTOM]]
            -- m[_f_[MID],_m_[LEFT]]{up}
            .. m[_f_[TOP],_m_[L_ARC]]
            .. m[_f_[TOP],aux[JOINT]]
            .. m[_f_[TOP],_m_[R_ARC]]
            .. m[_f_[END],_m_[RIGHT]]{dir m[-45,-90]};

       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       % der f-Strich zerfällt in zwei Teile
       draw m[aux[LEFT],_m_[BEGIN]]
            -- m[aux[MID],_m_[LEFT]];
       draw m[aux[MID],_m_[JOINT]]
            -- m[aux[RIGHT],_m_[MID]];
       % der erweiterte f-Bogen bekommt die
       % "Mittendelle" und einen verlängerten
       % Abstrich rechts
       draw _m_[BOTTOM]
            -- _m_[LEFT]{up}
            .. _m_[L_ARC]
            .. {dir m[0,-90]}m[aux[JOINT],_m_[JOINT]]{dir m[0,90]}
            .. _m_[R_ARC]
            .. _m_[RIGHT]{down}
            .. m[_m_[RIGHT],_m_[END]];

       setbounds currentpicture to boundingpath;
    endfig;
endfor


%
% f -> s
%

outputtemplate := "fs-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Wir schieben das f in die Mitte und stauchen es
tmp0 := (xpart(_f_[RIGHT])-xpart(_f_[LEFT]))/2;
% halbe Breite des f-Strichs

aux[LEFT]  := _s_[MID] shifted (-tmp0,0);
aux[RIGHT] := _s_[MID] shifted (tmp0,0);

tmp1 := xpart(_f_[MID]);
aux[END]   := _f_[END] shifted (-tmp1,-(asc-xh));
aux[TOP]   := _f_[TOP] shifted (-tmp1,-(asc-xh));
aux[MID]   := _f_[MID] shifted (-tmp1,-(asc-xh));
aux[BEGIN] := _f_[BEGIN] shifted (-tmp1,0);

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw m[_f_[LEFT],aux[LEFT]]
            -- m[_f_[RIGHT],aux[RIGHT]];

       draw m[_f_[BEGIN],aux[BEGIN]]
            -- m[_f_[MID],aux[MID]]{up}
            .. m[_f_[TOP],aux[TOP]]
            .. m[_f_[END],aux[END]];

       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Zwei Hilfspunkte im unteren Stamm, die den
% Bogen ausbilden. aux[BOTTOM] wandert zeitverzögert
% nach unten:
aux[D_ARC]  := 1/3[aux[MID],aux[BEGIN]];
aux[BOTTOM] := 2/3[aux[MID],aux[BEGIN]];

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[aux[LEFT],_s_[MID]]
            -- m[aux[RIGHT],_s_[MID]];

       draw m[aux[END],_s_[BEGIN]]{dir m[phi[END],90]}
            .. m[aux[TOP],_s_[TOP]]
            .. max(2m-1,0)[aux[MID],_s_[U_ARC]]{down} % oder m*m
            .. _s_[MID]
            .. max(2m-1,0)[aux[D_ARC],_s_[D_ARC]]{down} % oder m*m
            .. max(2m-1,0)[aux[BOTTOM],_s_[BOTTOM]]
            .. m[aux[BEGIN],_s_[END]]{dir m[270,90]};
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% g -> ()
%

outputtemplate := "g.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _g_[BEGIN] -- _g_[TOP];

   draw tmppath[G_LOOP];

   draw _g_[JOINT]{_g_[DIR]}
        .. _g_[U_ARC]
        .. _g_[L_ARC]
        .. _g_[D_ARC]
        .. _g_[R_ARC]
        .. _g_[END];

   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% g -> p
%

outputtemplate := "gp-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Wir ziehen die beiden Bogenpunkte zur Senkrechten durch _g_[LEFT]:
aux[U_ARC] := (xpart(_g_[LEFT]),ypart(_g_[U_ARC]));
aux[L_ARC] := (xpart(_g_[LEFT]),ypart(_g_[L_ARC]));
% Der untere Teil des Bogens wandert nach unten:
aux[D_ARC] := (xpart(_g_[D_ARC]),ypart(_p_[END]));

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw _g_[BEGIN] -- _g_[TOP];

       % Der Schnittpunkt aux[JOINT] wandert an der Rundung entlang Richtung _g_[LEFT]
       % und ist am Ende deckungsgleich:
       tmppath1 := (_g_[CENTER] -- (0,infinity))
                   rotatedaround (_g_[CENTER],m[135,90]);

       aux[JOINT] := tmppath[G_LOOP] intersectionpoint tmppath1;
       tmp[JOINT] := xpart(tmppath[G_LOOP] intersectiontimes tmppath1);
       phi[JOINT] := angle(direction tmp[JOINT] of tmppath[G_LOOP]);

       draw tmppath[G_LOOP];

       draw aux[JOINT]{dir phi[JOINT]}
            .. m[_g_[U_ARC],aux[U_ARC]]
            .. m[_g_[L_ARC],aux[L_ARC]]
            .. _g_[D_ARC]
            .. _g_[R_ARC]
            .. _g_[END];

       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Die Hilfspunkte aux[U_ARC] und aux[L_ARC] wandern zur finalen x-Koordinate:
aux[TOP] := (xpart(_p_[END]),ypart(aux[U_ARC]));
aux[MID] := (xpart(_p_[END]),ypart(aux[D_ARC]));


for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       tmppath0 := m[_g_[LEFT],_p_[U_ARC]]
                   .. m[_g_[TOP],_p_[TOP]]
                   .. m[_g_[RIGHT],_p_[RIGHT]]
                   .. m[_g_[BOTTOM],_p_[BOTTOM]]
                   .. m[_g_[LEFT],_p_[D_ARC]];

       tmp0 := xpart(_g_[BEGIN])-xpart(_g_[TOP]);
       tmp1 := ypart(_p_[BEGIN])-ypart(_p_[U_ARC]);

       tmppath1 := (0,0)--(m[tmp0,tmp1],0);

       draw tmppath1 rotatedabout ((0,0),90*m) shifted point 1-m of tmppath0;

       tmppath2 := m[_g_[LEFT],_p_[U_ARC]]
                   -- m[_g_[LEFT],_p_[D_ARC]]
                   .. m[aux[U_ARC],aux[TOP]]
                   .. m[aux[L_ARC],aux[MID]]{down}
                   .. m[_g_[D_ARC],_p_[END]]
                   .. m[_g_[R_ARC],_g_[D_ARC]]
                   .. m[_g_[END],_g_[R_ARC]];

       draw tmppath0;
       draw subpath (0,6-2m) of tmppath2;

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% h -> ()
%

outputtemplate := "h.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _h_[BEGIN] -- _h_[LEFT];
   draw _h_[BOTTOM]
        -- _h_[LEFT]{up}
        .. _h_[MID]
        .. _h_[RIGHT]{down}
        -- _h_[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% h -> r
%

outputtemplate := "hr-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

tmppath0 := _h_[BOTTOM]
            -- _h_[LEFT]{up}
            .. _h_[MID]
            .. _h_[RIGHT]{down}
            -- _h_[END];

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw _h_[BEGIN] -- _h_[LEFT];
       draw subpath (m,4-m) of tmppath0;

       setbounds currentpicture to boundingpath;
    endfig;
endfor

tmppath0 := _r_[MID]{up}
            .. _r_[TOP]
            .. _r_[END];
phi[END] := angle(direction 2 of tmppath0);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[_h_[BEGIN],_r_[BEGIN]]
            -- m[_h_[LEFT],_r_[BOTTOM]];
       draw m[_h_[LEFT],_r_[MID]]{up}
            .. m[_h_[MID],_r_[TOP]]
            .. m[_h_[RIGHT],_r_[END]]{dir m[-90,phi[END]]};

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% i -> ()
%

outputtemplate := "i.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _i_[TOP];
   draw _i_[BEGIN]
        -- _i_[MID]{down}
        .. _i_[BOTTOM]
        .. _i_[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;

endfig;
%
% i -> t
%

outputtemplate := "it-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Hilfspunkte: t-Strich auf Höhe i-Punkt:
aux[LEFT]  := (xpart(_t_[LEFT]),ypart(_i_[TOP]));
aux[RIGHT] := (xpart(_t_[RIGHT]),ypart(_i_[TOP]));

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw m[_i_[TOP],aux[LEFT]]
            -- m[_i_[TOP],aux[RIGHT]];
       draw _i_[BEGIN]
            -- _i_[MID]{down}
            .. _i_[BOTTOM]
            .. _i_[END];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[aux[LEFT],_t_[LEFT]]
            -- m[aux[RIGHT],_t_[RIGHT]];
       draw m[_i_[BEGIN],_t_[BEGIN]]
            -- _i_[MID]{down}
            .. _i_[BOTTOM]
            .. _i_[END];

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% j -> ()
%

outputtemplate := "j.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _j_[TOP];
   draw _j_[BEGIN]
        -- _j_[MID]
        .. _j_[BOTTOM]
        .. _j_[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% j -> a
%

outputtemplate := "ja-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Der Endwinkel beim j soll in der ersten Hälfte
% des Überganges unverändert bleiben:
tmppath0 := _j_[MID]{down}
            .. _j_[BOTTOM]
            .. _j_[END];
phi[END] := angle(direction 2 of tmppath0);

aux[MID] := 1/2[_j_[BEGIN],_j_[MID]];

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       tmppath1 := _j_[BEGIN]
                   .. aux[MID]
                   .. _j_[MID]{down}
                   .. _j_[BOTTOM]
                   .. _j_[END]{dir phi[END]}
                   .. aux[MID]{dir 30};
       draw _j_[TOP];
       draw subpath (0,4+m) of tmppath1;
       setbounds currentpicture to boundingpath;
    endfig;
endfor

aux[TOP] := 1/2[_j_[BEGIN],aux[MID]];

tmppath1 := _a_[BEGIN]
            ..  _a_[TOP]
            ..  _a_[R_ARC]
            --- _a_[JOINT]
            .. _a_[END];
phi[R_ARC] := angle(direction 2 of tmppath1);

tmppath2 := _a_[R_ARC]{dir phi[R_ARC]}
            .. _a_[L_ARC]
            .. _a_[BOTTOM]
            .. _a_[JOINT];
phi[JOINT] := 180+angle(direction 3 of tmppath2);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       aux[END] := min(2m,1)[_j_[TOP],_a_[END]];

       draw m[_j_[BEGIN],_a_[BEGIN]]
            .. m[aux[TOP],_a_[TOP]]
            .. m[aux[MID],_a_[R_ARC]]{dir m[-90,phi[R_ARC]]}
            .. {dir m[-90,phi[R_ARC]]}m[_j_[MID],_a_[JOINT]]{dir m[270,phi[JOINT]]}
            .. m[_j_[BOTTOM],_a_[BOTTOM]]
            .. m[_j_[END],_a_[L_ARC]]
            .. m[aux[MID],_a_[R_ARC]]{dir m[30,180+phi[R_ARC]]};
       draw max(2m-1,0)[aux[END],_a_[JOINT]]{dir phi[R_ARC]}
            .. aux[END];
       setbounds currentpicture to boundingpath;
    endfig;
endfor


%
% j -> f
%

outputtemplate := "jf-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Wir schieben das f um corr nach links
aux[BEGIN] := _f_[BEGIN] shifted (-corr,0);
aux[MID]   := _f_[MID]   shifted (-corr,0);
aux[TOP]   := _f_[TOP]   shifted (-corr,0);
aux[END]   := _f_[END]   shifted (-corr,0);

% Der j-Bogen wandert weiter in den f-Bogen hinein
% der Hilfspunkt aux[JOINT] verbindet j und f

aux[JOINT] := (xpart(_f_[BEGIN])-corr,ypart(_j_[MID]));

tmppath0 := _j_[BEGIN]
            -- _j_[MID]{down}
            .. _j_[BOTTOM]
            .. _j_[END]
            .. aux[JOINT]{up}
            -- aux[BEGIN]
            -- aux[MID]{up}
            .. aux[TOP]
            .. aux[END];

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw _j_[TOP] shifted (m*corr/2,0);

       draw (subpath (0,5m+3) of tmppath0) shifted (m*corr/2,0);

       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[(_j_[TOP] shifted (corr/2,0)),_f_[LEFT]]
            -- m[(_j_[TOP] shifted (corr/2,0)),_f_[RIGHT]];

       draw (subpath (5m,8) of tmppath0) shifted ((1+m)*corr/2,0);

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% j -> j
%

outputtemplate := "jj-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/(2fpht);
       m := f;

       aux[BOTTOM] := _j_[BOTTOM] yshifted (wiggle(xpart(_j_[BOTTOM])/u,f)*u);
       aux[BEGIN]  := _j_[BEGIN]  yshifted (wiggle(xpart(_j_[BEGIN] )/u,f)*u);
       aux[TOP]    := _j_[TOP]    yshifted (wiggle(xpart(_j_[TOP]   )/u,f)*u);
       aux[MID]    := _j_[MID]    yshifted (wiggle(xpart(_j_[MID]   )/u,f)*u);
       aux[END]    := _j_[END]    yshifted (wiggle(xpart(_j_[END]   )/u,f)*u);

       draw aux[TOP];
       draw aux[BEGIN]
            -- aux[MID]{down}
            .. aux[BOTTOM]
            .. aux[END];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% k -> ()
%

outputtemplate := "k.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _k_[BEGIN]
        -- _k_[END];

   draw _k_[TOP]
        -- _k_[MID]
        -- 4/3[_k_[MID],_k_[BOTTOM]];
   setbounds currentpicture to boundingpath;
endfig;

%
% l -> ()
%

outputtemplate := "l.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _l_[BEGIN]
        -- _l_[MID]{down}
        .. _l_[BOTTOM]
        .. _l_[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% l -> g
%

outputtemplate := "lg-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Hilfspunkte:
tmp0       := xpart(_l_[BOTTOM])-xpart(_l_[MID]);
aux[LEFT]  := _l_[BEGIN] shifted (0,-2tmp0);
aux[TOP]   := _l_[BEGIN] shifted (3/4*tmp0,0);
aux[RIGHT] := _l_[BEGIN] shifted (xpart(_l_[END]),-2tmp0);
aux[JOINT] := 1/4[_l_[MID],_l_[BEGIN]];
for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw _l_[END]
            .. _l_[BOTTOM]
            .. _l_[MID]{up}
            .. aux[JOINT]{up}
            .. aux[LEFT]{up}
            .. {dir m[90,0]}m[_l_[BEGIN],aux[TOP]]{dir m[-90,0]}
            .. m[aux[LEFT],aux[RIGHT]]
            .. {dir m[270,240]}aux[JOINT];

       setbounds currentpicture to boundingpath;
    endfig;
endfor

phi[JOINT] := angle(_g_[DIR]);

% Wir brauchen einen zusätzlichen Hilfspunkt zwischen
% aux[RIGHT] und aux[JOINT]:
tmppath0 := aux[TOP]{right}
            .. aux[RIGHT]
            .. {dir 240}aux[JOINT];
aux[MID] := point 3/2 of tmppath0;
phi[MID] := angle(direction 3/2 of tmppath0);
% Darüberhinaus müssen im l-Bogen Hilfpunkte gesetzt werden:
tmppath1 := _l_[MID]{down}
             .. _l_[BOTTOM]
             .. _l_[END];
aux[L_ARC] := point 1/2 of tmppath1;
aux[R_ARC] := point 3/2 of tmppath1;

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       % aus der l-Schlaufe wird der g-Kreis:
       draw m[aux[LEFT],_g_[LEFT]]
            .. m[aux[TOP],_g_[TOP]]{right}
            .. m[aux[RIGHT],_g_[RIGHT]]
            .. m[aux[MID],_g_[BOTTOM]]{dir m[phi[MID],-180]}
            .. {dir m[240,180+phi[JOINT]]}
               m[aux[JOINT],_g_[JOINT]]
               {dir m[90,180+phi[JOINT]]}
            .. cycle;
       % der kleine Strich wächst aus aux[TOP] und bleibt
       % immer waagrecht
       aux[BEGIN] := m[aux[TOP],_g_[TOP]];
       tmppath2 := aux[BEGIN]
                   -- (xpart(_g_[BEGIN]),ypart(aux[BEGIN]));
       draw subpath (0,m) of tmppath2;
       % Die g-Schlaufe:
       draw m[aux[JOINT],_g_[JOINT]]{dir m[-90,phi[JOINT]]}
            .. m[_l_[MID],_g_[U_ARC]]
            .. m[aux[L_ARC],_g_[L_ARC]]
            .. m[_l_[BOTTOM],_g_[D_ARC]]
            .. m[aux[R_ARC],_g_[R_ARC]]
            .. m[_l_[END],_g_[END]];

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% m -> ()
%

outputtemplate := "m.mps";

beginfig(start);
draw_grid(u);
   pickup pc;

   draw _m_[BEGIN] -- _m_[LEFT];
   draw _m_[BOTTOM]
        -- _m_[LEFT]{up}
        .. _m_[L_ARC]
        .. _m_[JOINT]{down}
     &  _m_[JOINT]{up}
        .. _m_[R_ARC]
        .. _m_[RIGHT]{down}
        -- _m_[END];
   draw _m_[MID] -- _m_[JOINT];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% m -> a
%

outputtemplate := "ma-%c.mps";

beginfig(start);
draw tmppic;
endfig;

tmppath0 := _m_[MID]
            -- _m_[JOINT]{up}
            .. _m_[R_ARC]
            .. _m_[RIGHT]{down}
            -- _m_[END];

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw m[_m_[BEGIN],_m_[LEFT]]
            -- _m_[LEFT];
       tmppath1 := _m_[BOTTOM]
                   -- _m_[LEFT]{up}
                   .. (m+1)[_m_[LEFT],_m_[L_ARC]]
                   .. m[_m_[JOINT],_m_[RIGHT]]{down}
                   -- m[_m_[MID],_m_[END]];
       draw tmppath1 cutafter tmppath0;
       draw tmppath0;
       setbounds currentpicture to boundingpath;
    endfig;
endfor

% einige Winkel vom a:
tmppath2 := _a_[BEGIN]
            .. _a_[TOP]
            .. _a_[R_ARC]
           --- _a_[JOINT]
            .. _a_[END];
phi[BEGIN] := angle(direction 0 of tmppath2);
phi[R_ARC] := angle(direction 2 of tmppath2);

tmppath3 := _a_[R_ARC]{dir phi[R_ARC]}
            .. _a_[L_ARC]
            .. _a_[BOTTOM]
            .. _a_[JOINT];
phi[L_ARC] := angle(direction 1 of tmppath3);
phi[BOTTOM] := angle(direction 2 of tmppath3);
% Hilfspunkte:
aux[TOP]   := 2[_m_[LEFT],_m_[L_ARC]];
aux[JOINT] := 2/3[_m_[RIGHT],_m_[END]];
aux[MID]   := point 1/2 of tmppath3;

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       tmppath0 := m[_m_[RIGHT],_a_[R_ARC]]{dir m[-270,phi[R_ARC]]}
                   .. m[_m_[R_ARC],aux[MID]]
                   .. m[_m_[JOINT],_a_[L_ARC]]{dir m[-90,phi[L_ARC]]}
                   .. {dir m[-90,phi[BOTTOM]]}m[_m_[MID],_a_[BOTTOM]]{dir m[0,phi[BOTTOM]]}
                   .. m[aux[JOINT],_a_[JOINT]];

       tmppath1 := _m_[BOTTOM]
                   .. m[_m_[LEFT],_a_[BEGIN]]{dir m[90,phi[BEGIN]]}
                   .. m[aux[TOP],_a_[TOP]]
                   .. m[_m_[RIGHT],_a_[R_ARC]]{dir m[-90,phi[R_ARC]]}
                  --- m[aux[JOINT],_a_[JOINT]]
                   .. m[_m_[END],_a_[END]];
       draw subpath (0,3+m) of tmppath0;
       draw subpath (m,5) of tmppath1;

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% m -> j
%

outputtemplate := "mj-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Der rechte Bogen wandert an der Strecke _m_[JOINT]/_m_[MID]
% nach unten:
aux[R_ARC] := _m_[R_ARC] shifted -(0,ypart(_m_[JOINT])-ypart(_m_[MID]));

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       % Der kleine Strich wird zum Punkt:
       draw _m_[BEGIN]
            -- m[_m_[LEFT],_m_[BEGIN]];
       % Der erste m-Bogen bleibt unverändert
       draw _m_[BOTTOM]
            -- _m_[LEFT]{up}
            .. _m_[L_ARC]
            .. _m_[JOINT]{down}
            -- _m_[MID];
       % während der zweite schrumpft:
       draw m[_m_[JOINT],_m_[MID]]{up}
            .. m[_m_[R_ARC],aux[R_ARC]]
            .. m[_m_[RIGHT],_m_[END]]{down}
            -- _m_[END];

       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Der Bogen muss verkleinert werden, dazu wird der
% Radius ermittelt:
tmp0 := xpart(_j_[MID])-xpart(_j_[BOTTOM]);
aux[END] := _m_[MID] shifted (2*tmp0,0);
aux[TOP] := _m_[MID] shifted (tmp0,tmp0);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       % Der Punkt wandert im Bogen zur j-Position:
       draw _m_[BEGIN] rotatedabout (1/2[_m_[BEGIN],_j_[TOP]],-180m);

       % Der erste Bogen wird zum j-Stamm
       tmppath0 := _m_[BOTTOM]
                   -- _m_[LEFT]{up}
                   .. _m_[L_ARC]
                   .. m[_m_[JOINT],_j_[BEGIN]]{down}
                   -- m[_m_[MID],_j_[MID]];
       draw subpath (3m,4) of tmppath0;
       % der zweite Bogen passt seine Größe an das j an und
       % klappt um 180° nach unten:
       tmppath1 := _m_[MID]{up}
                   .. m[aux[R_ARC],aux[TOP]]
                   .. m[_m_[END],aux[END]]{down};
       draw subpath (0,2-0.5m) of tmppath1 shifted m[_m_[MID],_j_[MID]] rotatedaround (m[_m_[MID],_j_[MID]],-180m);
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% m -> m
%

outputtemplate := "mm-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/(2fpht);
       m := f;

       aux[BEGIN] := _m_[BEGIN] yshifted (wiggle(xpart(_m_[BEGIN])/u,f)*u);
       aux[LEFT]  := _m_[LEFT]  yshifted (wiggle(xpart(_m_[LEFT] )/u,f)*u);
       aux[JOINT] := _m_[JOINT] yshifted (wiggle(xpart(_m_[JOINT])/u,f)*u);
       aux[RIGHT] := _m_[RIGHT] yshifted (wiggle(xpart(_m_[RIGHT])/u,f)*u);
       aux[L_ARC] := _m_[L_ARC] yshifted (wiggle(xpart(_m_[L_ARC])/u,f)*u);
       aux[R_ARC] := _m_[R_ARC] yshifted (wiggle(xpart(_m_[R_ARC])/u,f)*u);

       draw aux[BEGIN] -- aux[LEFT];
       draw _m_[BOTTOM]
            -- aux[LEFT]{up}
            .. aux[L_ARC]
            .. aux[JOINT]{down}
         &  aux[JOINT]{up}
            .. aux[R_ARC]
            .. aux[RIGHT]{down}
            -- _m_[END];
       draw _m_[MID] -- aux[JOINT];
    setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% m -> t
%

outputtemplate := "mt-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       tmppath0 := m[_m_[BEGIN],_m_[LEFT]] -- _m_[LEFT];
       tmppath1 := _m_[BOTTOM]
                   -- _m_[LEFT]{up}
                   .. _m_[L_ARC]
                   .. _m_[JOINT]{down}
                   &  _m_[JOINT]{up}
                   .. _m_[R_ARC]
                   .. _m_[RIGHT]{down}
                   -- _m_[END];
       tmppath2 :=  _m_[MID] -- _m_[JOINT];

       draw tmppath0 rotatedaround (C,90m);
       draw tmppath1 rotatedaround (C,90m);
       draw tmppath2 rotatedaround (C,90m);
       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Hilfspunkte; das m ist bereits gedreht:
aux[BOTTOM] := _m_[BOTTOM] rotatedaround (C,90);
aux[LEFT]   := _m_[LEFT]   rotatedaround (C,90);
aux[L_ARC]  := _m_[L_ARC]  rotatedaround (C,90);
aux[JOINT]  := _m_[JOINT]  rotatedaround (C,90);
aux[R_ARC]  := _m_[R_ARC]  rotatedaround (C,90);
aux[RIGHT]  := _m_[RIGHT]  rotatedaround (C,90);
aux[END]    := _m_[END]    rotatedaround (C,90);
aux[MID]    := _m_[MID]    rotatedaround (C,90);

% weitere Hilfspunkte; wir brauchen für den
% oberen Bogen "ARC" resp. das Teilstück zwischen
% t-Strich und t-Spitze einen unteren "D" und
% einen oberen "U" Hilfspunkt;
aux[D_ARC] := 1/3[_t_[INTER],_t_[BEGIN]];
aux[U_ARC] := 2/3[_t_[INTER],_t_[BEGIN]];

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[aux[BOTTOM],_t_[END]]
            .. m[aux[LEFT],_t_[BOTTOM]]{left}
            .. m[aux[L_ARC],_t_[MID]]{up}
            .. m[aux[JOINT],_t_[INTER]]{dir m[0,90]}
            &  m[aux[JOINT],_t_[INTER]]{dir m[180,90]}
            .. m[aux[R_ARC],aux[D_ARC]]
            .. m[aux[RIGHT],aux[U_ARC]]{dir m[0,90]}
            .. m[aux[END],_t_[BEGIN]];
       draw m[aux[JOINT],_t_[LEFT]]
            -- m[aux[MID],_t_[RIGHT]];

       setbounds currentpicture to boundingpath;
    endfig;
endfor


%
% n -> ()
%

outputtemplate := "n.mps";

beginfig(start);
draw_grid(u);
   pickup pc;

   draw _n_[BEGIN] -- _n_[LEFT];
   draw _n_[BOTTOM]
        -- _n_[LEFT]{up}
        .. _n_[MID]
        .. _n_[RIGHT]{down}
        --_n_[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% n -> b
%

outputtemplate := "nb-%c.mps";

beginfig(start);
draw tmppic;
endfig;

% der n-Bogen wird zum um 90° rotierten
% b-Bauch:
aux[BOTTOM] := _b_[U_ARC]  rotatedaround (C,90);
aux[LEFT]   := _b_[TOP]    rotatedaround (C,90);
aux[MID]    := _b_[RIGHT]  rotatedaround (C,90);
aux[RIGHT]  := _b_[BOTTOM] rotatedaround (C,90);
aux[END]    := _b_[D_ARC]  rotatedaround (C,90);

tmppath0 := aux[BOTTOM]
            .. aux[LEFT]
            .. aux[MID]
            .. aux[RIGHT]
            .. aux[END];
phi[LEFT] := angle(direction 1 of tmppath0);
phi[RIGHT] := angle(direction 3 of tmppath0);

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       % der n-Strick bleibt in Kontakt mit dem
       % Anfang des Bogens und passt sich der Bogenhöhe an:
       tmp0 := xpart(m[_n_[BOTTOM],aux[BOTTOM]]);
       tmp1 := ypart(m[_n_[MID],aux[MID]]);
       tmp2 := ypart(m[_n_[BOTTOM],aux[BOTTOM]]);
       draw (tmp0,tmp1) -- (tmp0,tmp2);

       % der n-Bogen wird zum gedrehten b-Bogen:
       draw m[_n_[BOTTOM],aux[BOTTOM]]
            .. m[_n_[LEFT],aux[LEFT]]{dir m[90,phi[LEFT]]}
            .. m[_n_[MID],aux[MID]]
            .. m[_n_[RIGHT],aux[RIGHT]]{dir m[-90,phi[RIGHT]]}
            .. m[_n_[END],aux[END]];

       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       tmppath1 := tmppath0 rotatedaround (C,-90m);

       % der n-Strich bleibt am Startpunkt des Bogens verankert;
       % wenn Unterteil des Bogens unter den Startpunkt fällt,
       % übernimmt der Strich dessen Höhe, die Spitze wandert
       % gleichzeitig zum Endpunkt:
       tmp0 := xpart(point 0 of tmppath1);
       tmp1 := ypart(m[aux[MID],_b_[BEGIN]]);
       tmp2 := min(ypart(point 0 of tmppath1),ypart(point 3 of tmppath1));

       draw (tmp0,tmp1) -- (tmp0,tmp2);
       draw tmppath1;
       setbounds currentpicture to boundingpath;
    endfig;
endfor


%
% n -> d
%

outputtemplate := "nd-%c.mps";

beginfig(start);
draw tmppic;
endfig;

tmppath0 := _n_[BEGIN] -- _n_[LEFT];
tmppath1 := _n_[BOTTOM]
            -- _n_[LEFT]{up}
            .. _n_[MID]
            .. _n_[RIGHT]{down}
            --_n_[END];

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw tmppath0 rotatedaround (C,90m);
       draw tmppath1 rotatedaround (C,90m);

       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Wir benötigen die Winkel beim d-Bogen:
tmppath2 := _d_[U_ARC]
            .. _d_[TOP]
            .. _d_[LEFT]
            .. _d_[BOTTOM]
            .. _d_[D_ARC];

phi[TOP]    := angle(direction 1 of tmppath2);
phi[BOTTOM] := angle(direction 3 of tmppath2);

% das n ist gedreht und wird dann zum d-Bogen:
aux[U_ARC]  := _n_[END]    rotatedaround (C,90);
aux[TOP]    := _n_[RIGHT]  rotatedaround (C,90);
aux[LEFT]   := _n_[MID]    rotatedaround (C,90);
aux[BOTTOM] := _n_[LEFT]   rotatedaround (C,90);
aux[D_ARC]  := _n_[BOTTOM] rotatedaround (C,90);
% der n-Strich wird zum d_Strich
% (Index RIGHT für die Spitze des d-Strichs)
aux[BEGIN]  := _n_[BEGIN]  rotatedaround (C,90);
aux[RIGHT]  := _d_[BEGIN] rotatedaround (_d_[END],90);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       % Der Bogen wird umgeformt:
       draw m[aux[U_ARC],_d_[U_ARC]]
            .. m[aux[TOP],_d_[TOP]]{dir m[-180,phi[TOP]]}
            .. m[aux[LEFT],_d_[LEFT]]
            .. m[aux[BOTTOM],_d_[BOTTOM]]{dir m[0,phi[BOTTOM]]}
            .. m[aux[D_ARC],_d_[D_ARC]];

       % Der Strich klappt nach oben und wird länger:
       tmppath0 := m[aux[D_ARC],_d_[END]]
                   -- m[aux[BEGIN],aux[RIGHT]];
       draw tmppath0 rotatedaround (_d_[END],-90m);
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% n -> e
%

outputtemplate := "ne-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Siehe auch u -> e

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       tmppath0 := _n_[BEGIN] -- _n_[BOTTOM];
       tmppath1 := _n_[BEGIN]
                   -- _n_[LEFT]{up}
                   .. _n_[MID]
                   .. _n_[RIGHT]{down}
                   -- _n_[END];

       draw tmppath0 rotatedaround (C,90m);
       draw tmppath1 rotatedaround (C,90m);
       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Das rotierte n wird in aux-Variablen abgelegt:
aux[LEFT]   := _n_[MID] rotatedaround (C,90);
aux[TOP]    := _n_[RIGHT] rotatedaround (C,90);
aux[RIGHT]  := _n_[END] rotatedaround (C,90);
aux[BOTTOM] := _n_[LEFT] rotatedaround (C,90);
aux[END]    := _n_[BOTTOM] rotatedaround (C,90);

aux[BEGIN]  := _n_[BEGIN] rotatedaround (C,90);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[aux[BEGIN],_e_[LEFT]]
            -- m[aux[END],_e_[RIGHT]];

       draw m[aux[RIGHT],_e_[RIGHT]]
            .. m[aux[TOP],_e_[TOP]]{left}
            .. m[aux[LEFT],_e_[LEFT]]
            .. m[aux[BOTTOM],_e_[BOTTOM]]{right}
            .. m[aux[END],_e_[END]];

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% n -> l
%

outputtemplate := "nl-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

aux[BEGIN]  := (xpart(_l_[BEGIN]),ypart(_n_[BEGIN]));
aux[BOTTOM] := (xpart(_l_[BEGIN]),ypart(_n_[BOTTOM]));
aux[LEFT]   := (xpart(_l_[BEGIN]),ypart(_n_[LEFT]));
aux[RIGHT]  := aux[LEFT] xscaled -1;
aux[END]    := aux[BOTTOM] xscaled -1;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw m[_n_[BEGIN],aux[BEGIN]]
            -- m[_n_[LEFT],aux[LEFT]];
       draw m[_n_[BOTTOM],aux[BOTTOM]]
            -- m[_n_[LEFT],aux[LEFT]]{up}
            .. _n_[MID]
            .. m[_n_[RIGHT],aux[RIGHT]]{down}
            -- m[_n_[END],aux[END]];

       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Wir suchen den Punkt auf halbem Weg zwischen
% aux[LEFT] und _n_[MID]:
tmppath0 := aux[BOTTOM]
            -- aux[LEFT]{up}
            .. _n_[MID]
            .. aux[RIGHT]{down}
            -- aux[END];

aux[L_ARC] := point 1.5 of tmppath0;

% Wir lassen den Startpunkt weg und bauen den Hilfspunkt ein:
tmppath1 := aux[LEFT]{up}
            .. aux[L_ARC]
            .. _n_[MID]
            .. aux[RIGHT]{down}
            -- aux[END];

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       % der n-Stamm wandert schnell zum Start von l ...
       draw (aux[BEGIN] -- aux[BOTTOM])
            shifted (min(2m,1)[aux[BEGIN],_l_[BEGIN]]-aux[BEGIN]);
       % während sich der Rest im Bogen verkürzt und
       % um 180° dreht – am Ende überlagern sich beide
       % geraden Abschnitte teilweise und bilden den
       % l-Strich:
       draw (subpath (m,4) of tmppath1) rotatedaround (C,-180m);

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% n -> n
%

outputtemplate := "nn-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/(2fpht);
       m := f;

       aux[BEGIN] := _n_[BEGIN] yshifted (wiggle(xpart(_n_[BEGIN])/u,f)*u);
       aux[LEFT]  := _n_[LEFT]  yshifted (wiggle(xpart(_n_[LEFT] )/u,f)*u);
       aux[MID]   := _n_[MID]   yshifted (wiggle(xpart(_n_[MID]  )/u,f)*u);
       aux[RIGHT] := _n_[RIGHT] yshifted (wiggle(xpart(_n_[RIGHT])/u,f)*u);

       draw aux[BEGIN] -- aux[LEFT];
       draw _n_[BOTTOM]
            -- aux[LEFT]{up}
            .. aux[MID]
            .. aux[RIGHT]{down}
            --_n_[END];
    setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% o -> ()
%

outputtemplate := "o.mps";

beginfig(start);
draw_grid(u);
   pickup pc;

   draw _o_[TOP]
        .. _o_[RIGHT]
        .. _o_[BOTTOM]
        .. _o_[LEFT]
        .. cycle;
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% o -> e
%

outputtemplate := "oe-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw _o_[TOP]
            .. _o_[RIGHT]
            .. _o_[BOTTOM]
            .. _o_[LEFT]
            .. cycle;

       draw _o_[RIGHT]
            -- m[_o_[RIGHT],_o_[LEFT]];

       setbounds currentpicture to boundingpath;
    endfig;
endfor

tmppath0 := _e_[RIGHT]{up}
            .. _e_[TOP]
            .. _e_[LEFT]
            .. _e_[BOTTOM]
            .. _e_[END];
phi[END] := angle(direction 4 of tmppath0);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw _e_[LEFT]
            -- _e_[RIGHT]{up}
            .. _e_[TOP]
            .. _e_[LEFT]
            .. _e_[BOTTOM]
            .. m[_e_[RIGHT],_e_[END]]{dir m[90,phi[END]]};

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% o -> n
%

outputtemplate := "on-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Ein Hilfspunkt, der zur "Spitze" des n wandert:
tmppath0 := _o_[TOP]
            .. _o_[RIGHT]
            .. _o_[BOTTOM]
            .. _o_[LEFT]
            .. cycle;
aux[BEGIN] := point 3.5 of tmppath0;
% Der andere bleibt unverändert und formt die Spitze aus:
aux[U_ARC] := point 3.75 of tmppath0;
% Zwei weitere Hilfspunkte, die von der Grundlinie
% so weit entfernt sind wie der Bogenansatz zur Oberkante:
tmp0 := ypart(_n_[BEGIN])-ypart(_n_[LEFT]);
aux[LEFT]  := _n_[BOTTOM] shifted (0,tmp0);
aux[RIGHT] := _n_[END]    shifted (0,tmp0);

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw m[aux[BEGIN],_n_[BEGIN]]
            .. aux[U_ARC]
            .. _o_[TOP]{right}
            .. m[_o_[RIGHT],_n_[RIGHT]]{down}
            .. m[_o_[RIGHT],aux[RIGHT]]{down}
            .. _o_[BOTTOM]
            .. m[_o_[LEFT],aux[LEFT]]{up}
            .. m[_o_[LEFT],_n_[LEFT]]{up}
            .. cycle;

       setbounds currentpicture to boundingpath;
    endfig;
endfor

tmppath0 := _n_[LEFT]{up}
            .. _n_[BEGIN]
            .. aux[U_ARC]
            .. _n_[MID]
            .. _n_[RIGHT]{down};

phi[BEGIN] := angle(direction 1 of tmppath0);
phi[U_ARC] := angle(direction 2 of tmppath0);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[_o_[BOTTOM],_n_[BOTTOM]]
            .. aux[LEFT]{up}
            .. _n_[LEFT]{up}
            .. {dir m[phi[BEGIN],90]}_n_[BEGIN]{dir m[phi[BEGIN],-90]}
            .. m[aux[U_ARC],_n_[LEFT]]{dir m[phi[U_ARC],90]}
            .. _n_[MID]
            .. _n_[RIGHT]{down}
            .. aux[RIGHT]{down}
            .. m[_o_[BOTTOM],_n_[END]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor


%
% o -> o [de]
%

outputtemplate := "oo-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% übernommen vom Übergang 0 -> 0, der ja nur bei Schaltsekunden sichtbar wird:
tmppath0 := _o_[TOP]
            .. _o_[RIGHT]
            .. _o_[BOTTOM]
            .. _o_[LEFT]
            .. cycle;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-start)/fpht;
       m := retarded(f);

       aux[R_ARC] := point 2m of tmppath0;

       draw m[_o_[TOP],aux[R_ARC]]
            .. m[_o_[RIGHT],aux[R_ARC]]
            .. m[_o_[BOTTOM],aux[R_ARC]]
            .. m[_o_[LEFT],aux[R_ARC]]
            .. cycle;
       % um Artefakte bei kleinen Schlaufen zu vermeiden:
       if ypart(m[_o_[TOP],aux[R_ARC]]) - ypart(_o_[BOTTOM]) < pendia:
          draw m[_o_[TOP],aux[R_ARC]];
       fi
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-start-fpht)/fpht;
       m := advanced(f);

       aux[L_ARC] := point 2m + 2 of tmppath0;

       draw m[aux[L_ARC],_o_[TOP]]
            .. m[aux[L_ARC],_o_[RIGHT]]
            .. m[aux[L_ARC],_o_[BOTTOM]]
            .. m[aux[L_ARC],_o_[LEFT]]
            .. cycle;
       % um Artefakte bei kleinen Schlaufen zu vermeiden:
       if ypart(m[aux[L_ARC],_o_[TOP]]) - ypart(_o_[BOTTOM]) < pendia:
          draw m[aux[L_ARC],_o_[TOP]];
       fi
       setbounds currentpicture to boundingpath;
    endfig;
endfor


%
% o -> u
%

outputtemplate := "ou-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw m[_o_[TOP],_o_[BOTTOM]]
            .. _o_[RIGHT]{dir m[-90,0]}
            .. _o_[BOTTOM]
            .. _o_[LEFT]{dir m[90,0]}
            .. cycle;

       setbounds currentpicture to boundingpath;
    endfig;
endfor

tmppath0 := _o_[BOTTOM]
            .. _o_[RIGHT]{right}
            .. _o_[BOTTOM]
            .. _o_[LEFT]{right}
            .. cycle;

% der äußere Bogen:
aux[RIGHT] := point 1.5 of tmppath0;
aux[LEFT]  := aux[RIGHT] xscaled -1;
% der kleinere, innere Bogen:
aux[R_ARC] := point 0.5 of tmppath0;
aux[L_ARC] := aux[R_ARC] xscaled -1;
% die Winkel an diesen Punkten:
phi[RIGHT] := angle(direction 1.5 of tmppath0);
phi[LEFT]  := -phi[RIGHT];
phi[R_ARC] := angle(direction 0.5 of tmppath0);
phi[L_ARC] := -phi[R_ARC];

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw _o_[BOTTOM]
            .. m[aux[R_ARC],_u_[RIGHT]]{dir m[phi[R_ARC],90]}
            .. {dir m[0,90]}
               m[_o_[RIGHT],_u_[END]]
               {dir m[0,-90]}
            .. m[aux[RIGHT],_u_[RIGHT]]{dir m[phi[RIGHT],-90]}
            .. _o_[BOTTOM]
            .. m[aux[LEFT],_u_[LEFT]]{dir m[phi[LEFT],90]}
            .. {dir m[0,90]}
               m[_o_[LEFT],_u_[BEGIN]]
               {dir m[0,-90]}
            .. m[aux[L_ARC],_u_[LEFT]]{dir m[phi[L_ARC],-90]}
            .. cycle;

       tmppath1 := m[aux[RIGHT],_u_[RIGHT]]
                   -- _u_[BOTTOM];

       draw subpath (0,(max(0,2m-1))) of tmppath1;

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% p -> ()
%

outputtemplate := "p.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _p_[BEGIN] -- _p_[END];
   draw _p_[U_ARC]
        .. _p_[TOP]
        .. _p_[RIGHT]
        .. _p_[BOTTOM]
        .. _p_[D_ARC];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% p -> a
%

outputtemplate := "pa-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Wir brauchen den Winkel am unteren Ansatz des p-Bogens:
tmppath0 := _p_[D_ARC]
            .. _p_[BOTTOM]
            .. _p_[RIGHT]
            .. _p_[TOP]
            .. _p_[U_ARC];

phi[D_ARC] := angle(direction 0 of tmppath0);

phi[R_ARC] := angle(_a_[DIR]);

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       aux[END] := (xpart(_p_[END]),0);
       % nach einer Vierteldrehung hat der p-Strich bereits die
       % gewünschte Länge:
       tmppath1 := _p_[BEGIN]
                   -- min(2m,1)[_p_[END],aux[END]];
       tmppath2 := _p_[U_ARC]
                   .. _p_[TOP]
                   .. _p_[RIGHT]
                   .. _p_[BOTTOM]
                   .. _p_[D_ARC];

       draw tmppath1 rotatedaround (C,180m);
       draw tmppath2 rotatedaround (C,180m);
       setbounds currentpicture to boundingpath;
    endfig;
endfor

aux[MID]    := _p_[D_ARC]  rotatedaround (C,180);
aux[BEGIN]  := aux[END]    rotatedaround (C,180);
aux[R_ARC]  := _p_[U_ARC]  rotatedaround (C,180);
aux[JOINT]  := _p_[BEGIN]  rotatedaround (C,180);
aux[L_ARC]  := _p_[RIGHT]  rotatedaround (C,180);
aux[BOTTOM] := _p_[TOP]    rotatedaround (C,180);
aux[TOP]    := _p_[BOTTOM] rotatedaround (C,180);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       % phi[D_ARC] ist der Winkel am unteren Bogenansatz des P
       % und muss daher um 180° gedreht werden;
       % phi[R_ARC] ist der Winkel am Ansatzpunkt vom "a":
       phi0 := m[phi[D_ARC]-180,phi[R_ARC]];

       % der gedrehte und verkürzte p-"Stamm" wird zum oberen Bogen:
       tmppath1 := m[aux[JOINT],_a_[END]]
                   .. m[aux[JOINT],_a_[JOINT]]{dir m[90,180+phi[R_ARC]]}
                   .. m[aux[R_ARC],_a_[R_ARC]]{dir m[90,180+phi[R_ARC]]}
                   .. m[aux[MID],_a_[TOP]]
                   .. m[aux[BEGIN],_a_[BEGIN]];

       % der gedrehte p-Bogen wird zum a-"Bauch":
       tmppath2 := m[aux[MID],_a_[R_ARC]]{dir phi0}
                   .. m[aux[TOP],_a_[INTER]]
                   .. m[aux[L_ARC],_a_[L_ARC]]
                   .. m[aux[BOTTOM],_a_[BOTTOM]]
                   .. m[aux[R_ARC],_a_[JOINT]];

       % die beiden Pfade überschneiden sich am Anfang sichtbar,
       % daher kürzen wir den "Bauch"-Pfad
       % [durch die Verwendung von "-numbersystem=double" ist die
       % Berechnung der intersectiontime z.T. fehlerhaft; die erste
       % Koordinate scheint korrekt zu sein, die zweite falsch]
       aux[INTER] := tmppath2 intersectiontimes tmppath1;

       draw tmppath1;
       draw subpath (xpart(aux[INTER]),4) of tmppath2;
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% p -> t
%

outputtemplate := "pt-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Der Beginn des t-Bogens
aux[MID]    := _p_[END] shifted (0,mw);
aux[BOTTOM] := _p_[END] shifted (mw,0);
aux[END]    := aux[BOTTOM]
               rotatedabout ((xpart(aux[BOTTOM]),ypart(aux[MID])),45);

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       % Der Bogen bildet sich zuerst nur bis zur Vierteldrehung aus:
       draw _p_[BEGIN]
       -- aux[MID]{down}
       .. m[_p_[END],aux[BOTTOM]];

       draw _p_[U_ARC]
            .. _p_[TOP]
            .. _p_[RIGHT]
            .. _p_[BOTTOM]
            .. _p_[D_ARC];

       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       tmppath0 := m[_p_[BEGIN],_t_[BEGIN]]
                   -- m[aux[MID],_t_[MID]]{down}
                   .. m[aux[BOTTOM],_t_[BOTTOM]]
                   .. m[aux[END],_t_[END]];

       tmppath1 := m[_p_[U_ARC],_t_[LEFT]]
                   .. m[_p_[TOP],_t_[RIGHT]]{right}
                   .. _p_[RIGHT]
                   .. _p_[BOTTOM]
                   .. _p_[D_ARC];

       draw subpath (0,2+m)  of tmppath0;
       draw subpath (0,4-3m) of tmppath1;

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% q -> ()
%

outputtemplate := "q.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _q_[BEGIN] -- _q_[END];
   draw _q_[U_ARC]
        .. _q_[TOP]
        .. _q_[LEFT]
        .. _q_[BOTTOM]
        .. _q_[D_ARC];
   setbounds currentpicture to boundingpath;
endfig;

%
% r -> ()
%

outputtemplate := "r.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _r_[BEGIN] -- _r_[BOTTOM];
   draw _r_[MID]{up}
        .. _r_[TOP]
        .. _r_[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% r -> a
%

outputtemplate := "ra-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% einige Winkel
tmppath0 := _r_[MID]{up}
            .. _r_[TOP]
            .. _r_[END];
phi[END] := angle(direction 2 of tmppath0);
tmppath1 := _a_[BEGIN]
            ..  _a_[TOP]
            ..  _a_[R_ARC]
            --- _a_[JOINT]
            .. _a_[END];
phi[BEGIN] := angle(direction 0 of tmppath1);
phi[R_ARC] := angle(direction 2 of tmppath1);

tmppath2 := _a_[R_ARC]{dir phi[R_ARC]}
            .. _a_[L_ARC]
            .. _a_[BOTTOM]
            .. _a_[JOINT];


for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw m[_r_[BEGIN],_r_[MID]]
            -- _r_[BOTTOM];
       draw _r_[MID]{up}
            .. _r_[TOP]
            .. _r_[END];

       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       tmppath0 := _r_[BOTTOM]
                   .. m[_r_[MID],_a_[BEGIN]]{dir m[90,phi[BEGIN]]}
                   .. m[_r_[TOP],_a_[TOP]]
                   .. m[_r_[END],_a_[R_ARC]]{dir m[phi[END],phi[R_ARC]]}
                  --- _a_[JOINT]
                   .. _a_[END];
       % Der Winkel phi[JOINT] wird am Ende zu phi[R_ARC],
       % so wird allerdings verhindert, dass tmppath1 zu "weich"
       % verläuft und rechts neben den Linienabschnitt "---"
       % herausragt
       phi[JOINT] := angle(direction 4 of tmppath0);

       tmppath1 := _r_[BOTTOM]
                   .. m[_r_[MID],_a_[BEGIN]]{dir m[90,phi[BEGIN]]}
                   .. m[_r_[TOP],_a_[TOP]]
                   .. m[_r_[END],_a_[R_ARC]]{dir phi[JOINT]}
                  .. _a_[L_ARC]
                  .. _a_[BOTTOM]
                  .. _a_[JOINT];

       draw subpath (m,3+2m) of tmppath0;
       draw subpath (m,3+3f) of tmppath1; % f statt m, da etwas langsamer
       setbounds currentpicture to boundingpath;
    endfig;
endfor
%
% r -> r
%

outputtemplate := "rr-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/(2fpht);
       m := f;

       aux[BEGIN] := _r_[BEGIN] yshifted (wiggle(xpart(_r_[BEGIN])/u,f)*u);
       aux[TOP]   := _r_[TOP]   yshifted (wiggle(xpart(_r_[TOP]  )/u,f)*u);
       aux[MID]   := _r_[MID]   yshifted (wiggle(xpart(_r_[MID]  )/u,f)*u);
       aux[END]   := _r_[END]   yshifted (wiggle(xpart(_r_[END]  )/u,f)*u);

       draw aux[BEGIN] -- _r_[BOTTOM];
       draw aux[MID]{up}
            .. aux[TOP]
            .. aux[END];
       setbounds currentpicture to boundingpath;
    endfig;
endfor
%
% r -> y
%

outputtemplate := "ry-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       tmppath0 := _r_[BEGIN] -- _r_[BOTTOM];
       tmppath1 := _r_[MID]{up}
                   .. _r_[TOP]
                   .. _r_[END];

       draw tmppath0 rotatedaround (C,-90m);
       draw tmppath1 rotatedaround (C,-90m);

       setbounds currentpicture to boundingpath;
    endfig;
endfor

aux[BEGIN] := _r_[BOTTOM] rotatedaround (C,-90);
aux[END]   := _r_[BEGIN]  rotatedaround (C,-90);
aux[LEFT]  := 1/4[aux[BEGIN],aux[END]];
aux[MID]   := 1/2[aux[BEGIN],aux[END]];
aux[RIGHT] := 3/4[aux[BEGIN],aux[END]];

aux[D_ARC]  := _r_[END] rotatedaround (C,-90);
aux[BOTTOM] := _r_[TOP] rotatedaround (C,-90);
% Der Punkt wandert ebenfalls zu _y_[RIGHT],
% aber aux[RIGHT] ist schon belegt:
aux[JOINT]  := _r_[MID] rotatedaround (C,-90);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[aux[BEGIN],_y_[BEGIN]]
            .. m[aux[LEFT],_y_[LEFT]]{dir m[0,-90]}
            .. m[aux[MID],_y_[MID]]
            .. m[aux[RIGHT],_y_[RIGHT]]{dir m[0,90]}
            .. m[aux[END],_y_[END]];
       draw min(2m,1)[aux[JOINT],_y_[RIGHT]]
            .. min(2m,1)[aux[BOTTOM],_y_[BOTTOM]]{down}
            .. min(2m,1)[aux[D_ARC],_y_[D_ARC]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor


%
% s -> ()
%

outputtemplate := "s.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _s_[BEGIN]{up}
        .. _s_[TOP]
        .. _s_[U_ARC]{down}
        .. _s_[MID]
        .. _s_[D_ARC]{down}
        .. _s_[BOTTOM]
        .. _s_[END]{up};

   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% s -> m
%

outputtemplate := "sm-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Wir machen das s unten so schmal wie oben:
aux[D_ARC] := (xpart(_s_[BEGIN]),ypart(_s_[D_ARC]));
aux[END]   := (xpart(_s_[U_ARC]),ypart(_s_[END]));

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       tmppath0 := _s_[MID]
                   .. _s_[BEGIN]{up}
                   .. _s_[TOP]
                   .. _s_[U_ARC]{down}
                   .. _s_[MID]
                   .. m[_s_[D_ARC],aux[D_ARC]]{down}
                   .. _s_[BOTTOM]
                   .. m[_s_[END],aux[END]]{up};

       draw (subpath (1-m,7) of tmppath0) rotatedaround (_s_[MID],90m);

       setbounds currentpicture to boundingpath;
    endfig;
endfor

aux[BOTTOM] := _s_[U_ARC]  rotatedaround (_s_[MID],90);
aux[LEFT]   := _s_[TOP]    rotatedaround (_s_[MID],90);
aux[L_ARC]  := _s_[BEGIN]  rotatedaround (_s_[MID],90);
aux[JOINT]  := _s_[MID];
aux[R_ARC]  := aux[D_ARC]  rotatedaround (_s_[MID],90);
aux[RIGHT]  := _s_[BOTTOM] rotatedaround (_s_[MID],90);
aux[END]    := aux[END]    rotatedaround (_s_[MID],90);

tmppath0 := aux[BOTTOM]{right}
            .. aux[JOINT]
            .. aux[R_ARC]{right}
            .. aux[RIGHT]{down}
            .. aux[END]{left};
phi[JOINT] := angle(direction 1 of tmppath0);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[aux[BOTTOM],_m_[MID]]{dir m[0,90]}
            .. m[aux[JOINT],_m_[JOINT]]{dir m[phi[JOINT],90]}
            .. m[aux[R_ARC],_m_[R_ARC]]{right}
            .. m[aux[RIGHT],_m_[RIGHT]]{down}
            .. m[aux[END],_m_[END]]{dir m[180,270]};

       draw m[aux[BOTTOM],_m_[BOTTOM]]{dir m[180,90]}
            .. m[aux[LEFT],_m_[LEFT]]{up}
            .. m[aux[L_ARC],_m_[L_ARC]]{right}
            .. m[aux[JOINT],_m_[JOINT]];

       tmppath1 := m[aux[LEFT],_m_[LEFT]]
                   -- _m_[BEGIN];
       draw subpath (0,(max(0,2m-1))) of tmppath1;

       setbounds currentpicture to boundingpath;
    endfig;
endfor


%
% s -> o
%

outputtemplate := "so-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw m[_s_[BEGIN],_o_[RIGHT]]{up}
            .. _s_[TOP]
            .. m[_s_[U_ARC],_o_[LEFT]]{down}
            .. _s_[MID]
            .. m[_s_[D_ARC],_o_[RIGHT]]{down}
            .. _s_[BOTTOM]
            .. m[_s_[END],_o_[LEFT]]{up};

       setbounds currentpicture to boundingpath;
    endfig;
endfor

tmppath0 := _o_[RIGHT]{up}
            .. _s_[TOP]
            .. _o_[LEFT]{down}
            .. _s_[MID]
            .. _o_[RIGHT]{down}
            .. _s_[BOTTOM]
            .. _o_[LEFT]{up};

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw subpath (0,3-m) of tmppath0;
       draw subpath (3+m,6) of tmppath0;

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% s -> s
%

outputtemplate := "ss-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/(2fpht);
       m := f;

       aux[BEGIN]  := _s_[BEGIN] yshifted (wiggle(xpart(_s_[BEGIN])/u,f)*u);
       aux[TOP]    := _s_[TOP]   yshifted (wiggle(xpart(_s_[TOP]  )/u,f)*u);
       aux[U_ARC]  := _s_[U_ARC] yshifted (wiggle(xpart(_s_[U_ARC])/u,f)*u);
       aux[MID]    := _s_[MID]   yshifted (wiggle(xpart(_s_[MID]  )/u,f)*u);
       aux[D_ARC]  := _s_[D_ARC] yshifted (wiggle(xpart(_s_[D_ARC])/u,f)*u);
       aux[END]    := _s_[END]   yshifted (wiggle(xpart(_s_[END]  )/u,f)*u);

       draw aux[BEGIN]{up}
            .. aux[TOP]
            .. aux[U_ARC]{down}
            .. aux[MID]
            .. aux[D_ARC]{down}
            .. _s_[BOTTOM]
            .. aux[END]{up};
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% t -> ()
%

outputtemplate := "t.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _t_[LEFT] -- _t_[RIGHT];

   draw _t_[BEGIN]
        -- _t_[MID]{down}
        .. _t_[BOTTOM]
        .. _t_[END];

   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% t -> f
%

outputtemplate := "tf-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Rotationszentrum
aux[MID]   := (xpart(_l_[BOTTOM]),ypart(_l_[MID]));
% Die Hilfspunkte für den geschlossenen Kreis,
% jeweils als Verlängerung durch das Rotationszentrum
% des Bogens
aux[RIGHT] := 2[_t_[MID],aux[MID]];
aux[TOP]   := 2[_t_[BOTTOM],aux[MID]];

tmppath0 := _t_[MID]
            .. _t_[BOTTOM]
            .. _t_[END]
            .. aux[RIGHT]
            .. aux[TOP]
            .. cycle;

tmppath1 := _t_[LEFT] -- _t_[RIGHT];

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       % Der t-Stamm wird oben verkürzt, um für
       % den f-Bogen Platz zu machen:

       draw min(2m,1)[_t_[BEGIN],_f_[MID]]
            -- _t_[MID];

       % Der untere Bogen wird zum Kreis aufgerollt (min(2m,1))
       % und danach bis zum Strich bewegt (max(2m-1,0)):

       tmp0 := max(2m-1,0)*(ypart(_t_[LEFT])-ypart(_t_[MID]));
       draw (subpath (0,3*min(2m,1)+2) of tmppath0) shifted (0,tmp0);

       % Der Querstrich wandert nach links, um den Kreis vorbeizulassen:

       tmp1 := m*(xpart(_t_[MID])-xpart(_t_[RIGHT]));
       draw tmppath1 shifted (tmp1,0);

       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Andere Rotationsrichtung, zusätzlicher Hilfspunkt
aux[U_ARC] := _t_[BOTTOM] rotatedabout (aux[MID],135);
tmppath0 := _t_[MID]
            .. aux[TOP]
            .. aux[U_ARC]
            .. aux[RIGHT]
            .. _t_[BOTTOM]
            .. cycle;

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       % der Stamm wird nun nach unten verlängert:
       draw _f_[MID]
            -- max(2m-1,0)[_t_[MID],_f_[BEGIN]];

       % der Kreis wandert weiter und entrollt sich wieder
       tmp0 := min(2m,1)[ypart(_t_[LEFT]),ypart(_f_[MID])]-ypart(_t_[MID]);
       draw (subpath (0,5-3*max(2m-1,0)) of tmppath0) shifted (0,tmp0);

       % Der Querstrich wandert wieder zurück, aber erst in der zweiten Hälfte
       % des Übergangs:
       tmp1 := min(2(1-m),1)*(xpart(_t_[MID])-xpart(_t_[RIGHT]));
       draw tmppath1 shifted (tmp1,0);

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% t -> n
%

outputtemplate := "tn-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Wir schieben _t_[BOTTOM] um die Hälfte _t_[MID]/_t_[BOTTOM]
% nach links, sowie _t_[END] oberhalb von _t_[BOTTOM]:

aux[BOTTOM] := (1/2(xpart(_t_[MID])+xpart(_t_[BOTTOM])),ypart(_t_[BOTTOM]));
aux[END]    := (xpart(_t_[BOTTOM]),ypart(_t_[END]));

% Zwei zusätzliche Hilfspunkte, die die Verlängerung des t-Bogens darstellen;
% aux[D_ARC] wandert zu aux[R_ARC], aux[U_ARC] zu aux[L_ARC]:

aux[U_ARC] := 2[_t_[BOTTOM],_t_[END]];
aux[L_ARC] := (1/2(xpart(_t_[END])+xpart(_t_[BOTTOM])),ypart(aux[U_ARC]));

aux[D_ARC] := (2*xpart(_t_[END]),ypart(_t_[BOTTOM]));
aux[R_ARC] := (xpart(_t_[END]),ypart(_t_[BOTTOM]));



for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw _t_[LEFT] -- _t_[RIGHT];

       tmppath0 := _t_[BEGIN]
                   -- _t_[MID]{down}
                   .. m[_t_[BOTTOM],aux[BOTTOM]]
                   .. m[_t_[END],aux[END]]
                   .. m[aux[U_ARC],aux[L_ARC]]
                   .. m[aux[D_ARC],aux[R_ARC]]{down};

       draw subpath (0,3+2m) of tmppath0;

       setbounds currentpicture to boundingpath;
    endfig;
endfor

tmppath0 := _t_[BEGIN]
            -- _t_[MID]{down}
            .. aux[BOTTOM]
            .. aux[END]
            .. aux[L_ARC]
            .. aux[R_ARC]{down};

aux[RIGHT] := point 4.5 of tmppath0;
% aux[RIGHT] wandert zu _n_[RIGHT]

% Winkel:
phi[LEFT]  := angle(direction 3 of tmppath0);
phi[RIGHT] := angle(direction 4.5 of tmppath0);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[_t_[LEFT],_n_[LEFT]]
            -- m[_t_[RIGHT],_n_[BEGIN]];

       tmppath0 := _t_[BEGIN]
                   -- _t_[MID]{down}
                   .. {dir min(2m,1)[0,90]}
                      m[aux[BOTTOM],_n_[BOTTOM]]
                      {dir min(2m,1)[0,90]}
                   .. m[aux[END],_n_[LEFT]]{dir m[phi[LEFT],90]}
                   .. m[aux[L_ARC],_n_[MID]]
                   .. m[aux[RIGHT],_n_[RIGHT]]{dir m[phi[RIGHT],-90]}
                   .. m[aux[R_ARC],_n_[END]]{down};

       draw subpath (2m,6) of tmppath0;
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% t -> u
%

outputtemplate := "tu-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% der t-Strich wächst zu einem um 90° gedrehten
% u-Strich:

aux[LEFT]  := (xpart(_u_[END])-ypart(_u_[END]),ypart(_t_[LEFT]));
aux[RIGHT] := (xpart(_u_[END]),ypart(_t_[RIGHT]));

% der Schnittpunkt des t-Striches mit dem t-Stamm:
aux[MID]   := (_t_[LEFT] -- _t_[RIGHT])
              intersectionpoint
              (_t_[BEGIN] -- _t_[MID]);

tmppath0 := _t_[BEGIN]
            -- aux[MID]
            -- _t_[MID]{down}
            .. _t_[BOTTOM]
            .. _t_[END];

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       % der Strich wird breiter
       draw m[_t_[LEFT],aux[LEFT]]
            -- m[_t_[RIGHT],aux[RIGHT]];

       % der t-Stamm schrumpft, bis er bündig mit dem
       % t-Strich liegt:
       draw subpath (m,4) of tmppath0;

       setbounds currentpicture to boundingpath;
    endfig;
endfor

% wir brauchen den Hilfspunkt, der auf halbem Weg zwischen
% _u_[MID] und _u_[RIGHT] liegt:

tmppath1 := _u_[BEGIN]
            -- _u_[LEFT]{down}
            .. _u_[MID]
            .. _u_[RIGHT]{up}
            -- _u_[END];
aux[TEMP] := point 2.5 of tmppath1;

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       tmppath0 := m[aux[MID],_u_[BEGIN]]
                   -- m[_t_[MID],_u_[LEFT]]{down}
                   .. m[_t_[BOTTOM],_u_[MID]]
                   .. m[_t_[END],aux[TEMP]]
                   .. m[_t_[MID] xscaled -1,_u_[RIGHT]]{up}
                   -- m[aux[MID] xscaled -1,_u_[END]];
       % bewege den überdimensionierten t-Strich in seine Endposition;
       % der linke Punkt bewegt sich annähernd auf einem Viertelkreis
       % nach unten, der rechte Punkt nach oben zu seinem Ziel:
       tmppath2 := aux[LEFT]{down} .. _u_[BOTTOM]{right};
       draw (point m of tmppath2) -- m[aux[RIGHT],_u_[END]];
       draw subpath (0,3+2m) of tmppath0;

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% t -> v
%

outputtemplate := "tv-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Hilfspunkte
% wir erweitern den t-Bogen zu einem Halbkreis:
aux[R_ARC] := _t_[MID] xscaled -1;
% Hilfspunkte im v:
tmppath0 := (-infinity,ypart(_t_[MID]))
            -- (infinity,ypart(_t_[MID]));
aux[LEFT]  := (_v_[LEFT] -- _v_[BOTTOM]) intersectionpoint tmppath0;
aux[RIGHT] := (_v_[BOTTOM] -- _v_[RIGHT]) intersectionpoint tmppath0;
aux[END] := 1/2[_v_[BOTTOM],_v_[RIGHT]];

phi[LEFT]  := angle(_v_[BOTTOM]-_v_[LEFT]);
phi[RIGHT] := angle(_v_[RIGHT]-_v_[BOTTOM]);

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw _t_[LEFT] -- _t_[RIGHT];

       tmppath1 := m[_t_[BEGIN],_v_[LEFT]]
                   -- m[_t_[MID],aux[LEFT]]
                   .. m[_t_[BOTTOM],_v_[BOTTOM]]{dir m[0,phi[LEFT]]}
                 & m[_t_[BOTTOM],_v_[BOTTOM]]{dir m[0,phi[RIGHT]]}
                   .. m[_t_[END],aux[RIGHT]]
                   .. m[aux[R_ARC],aux[END]];

       draw subpath (0,3+m) of tmppath1;



       setbounds currentpicture to boundingpath;
    endfig;
endfor


for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[_t_[LEFT],aux[END]]
            -- m[_t_[RIGHT],_v_[RIGHT]];

       draw _v_[LEFT]
            -- _v_[BOTTOM]
            -- aux[END];

       setbounds currentpicture to boundingpath;
    endfig;
endfor




%
% t -> w
%

outputtemplate := "tw-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Wir zeichnen den Übergang t -> v in der ersten Hälfte,
% also doppelt so schnell:
for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw m[_t_[LEFT],aux[END]]
            -- m[_t_[RIGHT],_v_[RIGHT]];

       tmppath1 := m[_t_[BEGIN],_v_[LEFT]]
                   -- m[_t_[MID],aux[LEFT]]
                   .. m[_t_[BOTTOM],_v_[BOTTOM]]{dir m[0,phi[LEFT]]}
                 & m[_t_[BOTTOM],_v_[BOTTOM]]{dir m[0,phi[RIGHT]]}
                   .. m[_t_[END],aux[RIGHT]]
                   .. m[aux[R_ARC],aux[END]];

       draw subpath (0,3+m) of tmppath1;

       setbounds currentpicture to boundingpath;
    endfig;
endfor

% wir verdoppeln das v zum w
for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[_v_[LEFT],_w_[BEGIN]]
            -- m[_v_[BOTTOM],_w_[LEFT]]
            -- m[_v_[RIGHT],_w_[MID]];
       draw m[_v_[LEFT],_w_[MID]]
            -- m[_v_[BOTTOM],_w_[RIGHT]]
            -- m[_v_[RIGHT],_w_[END]];

       setbounds currentpicture to boundingpath;
    endfig;
endfor


%
% u -> ()
%

outputtemplate := "u.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _u_[RIGHT] -- _u_[BOTTOM];
   draw _u_[BEGIN]
        -- _u_[LEFT]{down}
        .. _u_[MID]
        .. _u_[RIGHT]{up}
        -- _u_[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% u -> e
%

outputtemplate := "ue-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Siehe auch n -> e

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       tmppath0 := _u_[RIGHT] -- _u_[BOTTOM];
       tmppath1 := _u_[BEGIN]
                   -- _u_[LEFT]{down}
                   .. _u_[MID]
                   .. _u_[RIGHT]{up}
                   -- _u_[END];

       draw tmppath0 rotatedaround (C,-90m);
       draw tmppath1 rotatedaround (C,-90m);
       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Das rotierte u wird in aux-Variablen abgelegt:
aux[LEFT]   := _u_[MID] rotatedaround (C,-90);
aux[TOP]    := _u_[LEFT] rotatedaround (C,-90);
aux[RIGHT]  := _u_[BEGIN] rotatedaround (C,-90);
aux[BOTTOM] := _u_[RIGHT] rotatedaround (C,-90);
aux[END]    := _u_[END] rotatedaround (C,-90);

aux[BEGIN]  := _u_[BOTTOM] rotatedaround (C,-90);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[aux[BEGIN],_e_[LEFT]]
            -- m[aux[END],_e_[RIGHT]];

       draw m[aux[RIGHT],_e_[RIGHT]]{dir m[180,90]}
            .. m[aux[TOP],_e_[TOP]]{left}
            .. m[aux[LEFT],_e_[LEFT]]
            .. m[aux[BOTTOM],_e_[BOTTOM]]{right}
            .. m[aux[END],_e_[END]];

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% u -> i
%

outputtemplate := "ui-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Die Enden des u wandern auf i-Höhe
aux[BEGIN] := (xpart(_u_[BEGIN]),ypart(_i_[BEGIN]));
aux[END]   := (xpart(_u_[END]),ypart(_i_[BEGIN]));

% der i-Punkt ist erst über dem linken u-Strich:
aux[TOP] := (xpart(_u_[BEGIN]),ypart(_i_[TOP]));

tmppath0 := aux[TOP]
            -- _u_[END]
            -- aux[END];

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       % Der Strich wandert aus dem rechten u-Teil
       % heraus und um die Ecke, wo er einen Querstrich bildet
       % und zum i-Punkt wird:
       draw subpath (1-m,2-2m) of tmppath0;

       % Der rechte Strich verschwindet schneller, daher min(3m,1):
       draw _u_[RIGHT]
             -- min(3m,1)[_u_[BOTTOM],_u_[RIGHT]];

       draw m[_u_[BEGIN],aux[BEGIN]]
            -- _u_[LEFT]{down}
            .. _u_[MID]
            .. _u_[RIGHT]{up}
            -- m[_u_[END],aux[END]];

       setbounds currentpicture to boundingpath;
    endfig;
endfor

tmppath0 := _i_[MID]{down}
            .. _i_[BOTTOM]
            .. _i_[END];
phi[END] := angle(direction 2 of tmppath0);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[aux[TOP],_i_[TOP]];

       tmppath0 := m[aux[BEGIN],_i_[BEGIN]]
                   -- m[_u_[LEFT],_i_[MID]]{down}
                   .. m[_u_[MID],_i_[BOTTOM]]
                   .. m[_u_[RIGHT],_i_[END]]{dir m[90,phi[END]]}
                   .. aux[END];
       draw subpath (0,4-m) of tmppath0;

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% u -> o
%

outputtemplate := "uo-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

aux[BEGIN] := (0,xpart(_u_[END])-xpart(_u_[BEGIN])) shifted _u_[END];

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       tmppath0 := min(2m,1)[_u_[END],aux[BEGIN]]
                  -- min(2m,1)[_u_[BOTTOM],_u_[END]];
       draw tmppath0 rotatedaround (_u_[END],90*max(2m-1,0));
       draw _u_[BEGIN]
            -- _u_[LEFT]{down}
            .. _u_[MID]
            .. _u_[RIGHT]{up}
            -- _u_[END];

       setbounds currentpicture to boundingpath;
    endfig;
endfor


aux[MID] := 1/2[_u_[BEGIN],_u_[END]];

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[_u_[BEGIN],_o_[LEFT]]{dir m[0,90]}
            .. m[aux[MID],_o_[TOP]]
            .. m[_u_[END],_o_[RIGHT]]{dir m[0,-90]};
       draw m[_u_[BEGIN],_o_[LEFT]]
            -- m[_u_[LEFT],_o_[LEFT]]{down}
            .. m[_u_[MID],_o_[BOTTOM]]
            .. m[_u_[RIGHT],_o_[RIGHT]]{up}
            -- m[_u_[END],_o_[RIGHT]];

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% u -> u
%

outputtemplate := "uu-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/(2fpht);
       m := f;

       aux[BEGIN] := _u_[BEGIN] yshifted (wiggle(xpart(_u_[BEGIN])/u,f)*u);
       aux[LEFT]  := _u_[LEFT]  yshifted (wiggle(xpart(_u_[LEFT] )/u,f)*u);
       aux[END]   := _u_[END]   yshifted (wiggle(xpart(_u_[END]  )/u,f)*u);
       aux[RIGHT] := _u_[RIGHT] yshifted (wiggle(xpart(_u_[RIGHT])/u,f)*u);

       draw aux[RIGHT] -- _u_[BOTTOM];
       draw aux[BEGIN]
            -- aux[LEFT]{down}
            .. _u_[MID]
            .. aux[RIGHT]{up}
            -- aux[END];

    setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% v -> ()
%

outputtemplate := "v.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _v_[LEFT]
        -- _v_[BOTTOM]
        -- _v_[RIGHT];

   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% v -> c
%

outputtemplate := "vc-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

% Wir drehen das v und bringen die drei Punkte
% gleich in die richtigen "c"-Positionen:
aux[LEFT]   := _c_[BEGIN] rotatedaround (C,90);
aux[RIGHT]  := _c_[END]   rotatedaround (C,90);
aux[BOTTOM] := _c_[LEFT]  rotatedaround (C,90);

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       tmppath0 := m[_v_[LEFT],aux[LEFT]]
                   -- m[_v_[BOTTOM],aux[BOTTOM]]
                   -- m[_v_[RIGHT],aux[RIGHT]];

       draw tmppath0 rotatedaround (C,-90m);

       setbounds currentpicture to boundingpath;
    endfig;
endfor

aux[TOP]    := 1/2[_c_[LEFT],_c_[BEGIN]];
aux[BOTTOM] := 1/2[_c_[LEFT],_c_[END]];

% Ein Hilfspfad zur Winkelbestimmung:
tmppath0 := _c_[BEGIN]
            -- _c_[LEFT]
            -- _c_[END];
phi[U_ARC] := angle(direction 0 of tmppath0);
phi[D_ARC] := angle(direction 2 of tmppath0);


for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw _c_[BEGIN]
            .. m[aux[TOP],_c_[TOP]]
            .. {dir m[phi[U_ARC],-90]}
               _c_[LEFT]
               {dir m[phi[D_ARC],-90]}
            .. m[aux[BOTTOM],_c_[BOTTOM]]
            .. _c_[END];

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% w -> ()
%

outputtemplate := "w.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _w_[BEGIN]
        -- _w_[LEFT]
        -- _w_[MID]
        -- _w_[RIGHT]
        -- _w_[END];

   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;


%
% w -> t
%

outputtemplate := "wt-%c.mps";

beginfig(start);
   draw tmppic;
endfig;


% ein Hilfspunkt über _w_[RIGHT] auf halber Buchstabenhöhe
aux[RIGHT] := (xpart(_w_[RIGHT]),ypart(1/2[_w_[MID],_w_[RIGHT]]));
phi[RIGHT] := angle(aux[RIGHT]-_w_[MID]);

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       tmppath0 := _w_[MID]
                   -- min(2m,1)[_w_[RIGHT],aux[RIGHT]]
                   -- m[_w_[END],_w_[MID]];

       draw _w_[BEGIN]
            -- _w_[LEFT]
            -- _w_[MID];

       draw tmppath0 rotatedaround (_w_[MID],m[0,180-phi[RIGHT]]);

       setbounds currentpicture to boundingpath;
    endfig;
endfor

aux[LEFT] := aux[RIGHT] rotatedaround (_w_[MID],180-phi[RIGHT]);
aux[MID]  := 1/2[_w_[LEFT],_w_[MID]];

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[aux[LEFT],_t_[LEFT]]
            -- m[_w_[MID],_t_[RIGHT]];

       draw m[_w_[BEGIN],_t_[BEGIN]]
            -- m[_w_[LEFT],_t_[MID]]
         &  m[_w_[LEFT],_t_[MID]]
            .. m[aux[MID],_t_[BOTTOM]]
            .. m[_w_[MID],_t_[END]];

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% x -> ()
%

outputtemplate := "x.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _x_[BEGIN]
        -- _x_[RIGHT];
   draw _x_[LEFT]
        -- 5/4[_x_[LEFT],_x_[END]];
   setbounds currentpicture to boundingpath;
endfig;

%
% y -> ()
%

outputtemplate := "y.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _y_[RIGHT]
        -- _y_[BOTTOM]{down}
        .. _y_[D_ARC];
   draw _y_[BEGIN]
        -- _y_[LEFT]
        .. _y_[MID]
        .. _y_[RIGHT]
        -- _y_[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% y -> n
%

outputtemplate := "yn-%c.mps";

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       tmppath0 := _y_[D_ARC]
                   .. _y_[BOTTOM]{up}
                   -- _y_[RIGHT];

       draw subpath (m,2) of tmppath0;

       draw _y_[BEGIN]
        -- _y_[LEFT]{down}
        .. _y_[MID]
        .. _y_[RIGHT]{up}
        -- _y_[END];

       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       tmppath0 := _y_[RIGHT] -- _y_[BOTTOM];
       tmppath1 := _y_[BEGIN]
                   -- _y_[LEFT]{down}
                   .. _y_[MID]
                   .. _y_[RIGHT]{up}
                   -- _y_[END];

       draw tmppath0 rotatedabout (C,180m);
       draw tmppath1 rotatedabout (C,180m);

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% z -> ()
%

outputtemplate := "z.mps";

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _z_[BEGIN]
        -- _z_[U_ARC]
        -- _z_[D_ARC]
        -- _z_[END];
   setbounds currentpicture to boundingpath;
endfig;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Part VI: Uhrsymbol im "o"
%
%   ###
%  # # #
% #  ####
%  #   #
%   ###
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

outputtemplate := "clock-%c.mps";

% Um das Uhr-Oval zu zeichnen, werden die Punkte in Hilfsvariablen kopiert;
% mittels modulo-Berechnungen können dann die Punkte passend angesprochen
% werden:
aux[0] := _o_[TOP];
aux[1] := (lw,xh/2);
aux[2] := _o_[BOTTOM];
aux[3] := aux[1] xscaled -1;
% Dasselbe gilt für die Winkel:
phi[0] :=   0;
phi[1] := -90;
phi[2] := 180;
phi[3] :=  90;
% Das Oval wird komplett als Pfad hinterlegt:
tmppath0 := aux[0]
            .. aux[1]
            .. aux[2]
            .. aux[3]
            .. cycle;

for i = 0 upto 719:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       % Zeiger: wir ermitteln die Schnittpunkte der o-Linie
       % mit den Zeiger-Halbgeraden, die in C ansetzen:
       tmppath1 := C -- (0,infinity) rotatedaround (C,-i*6);
       tmppath2 := C -- (0,infinity) rotatedaround (C,-i/2);
       % TOP ist der längere Minutenzeiger, BOTTOM der Stundenzeiger:
       aux[TOP]    := tmppath0 intersectionpoint tmppath1;
       aux[BOTTOM] := tmppath0 intersectionpoint tmppath2;

       % parallel zum Stundenzeiger werden Halbgeraden definiert:
       tmppath3 := (C -- (0,infinity)) shifted (-0.15u,0) rotatedaround (C,-i*6);
       tmppath4 := (C -- (0,infinity)) shifted  (0.15u,0) rotatedaround (C,-i*6);
       % die Schnittpunkte mit dem Oval bilden BEGIN und END der
       % offenen Begrenzungslinie:
       aux[BEGIN] := tmppath0 intersectionpoint tmppath4;
       aux[END]   := tmppath0 intersectionpoint tmppath3;

       % zusätzlich werden die Winkel in diesen Punkten bestimmt und
       % per ceiling-Funktion der jeweilige Quadrant beziffert, in dem
       % die Punkte gerade liegen:
       %
       %   4  |  1
       % -----+-----
       %   3  |  2
       %
       tmp[BEGIN] := xpart(tmppath0 intersectiontimes tmppath4);
       phi[BEGIN] := angle(direction tmp[BEGIN] of tmppath0);
       tmp[BEGIN] := ceiling(tmp[BEGIN]);
       tmp[END]   := xpart(tmppath0 intersectiontimes tmppath3);
       phi[END]   := angle(direction tmp[END] of tmppath0);
       tmp[END]   := ceiling(tmp[END]);

       % anschließend werden die Zeiger skaliert:
       % der Minutenzeiger ist länger,
       % der Stundenzeiger kürzer.
       draw 4/3[C,aux[TOP]]
            -- C
            -- 2/3[C,aux[BOTTOM]];
       % das Oval:
       draw aux[BEGIN]{dir phi[BEGIN]}
            .. aux[tmp[BEGIN] mod 4]{dir phi[tmp[BEGIN] mod 4]}
            .. aux[(tmp[BEGIN]+1) mod 4]{dir phi[(tmp[BEGIN]+1) mod 4]}
            .. aux[(tmp[BEGIN]+2) mod 4]{dir phi[(tmp[BEGIN]+2) mod 4]}
            if (tmp[END] mod 4) <> ((tmp[BEGIN]+3) mod 4):
            .. aux[(tmp[BEGIN]+3) mod 4]{dir phi[(tmp[BEGIN]+3) mod 4]}
            fi
            .. aux[END]{dir phi[END]};

       setbounds currentpicture to boundingpath;
    endfig;
endfor

end;