%
% glyph
%
% die Bilder werden in der Form glyph.ffttnn erzeugt:
% f = "from": Startziffer (Position im Alphabet)
% t = "to":   Endziffer
% nn : laufende Nummer
%
% Für die Anzeige des Monats (jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)
% sind folgende Übergänge notwendig (dahinter die Kodierung):
%
% a -> e 0105
% a -> m 0113
% a -> p ---- schon in digit enthalten
% a -> s 0119
% a -> u 0121
% b -> r 0218
% c -> n 0314
% c -> o 0315
% d -> j 0410
% e -> a 0501
% e -> c 0503
% f -> m 0613
% g -> p 0716
% j -> a 1001
% j -> f 1006
% j -> j 1010
% l -> g 1207
% m -> a 1301
% m -> j 1310
% n -> b 1402
% n -> d 1404
% n -> l 1412
% o -> e 1505
% o -> n 1514
% p -> a ---- schon in digit enthalten
% p -> t 1620
% r -> r 1818
% r -> y 1825
% s -> o 1915
% t -> v 2022
% u -> e 2105
% u -> u 2121
% v -> c 2203
% y -> n 2514


% Versionsnummer:
string version;
version := "Version: 0.01";
show(version);

show("call with '-numbersystem=double' to prevent overflow errors");

outputtemplate := "%j-%c.mps";
outputformat := "eps";

warningcheck := 0; % unterdrückt Fehlermeldungen für i > 4096 bei beginfig(i);

numeric f;      % [f]rame index
numeric fpht;   % [f]rames [p]er [h]alf [t]ransition
fpht := 50;
numeric start;  % [start] of transition;
numeric m;      % [m]orph factor
numeric t;      % [t]ension
numeric tt;     % ano[t]her [t]ension ;-)
numeric phi[];  % rotation angle [phi1]
numeric u;      % [u]nit
u := 5cm;
numeric q;      % [q]adratic factor
pair C;         % [C]enter of rotation
C := (0,0.425u);
pen pc;         % [p]en[c]ircle
pc := pencircle scaled 0.1u;
path tmppath[]; % [t]e[mp]orary [path]
numeric tmp[];  % [t]e[mp]orary variable
pair aux[];     % [aux]iliary points;
picture tmppic; % [t]e[mp]orary [pic]ture

% symbolische Variablen
numeric LEFT, RIGHT, TOP, BOTTOM;
numeric BEGIN, END, JOINT, MID;
numeric L_ARC, R_ARC, U_ARC, D_ARC;
LEFT   = 1000;
RIGHT  = 1001;
TOP    = 1002;
BOTTOM = 1003;
BEGIN  = 1004;
END    = 1005;
JOINT  = 1006;
MID    = 1007;
L_ARC  = 1008; % [l]eft (part of) [arc]
R_ARC  = 1009; % [r]ight (part of) [arc]
U_ARC  = 1010; % [u]pright (part of) [arc]
D_ARC  = 1011; % [d]ownright (part of) [arc]

% Array für die Null
pair zero[];

% Arrays für die Buchstaben:
pair _a_[], _b_[], _c_[], _d_[],
     _e_[], _f_[], _g_[], _j_[],
     _l_[], _m_[], _n_[], _o_[],
     _p_[], _r_[], _s_[], _t_[],
     _u_[], _v_[], _y_[];

% draft kennzeichnet den Entwurfsmodus:
numeric draft; draft := 1;

def draw_grid(expr u) =
    if draft > 0:
      draw (-0.6u,-0.75u) -- (-0.6u,1.5u) -- (0.6u,1.5u) -- (0.6u,-0.75u) -- cycle;
      draw (-0.6u,0) -- (0.6u,0);
      draw (-0.6u,0.85u) -- (0.6u,0.85u);
      draw (-0.25u,-0.75u)--(-0.25u,1.5u);
      draw (0.25u,-0.75u)--(0.25u,1.5u);
    fi
enddef;

path boundingpath;
boundingpath := (-0.6u,-0.75u)
                -- (-0.6u,1.5u)
                -- (0.6u,1.5u)
                -- (0.6u,-0.75u)
                -- cycle;

vardef advanced(expr xx) = sind(90xx) enddef;
vardef retarded(expr xx) = 1-cosd(90xx) enddef;

% Die Exponentialfunktion ist standardmäßig nicht definiert: 
vardef exp(expr xx) = (mexp(256)**xx) enddef;

% Wir definieren ein "yshifted" für den Buchstaben "m":
primarydef z yshifted yy = z shifted (0,yy) enddef;

% eine Funktion zur Berechnung des Startwertes gemäß ffttnn:
vardef transition(expr from, to) =
    save i;
    i := (ASCII(from)-96)*10000+(ASCII(to)-96)*100;
    i
enddef;

show transition("c","c");

show transition("z","a");

%
% Null
%
zero[TOP]    = (0,0.85u);
zero[BOTTOM] = (0,0);
zero[LEFT]   = (-0.25u,0.425u);
zero[RIGHT]  = zero[LEFT] xscaled -1;


%
% a
%

_a_[BEGIN]  = (-0.25u,0.6u);
_a_[TOP]    = zero[TOP];
_a_[R_ARC]  = _a_[BEGIN] xscaled -1;
_a_[JOINT]  = (0.25u,0.15u);
_a_[END]    = (0.325u,0);
_a_[L_ARC]  = _a_[JOINT] xscaled -1;
_a_[BOTTOM] = zero[BOTTOM];

start := transition("a","e");
beginfig(start);
   draw_grid(u);
   pickup pc;

   tmppath1 := _a_[BEGIN]
               ..  _a_[TOP]
               ..  _a_[R_ARC]
               --- _a_[JOINT]
               .. _a_[END];
   aux0 := direction 2 of tmppath1;
   phi[R_ARC] := angle(aux0);
   % phi[R_ARC] wird für a -> p UND p -> a benötigt!

   tmppath2 := _a_[R_ARC]{dir phi[R_ARC]}
               .. _a_[L_ARC]
               .. _a_[BOTTOM]
               .. _a_[JOINT];
   % Der Schnitpunkt von a-"Bauch" und y-Achse wird
   % beim Übergang p -> a benötigt:
   _a_[MID] := tmppath2 intersectionpoint ((0,0.01u)--(0,infinity));

   draw tmppath1;
   draw tmppath2;
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;
% a -> m
beginfig(transition("a","m"));
   draw tmppic;
endfig;
% a -> s
beginfig(transition("a","s"));
   draw tmppic;
endfig;
% a -> u
beginfig(transition("a","u"));
   draw tmppic;
endfig;

%
% a -> e
%

%
% a -> m
%

%
% a -> p (schon definiert)
%

%
% a -> s
%

%
% a -> u
%

%
% p
%
_p_[BEGIN]  = (-0.325u,0.85u);
_p_[END]    = (-0.325u,-0.65u);
_p_[U_ARC]  = (-0.325u,0.6u); % [u]pper end of [arc]
_p_[D_ARC]  = (-0.325u,0.15u);
_p_[TOP]    = zero[TOP];
_p_[BOTTOM] = zero[BOTTOM];
_p_[RIGHT]  = (0.325u,0.425u);

%
% b
%

_b_[BEGIN]  = _p_[BEGIN] shifted (0,0.5u);
_b_[END]    = _p_[END] shifted (0,0.65u);
_b_[U_ARC]  = _p_[U_ARC];
_b_[D_ARC]  = _p_[D_ARC];
_b_[TOP]    = _p_[TOP];
_b_[BOTTOM] = _p_[BOTTOM];
_b_[RIGHT]  = _p_[RIGHT];

start := transition("b","r");
beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _b_[BEGIN] -- _b_[END];
   draw _b_[U_ARC]
        .. _b_[TOP]
        .. _b_[RIGHT]
        .. _b_[BOTTOM]
        .. _b_[D_ARC];
   setbounds currentpicture to boundingpath;
endfig;

%
% b -> r
%

%
% c
%


%
% c -> n
%

%
% c -> o
%

%
% d
%

_d_[BEGIN]  = _b_[BEGIN] xscaled -1;
_d_[END]    = _b_[END] xscaled -1;
_d_[U_ARC]  = _b_[U_ARC] xscaled -1;
_d_[D_ARC]  = _b_[D_ARC] xscaled -1;
_d_[TOP]    = _b_[TOP] xscaled -1;
_d_[BOTTOM] = _b_[BOTTOM] xscaled -1;
_d_[LEFT]  = _b_[RIGHT] xscaled -1;

%
% d -> j
%

start := transition("d","j");
beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _d_[BEGIN] -- _d_[END];
   draw _d_[U_ARC]
        .. _d_[TOP]
        .. _d_[LEFT]
        .. _d_[BOTTOM]
        .. _d_[D_ARC];
   setbounds currentpicture to boundingpath;
endfig;

%
% e
%

%
% e -> a
%

%
% e -> c
%

%
% f
%

_f_[BEGIN]  = (-0.15u,0);
_f_[MID]    = (-0.15u,1.2u);
_f_[TOP]    = (0, 1.35u);
aux[MID]   := (0,ypart(_f_[MID]));
_f_[END]    = _f_[TOP] rotatedabout (aux[MID],-45);

_f_[LEFT]   = (-0.25u,0.85u);
_f_[RIGHT]  = (-0.05u,0.85u);

%
% f -> m
%

start := transition("f","m");
beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _f_[LEFT] -- _f_[RIGHT];

   draw _f_[BEGIN]
        -- _f_[MID]
        .. _f_[TOP]
        .. _f_[END];
   setbounds currentpicture to boundingpath;
endfig;

%
% g
%

%
% g -> p
%

%
% j
%

_j_[TOP]    = (0.15u, 0.85u);
_j_[BEGIN]  = (0.15u,0.6u);
_j_[MID]    = (0.15u,-0.5u);
_j_[BOTTOM] = (0,-0.65u);
aux[MID]   := (0,ypart(_j_[MID])); % Hilfspunkt, Rotationszentrum
_j_[END]    = _j_[BOTTOM] rotatedaround (aux[MID],-45);

%
% j -> a
%

start := transition("j","a");
beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _j_[TOP];
   draw _j_[BEGIN]
        -- _j_[MID]
        .. _j_[BOTTOM]
        .. _j_[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;
% j -> f
beginfig(transition("j","f"));
   draw tmppic;
endfig;
% j -> j
beginfig(transition("j","j"));
   draw tmppic;
endfig;

%
% j -> f
%

% Der j-Bogen wandert weiter in den f-Bogen hinein
% der Hilfspunkt aux[JOINT] verbindet j und f

aux[JOINT] := (xpart(_f_[BEGIN]),ypart(_j_[MID]));

tmppath0 := _j_[BEGIN]
            -- _j_[MID]
            .. _j_[BOTTOM]
            .. _j_[END]
            .. aux[JOINT]
            -- _f_[BEGIN]
            -- _f_[MID]
            .. _f_[TOP]
            .. _f_[END];

start := transition("j","f");
for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       
       draw _j_[TOP];
                     
       draw subpath (0,5m+4) of tmppath0;
       
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[_j_[TOP],_f_[LEFT]]
            -- m[_j_[TOP],_f_[RIGHT]];
            
       draw subpath (5m,8) of tmppath0;

       setbounds currentpicture to boundingpath;
    endfig;
endfor


%
% j -> j
%

%
% l
%

_l_[BEGIN]  = (-0.15u,1.35u);
_l_[MID]    = (-0.15u,0.15u);
aux[MID]   := (0,ypart(_l_[MID]));
_l_[BOTTOM] = (0,0);
_l_[END]    = _l_[BOTTOM] rotatedaround(aux[MID],45);

%
% l - > g
%

start := transition("l","g");
beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _l_[BEGIN]
        -- _l_[MID]
        .. _l_[BOTTOM]
        .. _l_[END];
   setbounds currentpicture to boundingpath;
endfig;

%
% m
%

tmp0 := 0.375;
tmp1 := 0.85;
_m_[BEGIN] = (-tmp0*u,tmp1*u);
_m_[LEFT]  = (-tmp0*u,3/4*tmp1*u);
_m_[BOTTOM] = (-tmp0*u,0);
_m_[L_ARC] = (-.5tmp0*u,tmp1*u);
_m_[JOINT] = (0,0.65u);
_m_[MID]   = (0,0);
_m_[R_ARC] = _m_[L_ARC] xscaled -1;
_m_[RIGHT] = _m_[LEFT] xscaled -1;
_m_[END]   = _m_[BOTTOM] xscaled -1;

start := transition("m","a");

beginfig(start);
draw_grid(u);
   pickup pc;

   draw _m_[BEGIN] -- _m_[LEFT];
   draw _m_[BOTTOM]
        -- _m_[LEFT]{up}
        .. _m_[L_ARC]
        .. _m_[JOINT]{down}
     &  _m_[JOINT]{up}
        .. _m_[R_ARC]
        .. _m_[RIGHT]{down}
        -- _m_[END];
   draw _m_[MID] -- _m_[JOINT];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;
% m -> j
beginfig(transition("m","j"));
   draw tmppic;
endfig;

%
% m -> a
%

%
% m -> j
%

%
% n
%

tmp0 := 0.25;
tmp1 := 0.85;
_n_[BEGIN] = (-tmp0*u,tmp1*u);
_n_[LEFT]  = (-tmp0*u,3/4*tmp1*u);
_n_[BOTTOM] = (-tmp0*u,0);
_n_[MID]   = (0,tmp1*u);
_n_[RIGHT] = _n_[LEFT] xscaled -1;
_n_[END]   = _n_[BOTTOM] xscaled -1;

%
% n -> b
%

start := transition("n","b");

beginfig(start);
draw_grid(u);
   pickup pc;

   draw _n_[BEGIN] -- _n_[LEFT];
   draw _n_[BOTTOM]
        -- _n_[LEFT]{up}
        .. _n_[MID]
        .. _n_[RIGHT]{down}
        --_n_[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;
% n -> d
beginfig(transition("n","d"));
   draw tmppic;
endfig;
% n -> l
beginfig(transition("n","l"));
   draw tmppic;
endfig;

%
% n -> d
%

%
% n -> l
%

%
% o
%

% kopiert von Sechs

_o_[LEFT]   = zero[LEFT] xscaled 3/2;
_o_[RIGHT]  = zero[RIGHT] xscaled 3/2;
_o_[TOP]    = zero[TOP];
_o_[BOTTOM] = zero[BOTTOM];

%
% o -> e
%

start := transition("o","e");

beginfig(start);
draw_grid(u);
   pickup pc;

   draw _o_[TOP]
        .. _o_[RIGHT]
        .. _o_[BOTTOM]
        .. _o_[LEFT]
        .. cycle;
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;
% o -> n
beginfig(transition("o","n"));
   draw tmppic;
endfig;
%
% o -> n
%

%
% p
%
start := transition("p","t");
beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _p_[BEGIN] -- _p_[END];
   draw _p_[U_ARC]
        .. _p_[TOP]
        .. _p_[RIGHT]
        .. _p_[BOTTOM]
        .. _p_[D_ARC];
   setbounds currentpicture to boundingpath;
endfig;

%
% p -> a (schon definiert)
%

%
% p -> t
%

%
% r
%

%
% r -> r 
%

%
% r -> t
%

%
% s
%

%
% s -> o
%

%
% t
%

_t_[LEFT]   = _f_[LEFT];
_t_[RIGHT]  = _f_[RIGHT]; 

_t_[BEGIN]  = _l_[BEGIN];
_t_[MID]    = _l_[MID];
_t_[BOTTOM] = _l_[BOTTOM];
_t_[END]    = _l_[END];

%
% t -> v
%

start := transition("t","v");
beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _t_[LEFT] -- _t_[RIGHT];
   
   draw _t_[BEGIN]
        -- _t_[MID]
        .. _t_[BOTTOM]
        .. _t_[END];
   setbounds currentpicture to boundingpath;
endfig;

%
% u
%

_u_[BOTTOM] = _n_[BEGIN]  rotatedaround(C,180);
_u_[RIGHT]  = _n_[LEFT]   rotatedaround(C,180);
_u_[BEGIN]  = _n_[END]    rotatedaround(C,180);
_u_[MID]    = _n_[MID]    rotatedaround(C,180);
_u_[LEFT]   = _n_[RIGHT]  rotatedaround(C,180);
_u_[END]    = _n_[BOTTOM] rotatedaround(C,180);

start := transition("u","e");

beginfig(start);
draw_grid(u);
   pickup pc;

   draw _u_[RIGHT] -- _u_[BOTTOM];
   draw _u_[BEGIN]
        -- _u_[LEFT]{down}
        .. _u_[MID]
        .. _u_[RIGHT]{up}
        -- _u_[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;
% u -> u
beginfig(transition("u","u"));
   draw tmppic;
endfig;

%
% u -> e
%

%
% u -> u
%

%
% v
%

%
% v -> c
%

%
% y
%

_y_[BOTTOM] = _u_[BOTTOM];
_y_[U_ARC] = (-0.25u,-0.65u);
_y_[RIGHT]  = _u_[RIGHT];
_y_[BEGIN] = _u_[BEGIN];
_y_[MID] = _u_[MID];
_y_[LEFT] = _u_[LEFT];
_y_[END] = _u_[END];

%
% y -> n
%

start := transition("y","n");

beginfig(start);
draw_grid(u);
   pickup pc;

   draw _y_[RIGHT]
        -- _y_[BOTTOM]{down}
        .. _y_[U_ARC];
   draw _y_[BEGIN]
        -- _y_[LEFT]{down}
        .. _y_[MID]
        .. _y_[RIGHT]{up}
        -- _y_[END];
   setbounds currentpicture to boundingpath;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       
       draw _y_[RIGHT]
            -- _y_[BOTTOM]{down}
            .. m[_y_[U_ARC],_y_[BOTTOM]];
       draw _y_[BEGIN]
        -- _y_[LEFT]{down}
        .. _y_[MID]
        .. _y_[RIGHT]{up}
        -- _y_[END];
       
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);
       
       tmppath0 := _y_[RIGHT] -- _y_[BOTTOM];
       tmppath1 := _y_[BEGIN]
                   -- _y_[LEFT]{down}
                   .. _y_[MID]
                   .. _y_[RIGHT]{up}
                   -- _y_[END];
                    
       draw tmppath0 rotatedabout (C,180m);
       draw tmppath1 rotatedabout (C,180m);
       
       setbounds currentpicture to boundingpath;
    endfig;
endfor

end;
