%
% glyph.mpost
%
% die Ziffern und Buchstaben werden 
% a) als Einzelzeichen in der Form glyph-n erzeugt:
%    n := ASCII(glyph)-32
% b) als Übergänge in der Form glyph-ffttnn erzeugt:
% f = "from": Startziffer (Position im Alphabet)
% t = "to":   Endziffer
% nn : laufende Nummer
%
% Als Ziffernübergänge benötigen wir
% 0 -> 1, 1 -> 2, 2 -> 3, 3 -> 4, 4 -> 5,
% 5 -> 6, 6 -> 7, 7 -> 8, 8 -> 9, 9 -> 0 sowie
% 1 -> 0, 2 -> 0, 2 -> 1, 3 -> 0, 5 -> 0
%
% Als Interpunktionen haben wir nur den ":"
% und den Übergang : -> :
%
% Für die Anzeige des Monats (jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)
% und des Wochentages (mon|tue|wed|thu|fri|sat|sun)
% sind folgende Übergänge notwendig
%
% a -> e, a -> m, a -> p, a -> s, a -> u,
% b -> r, c -> n, c -> o, d -> j, d -> u,
% e -> a, e -> c, e -> d, e -> h, f -> m,
% f -> s, g -> p, h -> r, i -> t, j -> a,
% j -> f, j -> j, l -> g, m -> a, m -> j,
% m -> m, m -> t, n -> b, n -> d, n -> e,
% n -> l, n -> n, o -> e, o -> n, o -> u,
% p -> a, p -> t, r -> a, r -> r, r -> y,
% s -> m, s -> o, s -> s, t -> f, t -> n,
% t -> v, t -> w, u -> e, u -> i, u -> o,
% u -> u, v -> c, w -> t, y -> n
%
% Das Uhr-O schließlich ist unter clock-n
% n := hour*60+min (also n = 0 ... 719)
% abgelegt.

% Versionsnummer:
string version;
version := "Version: 0.01";
show(version);

show("call with '-numbersystem=double' to prevent overflow errors");

outputtemplate := "%j-%c.mps";
outputformat := "eps";

%warningcheck := 0; % unterdrückt Fehlermeldungen für i > 4096 bei beginfig(i);

numeric f;      % [f]rame index
numeric fpht;   % [f]rames [p]er [h]alf [t]ransition
fpht := 50;
numeric start;  % [start] of transition;
numeric m;      % [m]orph factor
numeric t;      % [t]ension
numeric tt;     % ano[t]her [t]ension ;-)
numeric phi[];  % rotation angle [phi1]
numeric u;      % [u]nit
u := 5cm;
numeric q;      % [q]adratic factor
pair C;         % [C]enter of rotation
C := (0,0.425u);
pen pc;         % [p]en[c]ircle
pc := pencircle scaled 0.1u;
path tmppath[]; % [t]e[mp]orary [path]
numeric tmp[];  % [t]e[mp]orary variable
pair aux[];     % [aux]iliary points;
picture tmppic; % [t]e[mp]orary [pic]ture

% symbolische Variablen
numeric LEFT, RIGHT, TOP, BOTTOM;
numeric BEGIN, END, JOINT, MID;
numeric L_ARC, R_ARC, U_ARC, D_ARC;
LEFT   = 1000;
RIGHT  = 1001;
TOP    = 1002;
BOTTOM = 1003;
BEGIN  = 1004;
END    = 1005;
JOINT  = 1006;
MID    = 1007;
L_ARC  = 1008; % [l]eft (part of) [arc]
R_ARC  = 1009; % [r]ight (part of) [arc]
U_ARC  = 1010; % [u]pright (part of) [arc]
D_ARC  = 1011; % [d]ownright (part of) [arc]


% Arrays für die Koordinaten der Ziffern:
pair zero[], one[],   two[], three[], four[];
pair five[], six[], seven[], eight[], nine[];

% Array für den Doppelpunkt:

pair colon[];

% Arrays für die Buchstaben:
pair _a_[], _b_[], _c_[], _d_[],
     _e_[], _f_[], _g_[], _h_[],
     _i_[], _j_[], _k_[], _l_[],
     _m_[], _n_[], _o_[], _p_[],
     _q_[], _r_[], _s_[], _t_[],
     _u_[], _v_[], _w_[], _x_[],
     _y_[], _z_[];

% draft kennzeichnet den Entwurfsmodus:
numeric draft; draft := 1;

def draw_grid(expr u) =
    if draft > 0:
      draw (-0.6u,-0.75u) -- (-0.6u,1.5u) -- (0.6u,1.5u) -- (0.6u,-0.75u) -- cycle;
      draw (-0.6u,0) -- (0.6u,0);
      draw (-0.6u,0.85u) -- (0.6u,0.85u);
      draw (-0.25u,-0.75u)--(-0.25u,1.5u);
      draw (0.25u,-0.75u)--(0.25u,1.5u);
    fi
enddef;

path boundingpath;
boundingpath := (-0.6u,-0.75u)
                -- (-0.6u,1.5u)
                -- (0.6u,1.5u)
                -- (0.6u,-0.75u)
                -- cycle;

vardef advanced(expr xx) = sind(90xx) enddef;
vardef retarded(expr xx) = 1-cosd(90xx) enddef;

% Die Exponentialfunktion ist standardmäßig nicht definiert: 
vardef exp(expr xx) = (mexp(256)**xx) enddef;

% Wir definieren ein "yshifted" für den Buchstaben "m":
primarydef z yshifted yy = z shifted (0,yy) enddef;

% eine Funktion zur Berechnung des Startwertes gemäß ffttnn:
vardef transition(expr from, to) =
    i := (ASCII(from)-32)*10000+(ASCII(to)-32)*100;
    i
enddef;

% die Glyphen verwenden wir zusätzlich "standalone":
vardef standalone(expr glyph) = 
    save i;
    i := ASCII(glyph)-32;
    i
enddef;

%
% Zur Animation des m benutzen wir folgende Funktion:
%
%  1.5 +-+---------+----------+-----------+----------+-----------+--------+-+
%      +           +          +           +          +           +          +
%      |                                sqrt(2*exp(1))*x*exp(-x**2) ******* |
%    1 +-+                                      ****                      +-+
%      |                                       *    ***                     |
%      |                                     **       **                    |
%  0.5 +-+                                   *          **                +-+
%      |                                   **             **                |
%      |                                   *                ***             |
%    0 +-+                                *                    **************
%      **************                    *                                  |
%      |             ***                *                                   |
%      |                **             **                                   |
% -0.5 +-+                **          *                                   +-+
%      |                    **       **                                     |
%      |                     ***    *                                       |
%   -1 +-+                      ****                                      +-+
%      |                                                                    |
%      +           +          +           +          +           +          +
% -1.5 +-+---------+----------+-----------+----------+-----------+--------+-+
%     -3          -2         -1           0          1           2          3
%
% Wir substituieren:
% x => scale*(x-shift*(2*t-1)), somit  [0 .. t .. 1] => [-1 .. 2t-1 .. 1]
% "shift" gibt die Lage des Nullpunktes der Funktion an,
% "scale" komprimiert den Funktionsverlauf für scale > 1
% "amplitude" ist selbsterklärend
%
% Die Verzerrung läuft somit für t=[0..1] von links nach rechts durch das
% Bild

def wiggle(expr x, t) =
    begingroup
    save scale, shift, amplitude, res;
    scale := 2;
    shift := 1.25;
    amplitude := 0.15;
    res := scale*(x-shift*(2*t-1));
    res := amplitude*sqrt(2*exp(1))*res*exp(-res*res);
    res
    endgroup
enddef;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Part I: Ziffern
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 0
zero[TOP]    = (0,0.85u);
zero[BOTTOM] = (0,0);
zero[LEFT]   = (-0.275u,0.425u);
zero[RIGHT]  = zero[LEFT] xscaled -1;

% 1
one[BEGIN]  = (-0.25u,0.55u);
one[TOP]    = zero[TOP];
one[BOTTOM] = zero[BOTTOM];

% 2
two[BEGIN] = one[BEGIN];
two[TOP]   = one[TOP];
two[R_ARC] = (0.225u,0.55u);
two[JOINT] = (-0.25u,0);
two[END]   = (0.25u,0);

% 3
three[BEGIN]  = (-0.25u,0.65u);
three[TOP]    = two[TOP];
three[U_ARC]  = (0.25u,0.5u);
three[JOINT]  = (-0.15u,0);
three[D_ARC]  = (0.3u,-0.5u);
three[BOTTOM] = (0,-0.65u);
three[END]    = three[D_ARC] xscaled -1;

% 4
four[LEFT]   = (-0.25u,0);
four[TOP]    = (0.25u,0.85u);
four[MID]    = four[LEFT] xscaled -1;
four[BOTTOM] = (0.25u,-0.65u);
four[RIGHT]  = (0.375u,0);

% 5
five[BEGIN] = four[TOP];
five[LEFT]  = five[BEGIN] xscaled -1;
five[JOINT] = four[LEFT];
five[U_ARC] = (0,0.1u);
five[R_ARC] = (0.3u,-0.425u);
five[END]   = (-0.275u,-0.65u);

% 6
six[BEGIN]  = (0.25u,1.35u);
six[LEFT]   = zero[LEFT] xscaled 15/11; % 0.275 -> 0.375
six[RIGHT]  = zero[RIGHT] xscaled 15/11;
six[TOP]    = zero[TOP];
six[BOTTOM] = zero[BOTTOM];

% 7
seven[BEGIN] = (-0.3u,0.75u);
seven[LEFT]  = (-0.3u,0.85u);
seven[JOINT] = seven[LEFT] xscaled -1;
seven[MID]   = (0.1u,0.15u);
seven[END]   = (0,-0.65u);
% Hilfspunkt:
seven[TOP]   = (1/2)[seven[LEFT],seven[JOINT]];

% 8
eight[MID]    = (0,0.85u);
eight[L_ARC]  = (-0.25u,1.1u);
eight[R_ARC]  = eight[L_ARC] xscaled -1;
eight[LEFT]   = (-0.4u,0.35u);
eight[RIGHT]  = eight[LEFT] xscaled -1;
eight[BOTTOM] = zero[BOTTOM];

% 9
nine[TOP]    = six[TOP];
nine[LEFT]   = six[LEFT];
nine[RIGHT]  = six[RIGHT];
nine[BOTTOM] = six[BOTTOM];
nine[END]    = (-0.25u,-0.65u);

%
%%%%%%%%%%%% Ziffern/Übergänge
%

%
% 0 ->()
%

start := standalone("0");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw zero[TOP]
        .. zero[RIGHT]
        .. zero[BOTTOM]
        .. zero[LEFT]
        .. cycle;
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% 0 -> 1
%

start := transition("0","1");

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-start)/fpht;
       m := retarded(f);

       if m < 1:
          draw zero[TOP]
               ... (m/2)[zero[RIGHT],zero[LEFT]]
               ... zero[BOTTOM]
             ... (m/2)[zero[LEFT],zero[RIGHT]]
             ... cycle;
       else:
          % für m = 1 entstünden seltsame Schlaufen
          draw one[TOP] -- one[BOTTOM];
       fi
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[one[TOP],one[BEGIN]]
            -- one[TOP]
            -- one[BOTTOM];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 1 -> ()
%

start := standalone("1");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw one[BEGIN]
        -- one[TOP]
        -- one[BOTTOM];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% 1 -> 2
%

start := transition("1","2");

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw one[BEGIN]
            -- m[one[TOP],two[R_ARC]]
            -- m[one[BOTTOM],two[JOINT]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);
       t := 1/sqrt(sqrt(m)); % zur Vermeidung einer Spitze im Scheitel der 2

       aux[MID] := (1/2)[two[BEGIN],two[R_ARC]];
       aux[TOP] := m[aux[MID],two[TOP]];

       draw two[BEGIN]
            .. tension  t .. aux[TOP]
            .. tension  t .. two[R_ARC]
            .. tension 2t .. two[JOINT]
          & two[JOINT]
            -- m[two[JOINT],two[END]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 1 -> 0
%

start := transition("1","0");

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       tmppath1 := C -- one [TOP] -- one[BEGIN];

       draw subpath (0,2*(1-m)) of tmppath1;
       draw C -- m[one[BOTTOM],C];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;
       f := (i-start-fpht)/fpht;
       m := advanced(f);
       
       % Der horizontale Abstand zwischen dem linken und rechten Rand:
       tmp0 := xpart(m[C,zero[RIGHT]])-xpart(m[C,zero[LEFT]]);

       draw m[C,zero[TOP]]
            .. m[C,zero[RIGHT]]
            .. m[C,zero[BOTTOM]]
            .. m[C,zero[LEFT]]
            .. cycle;
       % Bei engen Schlaufen gibt es Artefakte, daher setzen wir
       % einen Punkt in die Mitte, der diese überdeckt:
       if tmp0 < 0.1u : draw C; fi
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 2 -> ()
%

start := standalone("2");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw two[BEGIN]
        .. two[TOP]
        .. two[R_ARC]
        .. tension 2 .. two[JOINT]
      & two[JOINT] -- two[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% 2 -> 3
%

start := transition("2","3");

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       phi1 := -90m;

       draw two[BEGIN]
            .. two[TOP]
            .. two[R_ARC]
            .. tension 2 .. two[JOINT]
          & two[JOINT]
            -- two[END] rotatedaround (two[JOINT],phi1);
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);
       t := 1/m;

       aux[END] := two[END] rotatedaround (two[JOINT],-90);

       draw m[two[BEGIN],three[BEGIN]]
            .. three[TOP]
            .. m[two[R_ARC],three[U_ARC]]
            .. tension (2-m) .. m[two[JOINT],three[JOINT]]
          & m[two[JOINT],three[JOINT]]
            .. m[two[JOINT],three[D_ARC]]
            .. m[aux[END],three[END]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 2 -> 0
%

start := transition("2","0");
beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       t := 2-m;

       tmppath0 := two[BEGIN] .. two[TOP] .. two[R_ARC];
       aux0     := direction 0 of tmppath0;
       phi1     := m[angle(aux0),90];

       draw m[two[BEGIN],zero[LEFT]]{dir phi1}
            .. m[two[TOP],zero[TOP]]
            .. m[two[R_ARC],zero[RIGHT]]
            .. tension t .. m[two[JOINT],zero[BOTTOM]];
       draw two[JOINT] -- two[END];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Ursprünglicher Winkel bei zero[BOTTOM] ist nicht
% von einem Parameter abhängig:
tmppath0 := zero[LEFT]{up}
                  .. zero[TOP]
                  .. zero[RIGHT]
                  .. zero[BOTTOM];
aux3 := direction 3 of tmppath0;

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       phi1 := m[angle(aux3),-180];

       tmppath0 := zero[BOTTOM]{left} .. m[two[JOINT],zero[LEFT]];
       aux1     := direction 1 of tmppath0;
       phi2     := max(angle(aux1),90);

       draw zero[LEFT]{up}
            .. zero[TOP]
            .. zero[RIGHT]
            .. zero[BOTTOM]{dir phi1};
       draw m[two[END],zero[BOTTOM]]
            -- zero[BOTTOM]{left}
            .. m[two[JOINT],zero[LEFT]]{dir phi2};
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 2 -> 1
%

start := transition("2","1");

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       t := 10*m*m+1;

       %aux[TOP] entspricht dem Startpunkt der Eins, heruntergeklappt
       % an den Mittelstrich:
       aux[TOP]    := one[TOP] shifted (0,-length(one[BEGIN]-one[TOP]));
       % two[R_ARC] und two[JOINT|END] wandern waagrecht zum Mittelstrich:
       aux[MID]    := (xpart(one[TOP]),ypart(two[R_ARC]));
       aux[BOTTOM] := (xpart(one[TOP]),ypart(two[END]));

       if m < 1:
          draw m[two[BEGIN],aux[TOP]]
               .. tension t .. two[TOP]
               .. tension t .. m[two[R_ARC],aux[MID]]
               .. tension (t+1) .. m[two[JOINT],aux[BOTTOM]]
               -- m[two[END],aux[BOTTOM]];
       else:
          draw one[TOP] -- one[BOTTOM];
       fi
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       phi0 := -90-angle(one[BEGIN]-one[TOP]);
       phi1 := (1-m)*phi0;

       draw one[BEGIN] rotatedaround (one[TOP],phi1)
            -- one[TOP]
            -- one[BOTTOM];
       setbounds currentpicture to boundingpath;
    endfig;
endfor


%
% 3 -> ()
%

start := standalone("3");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw three[BEGIN]
        .. three[TOP]
        .. three[U_ARC]
        .. three[JOINT]
      & three[JOINT]
        .. three[D_ARC]
        .. three[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% 3 -> 4
%

start := transition("3","4");

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       t := max(15f*f,1);

       % Der "Austrittswinkel" des unteren Bogens an der "Spitze"
       % wird ermittelt und wandert langsam gegen 0.
       tmppath0 := three[JOINT] .. three[D_ARC] .. three[END];
       aux0 := direction 0 of tmppath0;
       phi1 := (1-m)*angle(aux0);

       draw m[three[BEGIN],four[LEFT]]
            .. tension t .. m[three[TOP],four[TOP]]
            .. tension t .. m[three[U_ARC],four[MID]]
            .. tension t .. three[JOINT]
          & three[JOINT]{dir phi1}
            .. three[D_ARC]
            .. three[END];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);
       t := max(15*f*f*f,1);

       draw four[LEFT]
            -- four[TOP]
            -- four[MID]
            -- m[three[JOINT],four[LEFT]]{right}
            .. tension t .. m[three[D_ARC],four[MID]]
            .. tension t .. m[three[END],four[BOTTOM]];
       draw four[MID]
            -- m[four[MID],four[RIGHT]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 3 -> 0
%

start := transition("3","0");

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       % Übergang oberer Bogen Drei zur Dreiviertel-Null
       tmppath0 := three[BEGIN]
                   .. three[TOP]
                   .. three[U_ARC]
                   .. three[JOINT];
       aux0 := direction 0 of tmppath0;
       phi1 := m[angle(aux0),90];
       aux3 := direction 3 of tmppath0;
       phi2 := m[angle(aux3),-180];

       % Der untere Bogen soll zu einem senkrecht nach unten geklappten
       % Viertelsegment der Null werden:

       tmppath1 := zero[BOTTOM]{left} .. zero[LEFT]{up};
       phi0     := 270-angle(zero[LEFT]-zero[BOTTOM]);

       aux[JOINT] := m[three[JOINT],zero[BOTTOM]];
       aux[D_ARC] := (point 0.5 of tmppath1) rotatedaround (zero[BOTTOM],phi0);
       aux[END]   := zero[LEFT] rotatedaround (zero[BOTTOM],phi0);

       draw m[three[BEGIN],zero[LEFT]]{dir phi1}
            .. m[three[TOP],zero[TOP]]
            .. m[three[U_ARC],zero[RIGHT]]
            .. aux[JOINT]{dir phi2}
          & aux[JOINT]
            .. m[three[D_ARC],aux[D_ARC]]
            .. m[three[END],aux[END]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       phi1 := (1-m)*phi0;

       draw zero[LEFT]{up}
            .. zero[TOP]
            .. zero[RIGHT]
            .. zero[BOTTOM]{left}
            % Der Viertelbogen klappt nach oben:
          & tmppath1 rotatedaround (zero[BOTTOM],phi1);
       setbounds currentpicture to boundingpath;
    endfig;
endfor


%
% 4 -> ()
%

start := standalone("4");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw four[RIGHT]
        -- four[LEFT]
        -- four[TOP]
        -- four[BOTTOM];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% 4 -> 5
%

start := transition("4","5");

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       draw four[TOP]
            -- four[LEFT]
            -- m[four[RIGHT],four[MID]];
       draw m[four[TOP],four[MID]]
            -- four[BOTTOM];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);
       t := max(5(1-m),1);

       % Der Pfad soll bei five[END] maximal waagrecht werden
       % und nicht nach rechts unten zeigen. Weil hier angle(...)
       % einen Vorzeichenwechsel hat, muss eine if-Anweisung her.
       tmppath0 := five[JOINT]
                   .. tension t .. m[four[MID],five[U_ARC]]
                   .. tension 1 .. m[four[MID],five[R_ARC]]
                   .. tension t .. m[four[BOTTOM],five[END]];
       aux4 := direction 4 of tmppath0;
       phi1 := angle(aux4); if phi1 > 0 : phi1 := -180; fi

       draw five[BEGIN]
            -- m[four[TOP],five[LEFT]]
            -- five[JOINT]
            .. tension t .. m[four[MID],five[U_ARC]]
            .. tension 1 .. m[four[MID],five[R_ARC]]
            .. tension t .. {dir phi1}m[four[BOTTOM],five[END]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 5 -> ()
%

start := standalone("5");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw five[BEGIN]
        -- five[LEFT]
        -- five[JOINT]
        .. five[U_ARC]
        .. five[R_ARC]
        .. {left}five[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% 5 -> 6
%

start := transition("5","6");

beginfig(start);
   draw tmppic;
endfig;

% wir gehen hier nur bis fpht-1, weil bei fpht die Schleife geschlossen wäre
% und sich die Zeichenrichtung umdreht:
for i = start+1 upto start+fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       % die linke Ecke five[LEFT] wandert genauso schnell nach oben wie
       % five[BEGIN], aber die x-Koordinate bleibt unverändert:

       aux[LEFT] := (xpart(five[LEFT]),ypart(m[five[BEGIN],six[BEGIN]]));

       draw m[five[BEGIN],six[BEGIN]]
            -- aux[LEFT]
            -- m[five[JOINT],six[LEFT]];
       draw m[five[JOINT],six[LEFT]]
            .. m[five[U_ARC],six[TOP]]
            .. m[five[R_ARC],six[RIGHT]]
            .. {left}m[five[END],six[BOTTOM]]
            .. m[five[END],six[LEFT]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);
       t := 1/(m+0.001); % m kann Null werden

       % wir ermitteln den Punkt, der auf 2/3 des abschließenden Bogens liegt;
       % aux[MID] wandert von der linken Ecke der nach oben geschobenen "5"
       % zum Zielpunkt.
       % Weil er dann auf dem Bogen liegt, kann er bei der "6" einfach
       % weggelassen weden.

       tmppath0   := six[LEFT]{up} .. six[BEGIN];
       aux[END]   := point 2/3 of tmppath0;
       aux[BEGIN] := (xpart(five[LEFT]),ypart(six[BEGIN]));
       aux[MID]   := m[aux[BEGIN],aux[END]];

       draw six[LEFT]{up}
            .. six[TOP]
            .. six[RIGHT]
            .. six[BOTTOM]
            .. six[LEFT]{up}
            .. tension t .. aux[MID]
            .. tension t .. six[BEGIN];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 5-> 0
%

start := transition("5","0");

beginfig(start);
   draw tmppic;
endfig;

% wir gehen hier nur bis fpht-1, weil bei fpht die Schleife geschlossen wäre
% und sich die Zeichenrichtung umdreht (siehe Übergang 5 -> 6):
for i = start+1 upto start+fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       tmppath0 := m[five[JOINT],zero[LEFT]]
                   .. m[five[U_ARC],zero[TOP]]
                   .. m[five[R_ARC],zero[RIGHT]]
                   .. {left}m[five[END],zero[BOTTOM]]
                   .. m[five[END],zero[LEFT]]{up};

       aux0 := direction 0 of tmppath0;
       phi1 := min(angle(aux0),90);

       draw m[five[BEGIN],five[LEFT]]
            -- five[LEFT]
            -- m[five[JOINT],zero[LEFT]]
          & m[five[JOINT],zero[LEFT]]{dir phi1}
            .. m[five[U_ARC],zero[TOP]]
            .. m[five[R_ARC],zero[RIGHT]]
            .. {left}m[five[END],zero[BOTTOM]]
            .. m[five[END],zero[LEFT]]{up};
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);
       t := 1/(m+0.001); % m kann Null werden

       draw zero[LEFT]{up}
            .. zero[TOP]
            .. zero[RIGHT]
            .. zero[BOTTOM]
            .. zero[LEFT]{up}
            -- m[five[LEFT],zero[LEFT]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 6 -> ()
%

start := standalone("6");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw six[LEFT]{up}
        .. six[TOP]
        .. six[RIGHT]
        .. six[BOTTOM]
        .. six[LEFT]{up}
        .. six[BEGIN];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% 6 -> 7
%

start := transition("6","7");

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       q := 2m*m-2*m+1;
         % Parabelabschnitt y = 1 .. 1/2 .. 1 für x = 0 .. 0.5 .. 1;
       phi1 := 180m;

       aux[MID]   := six[LEFT]   rotatedaround (C,phi1);
       aux[END]   := (six[BEGIN] yscaled q) rotatedaround (C,phi1);
       aux[TOP]   := six[RIGHT]  rotatedaround (C,phi1/2);
       aux[LEFT]  := six[TOP]    rotatedaround (C,phi1/4);
       aux[JOINT] := six[BOTTOM] rotatedaround (C,3phi1/4);
       aux[BEGIN] := six[LEFT] shifted (0.125m*u,0.075m*u);

       draw aux[BEGIN]
            ... aux[LEFT]
            ... aux[TOP]
            ... aux[JOINT]
            .. aux[MID]{dir (phi1+90)}
            .. aux[END];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);
       t := max(30m*m,1);

       % Der Tangentenwinkel an JOINT beträgt
       % näherungsweise -45° und soll zu -90°=down wandern
       % TODO: korrekt berechnen!
       phi1 := -45(m+1);

       draw m[aux[BEGIN],seven[BEGIN]]
            .. tension t .. m[aux[LEFT],seven[LEFT]]
            .. tension t .. m[aux[TOP],seven[TOP]]{right}
            .. tension t .. m[aux[JOINT],seven[JOINT]]{dir phi1}
            .. m[aux[MID],seven[MID]]
            .. m[aux[END],seven[END]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 7 -> ()
%

start := standalone("7");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw seven[BEGIN]
        -- seven[LEFT]
        -- seven[JOINT]{down}
        .. seven[MID]
        .. seven[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% 7 -> 8
%

start := transition("7","8");

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       tmppath1 := m[seven[BEGIN],seven[LEFT]]
                   -- seven[LEFT]
                   -- seven[JOINT]{down}
                   .. seven[MID]
                   .. seven[END];

       % der Mittelstrich wächst aus der Mitte der Höhe der Sieben:
       tmp0 := 1/2[ypart(seven[LEFT]),ypart(seven[END])];
       aux[MID]   := ((-infinity,tmp0)--(infinity,tmp0)) intersectionpoint tmppath1;
       aux[LEFT]  := aux[MID] - (0.15u,0);
       aux[RIGHT] := aux[MID] + (0.15u,0);

       draw tmppath1;
       draw m[aux[MID],aux[LEFT]] -- m[aux[MID],aux[RIGHT]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);
       t := 1/f;
       tt := max(t/2,1);

       draw m[seven[END],eight[RIGHT]]
            .. m[seven[MID],eight[LEFT]]
            .. m[seven[MID],eight[MID]]
            .. m[seven[JOINT],eight[R_ARC]]{up}
            .. tension t .. m[seven[LEFT],eight[L_ARC]];
       draw m[aux[LEFT],eight[L_ARC]]{down}
            .. tension tt .. m[aux[MID],eight[MID]]
            .. tension tt .. {down}m[aux[RIGHT],eight[RIGHT]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 8 -> ()
%

start := standalone("8");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw eight[R_ARC]
        .. eight[MID]
        .. eight[LEFT]
        .. eight[BOTTOM]
        .. eight[RIGHT]
        .. eight[MID]
        .. eight[L_ARC]
        .. cycle;
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% 8 -> 9
%

start := transition("8","9");

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       phi1 := -90m*m;

       % Die Acht kippt um 90° nach rechts,
       % aus eight[MID] wird nine[RIGHT] etc.
       % Um zu skalieren, drehen wir daher
       % nine[RIGHT|LEFT|TOP|BOTTOM] um 90° nach links:

       aux[MID]    := nine[RIGHT]  rotatedaround (C,90);
       aux[BOTTOM] := nine[LEFT]   rotatedaround (C,90);
       aux[LEFT]   := nine[TOP]    rotatedaround (C,90);
       aux[RIGHT]  := nine[BOTTOM] rotatedaround (C,90);

       % Wir ändern die Punktreihenfolge, um bei i=830
       % eine geschlossene Schleife zu bekommen:

       tmppath1 := m[eight[LEFT],aux[LEFT]]
                   .. m[eight[BOTTOM],aux[BOTTOM]]
                   .. m[eight[RIGHT],aux[RIGHT]]
                   .. m[eight[MID],aux[MID]]
                   if i < start+fpht:
                      .. m[eight[L_ARC],aux[MID]]
                      .. m[eight[R_ARC],aux[MID]]
                      .. m[eight[MID],aux[MID]]
                   fi
                   .. cycle;

       draw tmppath1 rotatedaround (C,phi1);
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       % Der Endpunkt des Bogens wandert von nine[RIGHT] ausgehend am
       % tatsächlichen Bogen entlang:

       tmppath0 := nine[RIGHT]{down} .. nine[END];
       aux[END] := point m of tmppath0;

       draw nine[RIGHT]{down}
            .. nine[BOTTOM]
            .. nine[LEFT]
            .. nine[TOP]
            .. nine[RIGHT]{down}
            .. aux[END];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% 9 -> ()
%

start := standalone("9");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw nine[RIGHT]{down}
        .. nine[BOTTOM]
        .. nine[LEFT]
        .. nine[TOP]
        .. nine[RIGHT]{down}
        .. nine[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% 9 -> 0
%

start := transition("9","0");

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       % Der Bogen der Neun soll beim Aufwickeln ein bisschen
       % nach links gestreckt werden:

       q := -2m*m+2m+1; % durchläuft 1 .. 3/2 .. 1 für x = 0 .. 0.5 .. 1;
       aux[END] := m[nine[END],nine[LEFT]] xscaled q;

       % wir legen einen Hilfspunkt dort an, wo der untere Bogen die
       % y-Achse schneidet. Steigt der y-Wert des Hilfspunktes über
       % die Unterkante der geschlossenen Schleife, wird als y-Koordinate
       % die Unterkante der Schleife gewählt, um zu verhindern, dass
       % der Bogen beim "Aufwickeln" ins Innere der geschlossenen Schleife
       % ragt.

       tmppath0 := nine[RIGHT]{down} .. aux[END];
       aux0 := ((0,-infinity)--(0,infinity)) intersectionpoint tmppath0;
       tmp0 := ypart(aux0);
       tmp1 := ypart(nine[BOTTOM]);
       aux[MID] := (0,min(tmp0,tmp1));

       draw nine[RIGHT]{down}
            .. nine[BOTTOM]
            .. nine[LEFT]
            .. nine[TOP]
            .. nine[RIGHT]{down}
            .. aux[MID]
            .. aux[END];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw zero[TOP]
            .. m[nine[RIGHT],zero[RIGHT]]
            .. zero[BOTTOM]
            .. m[nine[LEFT],zero[LEFT]]
            .. cycle;
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Part II: Interpunktion
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% ":"
colon[TOP]    := (0,0.7u);
colon[BOTTOM] := (0,0.15u);

aux[TOP] := (0,0.475u);
aux[BOTTOM] := (0,0.375u);

%
%%%%%%%%%%%% Interpunktion/Übergänge
%

start := standalone(":");
beginfig(start);
   draw_grid(u);
   pickup pc;
   
   draw colon[TOP];
   draw colon[BOTTOM];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;


start := transition(":",":");
beginfig(start);
   draw tmppic;
endfig;

%
% ":" -> ":"
%
for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       
       draw m[colon[TOP],aux[TOP]];
       draw m[colon[BOTTOM],aux[BOTTOM]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);
       
       draw m[aux[TOP],colon[TOP]];
       draw m[aux[BOTTOM],colon[BOTTOM]];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Part III: Buchstaben
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% a
_a_[BEGIN]  = (-0.25u,0.6u);
_a_[TOP]    = zero[TOP];
_a_[R_ARC]  = (0.275u,0.6u);
_a_[JOINT]  = (0.275u,0.15u);
_a_[END]    = (0.325u,0);
_a_[L_ARC]  = _a_[JOINT] xscaled -1;
_a_[BOTTOM] = zero[BOTTOM];

% b
_b_[BEGIN]  = _p_[BEGIN] shifted (0,0.5u);
_b_[END]    = _p_[END] shifted (0,0.65u);
_b_[U_ARC]  = _p_[U_ARC];
_b_[D_ARC]  = _p_[D_ARC];
_b_[TOP]    = _p_[TOP];
_b_[BOTTOM] = _p_[BOTTOM];
_b_[RIGHT]  = _p_[RIGHT];

% c
_c_[LEFT]   = six[LEFT];
_c_[RIGHT]  = six[RIGHT];
_c_[TOP]    = six[TOP];
_c_[BOTTOM] = six[BOTTOM];
% Schnittpunkt zwischen o-Bogen und einer Halbgeraden
_c_[BEGIN] = (_c_[RIGHT]{up} .. _c_[TOP]{left})
             intersectionpoint 
             (((0,0) -- (infinity,0)) rotated 35 shifted C);
_c_[END]   = (_c_[RIGHT]{down} .. _c_[BOTTOM]{left})
             intersectionpoint 
             (((0,0) -- (infinity,0)) rotated -35 shifted C);

% d
_d_[BEGIN]  = _b_[BEGIN] xscaled -1;
_d_[END]    = _b_[END] xscaled -1;
_d_[U_ARC]  = _b_[U_ARC] xscaled -1;
_d_[D_ARC]  = _b_[D_ARC] xscaled -1;
_d_[TOP]    = _b_[TOP] xscaled -1;
_d_[BOTTOM] = _b_[BOTTOM] xscaled -1;
_d_[LEFT]  = _b_[RIGHT] xscaled -1;

% e
_e_[LEFT]   = _c_[LEFT];
_e_[RIGHT]  = _c_[RIGHT];
_e_[TOP]    = _c_[TOP];
_e_[BOTTOM] = _c_[BOTTOM];
_e_[END]    = _c_[END];

% f
_f_[BEGIN]  = (-0.15u,0);
_f_[MID]    = (-0.15u,1.2u);
_f_[TOP]    = (0, 1.35u);
_f_[END]    = _f_[TOP] rotatedaround
              ((xpart(_f_[TOP]),ypart(_f_[MID])),-45);

_f_[LEFT]   = (-0.25u,0.85u);
_f_[RIGHT]  = (-0.05u,0.85u);

% g
_g_[TOP]    = (0,0.85u);
_g_[LEFT]   = (-0.325u,0.5u);
% 0.15u höher als Nulllinie, daher ist die Mitte bei
% 0.15u+1/2(0.85u-0.15u) = 0.5u
_g_[RIGHT]  = (0.325u,0.5u);
_g_[BOTTOM] = (0,0.15u);

_g_[BEGIN]  = (0.25u,0.85u); % "Schwänzchen" oben rechts

% _g_[JOINT] wird später definiert
_g_[U_ARC]  = (-0.15u,-0.1u);
_g_[L_ARC]  = (-0.375u,-0.25u);
_g_[R_ARC]  = (0.375u,-0.25u);
_g_[D_ARC]  = (0,-0.55u);
_g_[END]    = (0.15u,-0.1u);

% h
tmp0 := 0.275;
tmp1 := 0.85;
_h_[BEGIN] = (-tmp0*u,1.35u);
_h_[LEFT]  = (-tmp0*u,3/4*tmp1*u);
_h_[BOTTOM] = (-tmp0*u,0);
_h_[MID]   = (0,tmp1*u);
_h_[RIGHT] = _h_[LEFT] xscaled -1;
_h_[END]   = _h_[BOTTOM] xscaled -1;

% i
_i_[TOP]    = (0,0.85u);
_i_[BEGIN]  = (0,0.6u);
_i_[END]    = (0,0);

% j
_j_[TOP]    = (0.15u, 0.85u);
_j_[BEGIN]  = (0.15u,0.6u);
_j_[MID]    = (0.15u,-0.5u);
_j_[BOTTOM] = (0,-0.65u);
_j_[END]    = _j_[BOTTOM] rotatedaround
              ((xpart(_j_[BOTTOM]),ypart(_j_[MID])),-45);

% k
_k_[BEGIN]  = (-0.25u,1.35u);
_k_[END]    = (-0.25u,0);
_k_[MID]    = (-0.25u,0.425u);
_k_[TOP]    = (0.25u,0.85u);
_k_[BOTTOM] = (0.25u,0);

% l
_l_[BEGIN]  = (-0.15u,1.35u);
_l_[MID]    = (-0.15u,0.15u);
_l_[BOTTOM] = (0,0);
_l_[END]    = _l_[BOTTOM] rotatedaround
              ((xpart(_l_[BOTTOM]),ypart(_l_[MID])),45);

% m
tmp0 := 0.375;
tmp1 := 0.85;
_m_[BEGIN] = (-tmp0*u,tmp1*u);
_m_[LEFT]  = (-tmp0*u,3/4*tmp1*u);
_m_[BOTTOM] = (-tmp0*u,0);
_m_[L_ARC] = (-.5tmp0*u,tmp1*u);
_m_[JOINT] = (0,0.65u);
_m_[MID]   = (0,0);
_m_[R_ARC] = _m_[L_ARC] xscaled -1;
_m_[RIGHT] = _m_[LEFT] xscaled -1;
_m_[END]   = _m_[BOTTOM] xscaled -1;

% n
tmp0 := 0.275;
tmp1 := 0.85;
_n_[BEGIN] = (-tmp0*u,tmp1*u);
_n_[LEFT]  = (-tmp0*u,3/4*tmp1*u);
_n_[BOTTOM] = (-tmp0*u,0);
_n_[MID]   = (0,tmp1*u);
_n_[RIGHT] = _n_[LEFT] xscaled -1;
_n_[END]   = _n_[BOTTOM] xscaled -1;

% o
_o_[LEFT]   = _c_[LEFT];
_o_[RIGHT]  = _c_[RIGHT];
_o_[TOP]    = _c_[TOP];
_o_[BOTTOM] = _c_[BOTTOM];

% p
_p_[BEGIN]  = (-0.325u,0.85u);
_p_[END]    = (-0.325u,-0.65u);
_p_[U_ARC]  = (-0.325u,0.6u); % [u]pper end of [arc]
_p_[D_ARC]  = (-0.325u,0.15u);
_p_[TOP]    = zero[TOP];
_p_[BOTTOM] = zero[BOTTOM];
_p_[RIGHT]  = (0.325u,0.425u);

% q
_q_[BEGIN]  = _p_[BEGIN] xscaled -1;
_q_[END]    = _p_[END] xscaled -1;
_q_[U_ARC]  = _p_[U_ARC] xscaled -1;
_q_[D_ARC]  = _p_[D_ARC] xscaled -1;
_q_[TOP]    = zero[TOP];
_q_[BOTTOM] = zero[BOTTOM];
_q_[LEFT]   = _p_[RIGHT] xscaled -1;

% r
_r_[BEGIN]  = (-0.15u,0.85u);
_r_[BOTTOM] = (-0.15u,0);
_r_[MID]    = (-0.15u,0.6u);
_r_[TOP]    = (0,0.85u);
_r_[END]    = _r_[TOP] rotatedaround
              ((xpart(_r_[TOP]),ypart(_r_[MID])),-45);

% s
_s_[BEGIN]  = (0.25u,0.6375u);
_s_[TOP]    = _o_[TOP];
_s_[U_ARC]  = _s_[BEGIN] xscaled -1;
_s_[MID]    = C;
_s_[D_ARC]  = (0.3u,0.2125u);
_s_[BOTTOM] = _o_[BOTTOM];
_s_[END]    = (-0.3u,0.2125u);

% t
_t_[LEFT]   = _f_[LEFT];
_t_[RIGHT]  = _f_[RIGHT]; 

_t_[BEGIN]  = _l_[BEGIN];
_t_[MID]    = _l_[MID];
_t_[BOTTOM] = _l_[BOTTOM];
_t_[END]    = _l_[END];

% u
_u_[BOTTOM] = _n_[BEGIN]  rotatedaround(C,180);
_u_[RIGHT]  = _n_[LEFT]   rotatedaround(C,180);
_u_[BEGIN]  = _n_[END]    rotatedaround(C,180);
_u_[MID]    = _n_[MID]    rotatedaround(C,180);
_u_[LEFT]   = _n_[RIGHT]  rotatedaround(C,180);
_u_[END]    = _n_[BOTTOM] rotatedaround(C,180);

% v
_v_[LEFT] = (-0.275u,0.85u);
_v_[BOTTOM] = (0,0);
_v_[RIGHT] = _v_[LEFT] xscaled -1;

% w
tmp0 := 0.375;
tmp1 := 0.85;
_w_[BEGIN] = _m_[BEGIN];
_w_[LEFT]  = (1/2*xpart(_w_[BEGIN]),0);
_w_[MID]   = (0,0.85u);
_w_[RIGHT] = _w_[LEFT] xscaled -1;
_w_[END] = _w_[BEGIN] xscaled -1;

% x
_x_[LEFT]  = (-0.275u,0.85u);
_x_[RIGHT] = _x_[LEFT] xscaled -1;
_x_[BEGIN] = (-0.275u,0);
_x_[END]   = _x_[BEGIN] xscaled -1 ;

% y
_y_[BOTTOM] = _u_[BOTTOM];
_y_[D_ARC] = (-0.25u,-0.65u);
_y_[RIGHT]  = _u_[RIGHT];
_y_[BEGIN] = _u_[BEGIN];
_y_[MID] = _u_[MID];
_y_[LEFT] = _u_[LEFT];
_y_[END] = _u_[END];

% z
_z_[BEGIN] = _x_[LEFT];
_z_[U_ARC] = _x_[RIGHT];
_z_[D_ARC] = _x_[BEGIN];
_z_[END]   = _x_[END];

%
%%%%%%%%%%%% Buchstaben/Übergänge
%

%
% a -> ()
%

tmppath1 := _a_[BEGIN]
            ..  _a_[TOP]
            ..  _a_[R_ARC]
            --- _a_[JOINT]
            .. _a_[END];
aux0 := direction 2 of tmppath1;
phi[R_ARC] := angle(aux0);

tmppath2 := _a_[R_ARC]{dir phi[R_ARC]}
            .. _a_[L_ARC]
            .. _a_[BOTTOM]
            .. _a_[JOINT];
% Der Schnitpunkt von a-"Bauch" und y-Achse wird
% beim Übergang p -> a benötigt:
_a_[MID] := tmppath2 intersectionpoint ((0,0.01u)--(0,infinity));

start := standalone("a");
  
beginfig(start);
   draw_grid(u);
   pickup pc;

   draw tmppath1;
   draw tmppath2;
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% a -> e
%

start := transition("a","e");

beginfig(start);
   draw tmppic;
endfig;

%
% a -> m
%

start := transition("a","m");

beginfig(start);
   draw tmppic;
endfig;

%
% a -> p
%

start := transition("a","p");

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       % Der Startpunkt vom "a" wandert nach links
       aux[BEGIN] := (xpart(m[_a_[BEGIN],_p_[END]]),ypart(_a_[BEGIN]));
       % Der "Bauch" wird im ersten Drittel der Frames eingezogen,
       % damit die Linie vorbeilaufen kann, ohne ihn zu berühren.

       tmp0 := min(3m,1);
       aux[L_ARC] := _a_[L_ARC] xscaled (1-(2/5)*tmp0);

       tmppath1 := m[aux[BEGIN],_p_[END]]
                   ..  aux[BEGIN]{up}
                   ..  _a_[TOP]
                   ..  _a_[R_ARC]
                   --- _a_[JOINT]
                   ..  _a_[END];
       draw  subpath (0,5-m) of tmppath1;
       draw _a_[R_ARC]{dir phi[R_ARC]}
            .. aux[L_ARC]
            .. _a_[BOTTOM]
            .. _a_[JOINT];
       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Wir brauchen den Winkel am unteren Ansatz des p-Bogens:
tmppath0 := _p_[D_ARC]
            .. _p_[BOTTOM]
            .. _p_[RIGHT]
            .. _p_[TOP]
            .. _p_[U_ARC];
aux0 := direction 0 of tmppath0;
phi[D_ARC] := angle(aux0);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       aux[BEGIN] := (xpart(_p_[END]),ypart(_a_[BEGIN]));
       aux[L_ARC] := _a_[L_ARC] xscaled 3/5;

       % Der Ansatzpunkt wandert am p-Bogen entlang bis zum
       % unteren Ansatz am senkrechten Stamm:
       tmppath1   := _p_[D_ARC]
                     --  m[aux[BEGIN],_p_[U_ARC]]
                     ..  _a_[TOP]
                     ..  m[_a_[R_ARC],_p_[RIGHT]]
                     --- m[_a_[JOINT],_p_[RIGHT]];
       aux[R_ARC] := point 3-3m of tmppath1;     

       % Ein Hilfspfad beschreibt den Weg von aux[L_ARC] -> _a_[BOTTOM]
       tmppath2    := aux[L_ARC] .. _a_[BOTTOM]{right};
       aux[BOTTOM] := point m of tmppath2;

       draw _p_[END] -- m[aux[BEGIN],_p_[BEGIN]];
       draw tmppath1;
       % Während der Ansatzpunkt wandert, verändert sich der Winkel:
       draw aux[R_ARC]{dir m[phi[R_ARC],phi[D_ARC]]}
            .. aux[BOTTOM]
            .. _a_[BOTTOM]
            .. m[_a_[JOINT],_p_[RIGHT]]{up};
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% a -> s
%

start := transition("a","s");

beginfig(start);
   draw tmppic;
endfig;

tmppath1 := _a_[BEGIN]
            ..  _a_[TOP]
            ..  _a_[R_ARC]
            --- _a_[JOINT]
            .. _a_[END];
aux0 := direction 2 of tmppath1;
phi[R_ARC] := angle(aux0);

tmppath2 := _a_[R_ARC]{dir phi[R_ARC]}
            .. _a_[L_ARC]
            .. _a_[BOTTOM]
            .. _a_[JOINT];

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       
       draw subpath (0,4-2m) of tmppath1;
       draw tmppath2;
       
       setbounds currentpicture to boundingpath;
    endfig;
endfor

% der Winkel am a-"Bauch":
aux1 := direction 1 of tmppath2;
phi[L_ARC] := angle(aux1);
% der Winkel am "Joint":
aux2 := direction 3 of tmppath2;
phi[JOINT] := angle(aux2);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       % Hilfspfad; wir benötigen den Winkel beim Punkt _a_[JOINT], 
       tmppath3 := m[_a_[L_ARC],_s_[END]]{dir m[phi[L_ARC],-90]}
                   .. _a_[BOTTOM]
                   .. m[_a_[JOINT],_s_[D_ARC]]
                   .. _s_[MID]
                   .. _s_[U_ARC]{up};
       % dieser Winkel soll 90 = up nicht überschreiten:
       phi[JOINT] := min(angle(direction 2 of tmppath3),90);

       % Der komplette Pfad, bestehend aus dem Rest von a und einem vollständigen s:
       tmppath4 := m[_a_[BEGIN],_s_[U_ARC]]
                   .. _a_[TOP]
                   .. _a_[R_ARC]{dir phi[R_ARC]}
                   .. m[_a_[L_ARC],_s_[END]]{dir m[phi[L_ARC],-90]}
                      % Übergang vom ursprünglichen Winkel zu -90 = down
                   .. _a_[BOTTOM]
                   .. m[_a_[JOINT],_s_[D_ARC]]{dir phi[JOINT]}
                   .. _s_[MID]
                   .. _s_[U_ARC]{up}
                   .. _s_[TOP]
                   .. _s_[BEGIN]{down};

       draw subpath (3m,5+4m) of tmppath4;         
       
       setbounds currentpicture to boundingpath;
    endfig;
endfor


%
% a -> u
%

start := transition("a","u");

beginfig(start);
   draw tmppic;
endfig;

%
% b -> ()
%

start := standalone("b");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _b_[BEGIN] -- _b_[END];
   draw _b_[U_ARC]
        .. _b_[TOP]
        .. _b_[RIGHT]
        .. _b_[BOTTOM]
        .. _b_[D_ARC];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% b -> r
%

start := transition("b","r");

beginfig(start);
   draw tmppic;
endfig;

%
% c -> ()
%

start := standalone("c");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _c_[BEGIN]
        .. _c_[TOP]
        .. _c_[LEFT]
        .. _c_[BOTTOM]
        .. _c_[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% c -> n
%

start := transition("c","n");

beginfig(start);
   draw tmppic;
endfig;

%
% c -> o
%

start := transition("c","o");

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       
       aux[BEGIN] := (_c_[BOTTOM]{right} .. _c_[RIGHT]{up} .. _c_[TOP]{left})
              intersectionpoint 
              (((0,0) -- (infinity,0)) rotated (35-90m) shifted C);
       aux[END]   := (_c_[RIGHT]{down} .. _c_[BOTTOM]{left} .. _c_[LEFT]{up})
              intersectionpoint 
              (((0,0) -- (infinity,0)) rotated (-35-90m) shifted C);

       draw aux[END]
            if (-35-90m > -90): .. _c_[BOTTOM]{left} fi
            .. _c_[LEFT]{up}
            .. _c_[TOP]{right}
            if (35-90m < 0): .. _c_[RIGHT]{down} fi
            .. aux[BEGIN];
       
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       tmppath0 := _c_[BOTTOM] .. _c_[LEFT] .. _c_[TOP] .. _c_[RIGHT] .. cycle;
  
       % Wir wollen unten eine abgerundete Kurve, daher funktioniert der oben
       % stehende Ansatz hier nicht.
       draw tmppath0 cutafter  (((0,0) -- (infinity,0)) rotated  (35*(1-m)-90) shifted C)
                     cutbefore (((0,0) -- (infinity,0)) rotated (-35*(1-m)-90) shifted C);
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% d -> ()
%

start := standalone("d");

%
% d -> j
%

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _d_[BEGIN] -- _d_[END];
   draw _d_[U_ARC]
        .. _d_[TOP]
        .. _d_[LEFT]
        .. _d_[BOTTOM]
        .. _d_[D_ARC];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

start := transition("d","j");

beginfig(start);
   draw tmppic;
endfig;

%
% d -> u
%

start := transition("d","u");

beginfig(start);
   draw tmppic;
endfig;

%
% e -> ()
%

start := standalone("e");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _e_[LEFT]
        -- _e_[RIGHT]{up}
        .. _e_[TOP]
        .. _e_[LEFT]
        .. _e_[BOTTOM]
        .. _e_[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% e -> a
%

start := transition("e","a");

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       
       aux[END] := (m[_e_[RIGHT],zero[RIGHT]]{down} .. _e_[BOTTOM]{left})
                   intersectionpoint 
                   (((0,0) -- (infinity,0)) rotated -35 shifted C);
       
       tmppath0 := m[_e_[LEFT],zero[LEFT]]
                   -- m[_e_[RIGHT],zero[RIGHT]]{up}
                   .. _e_[TOP]
                   .. m[_e_[LEFT],zero[LEFT]]
                   .. _e_[BOTTOM]
                   .. aux[END];
       
       draw tmppath0 rotatedaround (C,180m);
       
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       %TODO

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% e -> c
%

start := transition("e","c");

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       
       draw m[_e_[LEFT],_e_[RIGHT]]
        -- _e_[RIGHT]{up}
        .. _e_[TOP]
        .. _e_[LEFT]
        .. _e_[BOTTOM]
        .. _e_[END];
       
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       tmppath0 := _e_[RIGHT]{up}
                   .. _c_[BEGIN]
                   .. _e_[TOP]
                   .. _e_[LEFT]
                   .. _e_[BOTTOM]
                   .. _e_[END];
                   
       draw subpath (m,5) of tmppath0;

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% e -> d
%

start := transition("e","d");

beginfig(start);
   draw tmppic;
endfig;

%
% e -> h
%

start := transition("e","h");

beginfig(start);
   draw tmppic;
endfig;

%
% f -> ()
%

tmppath0 :=  _f_[BEGIN]
             -- _f_[MID]{up}
             .. _f_[TOP]
             .. _f_[END];
% Wir brauchen den Winkel an der Spitze für den Übergang f -> s
phi[BEGIN] := angle(direction 0 of tmppath0); 

start := standalone("f");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _f_[LEFT] -- _f_[RIGHT];   
   draw tmppath0;
   
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% f -> m
%

start := transition("f","m");

beginfig(start);
   draw tmppic;
endfig;

%
% f -> s
%

start := transition("f","s");

beginfig(start);
   draw tmppic;
endfig;

% Wir schieben das f in die Mitte und stauchen es
aux[LEFT]  := C shifted (-0.1u,0); % halbe Breite des f-Strichs: 0.1u
aux[RIGHT] := C shifted(0.1u,0);

aux[END]   := _f_[END] shifted (0.15u,-0.5u); % 1.35u (f-Höhe)-0.85u (s-Höhe)
aux[TOP]   := _f_[TOP] shifted (0.15u,-0.5u);
aux[MID]   := _f_[MID] shifted (0.15u,-0.5u);
aux[BEGIN] := _f_[BEGIN] shifted (0.15u,0);

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       
       draw m[_f_[LEFT],aux[LEFT]]
            -- m[_f_[RIGHT],aux[RIGHT]];

       draw m[_f_[BEGIN],aux[BEGIN]]
            -- m[_f_[MID],aux[MID]]{up}
            .. m[_f_[TOP],aux[TOP]]
            .. m[_f_[END],aux[END]];
       
       setbounds currentpicture to boundingpath;
    endfig;
endfor

aux[D_ARC] := 1/2[_s_[MID],_s_[BOTTOM]];

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);
       
       t := 1/sqrt(m);
       
       draw m[aux[LEFT],C]
            -- m[aux[RIGHT],C];

       draw m[aux[END],_s_[BEGIN]]{dir (m*m)[phi[BEGIN],90]}
            .. m[aux[TOP],_s_[TOP]]
            .. (m*m)[aux[MID],_s_[U_ARC]]{down}
            %.. tension t
            .. _s_[MID]
            %.. tension t
            .. (m*m)[aux[D_ARC],_s_[D_ARC]]{down}
            .. tension t
            .. _s_[BOTTOM]
            .. (1*m)[aux[BEGIN],_s_[END]]{up};
       
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% g -> ()
%

start := standalone("g");

beginfig(start);
   draw_grid(u);
   pickup pc;
   
   draw _g_[BEGIN] -- _g_[TOP];
   
   tmppath0 := _g_[TOP]
               .. _g_[LEFT]
               .. _g_[BOTTOM]
               .. _g_[RIGHT]
               .. cycle;
   aux[MID] := (0,0.5[ypart(_g_[TOP]),ypart(_g_[BOTTOM])]);
   tmppath1 := (aux[MID] -- (0,infinity)) rotatedaround (aux[MID],135);
   
   _g_[JOINT] := tmppath0 intersectionpoint tmppath1;
   (tmp[JOINT], whatever) = tmppath0 intersectiontimes tmppath1;
   phi[JOINT] := angle(direction tmp[JOINT] of tmppath0);
    
   draw tmppath0;
   
   draw _g_[JOINT]{dir phi[JOINT]}
        .. _g_[U_ARC]
        .. _g_[L_ARC]
        .. _g_[D_ARC]
        .. _g_[R_ARC]
        .. _g_[END];

   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% g -> p
%

start := transition("g","p");

beginfig(start);
   draw tmppic;
endfig;

% Wir ziehen die beiden Bogenpunkte zur Senkrechten durch _g_[LEFT]:
aux[U_ARC] := (xpart(_g_[LEFT]),ypart(_g_[U_ARC]));
aux[L_ARC] := (xpart(_g_[LEFT]),ypart(_g_[L_ARC]));
% Der untere Teil des Bogens wandert nach unten:
aux[D_ARC] := (xpart(_g_[D_ARC]),ypart(_p_[END]));

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       
       draw _g_[BEGIN] -- _g_[TOP];
   
       % Der Schnittpunkt _g_[JOINT] wandert an der Rundung entlang Richtung _g_[LEFT]
       % und ist am Ende deckungsgleich:
       tmppath1 := (aux[MID] -- (0,infinity)) rotatedaround (aux[MID],m[135,90]);
   
       _g_[JOINT] := tmppath0 intersectionpoint tmppath1;
       tmp[JOINT] := xpart(tmppath0 intersectiontimes tmppath1);
       phi[JOINT] := angle(direction tmp[JOINT] of tmppath0);
    
       draw tmppath0;
   
       draw _g_[JOINT]{dir phi[JOINT]}
            .. m[_g_[U_ARC],aux[U_ARC]]
            .. m[_g_[L_ARC],aux[L_ARC]]
            .. _g_[D_ARC]
            .. _g_[R_ARC]
            .. _g_[END];
       
       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Die Hilfspunkte aux[U_ARC] und aux[L_ARC] wandern zur finalen x-Koordinate:
aux[TOP] := (xpart(_p_[END]),ypart(aux[U_ARC]));
aux[MID] := (xpart(_p_[END]),ypart(aux[D_ARC]));


for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       tmppath0 := m[_g_[LEFT],_p_[U_ARC]]
                   .. m[_g_[TOP],_p_[TOP]]
                   .. m[_g_[RIGHT],_p_[RIGHT]]
                   .. m[_g_[BOTTOM],_p_[BOTTOM]]
                   .. m[_g_[LEFT],_p_[D_ARC]];
                   
       tmp0 := xpart(_g_[BEGIN])-xpart(_g_[TOP]);
       tmp1 := ypart(_p_[BEGIN])-ypart(_p_[U_ARC]);
       
       tmppath1 := (0,0)--(m[tmp0,tmp1],0);
       
       draw tmppath1 rotatedabout ((0,0),90*m) shifted point 1-m of tmppath0;
       
       tmppath2 := m[_g_[LEFT],_p_[U_ARC]]
                   -- m[_g_[LEFT],_p_[D_ARC]]
                   .. m[aux[U_ARC],aux[TOP]]
                   .. m[aux[L_ARC],aux[MID]]{down}
                   .. m[_g_[D_ARC],_p_[END]]
                   .. m[_g_[R_ARC],_g_[D_ARC]]
                   .. m[_g_[END],_g_[R_ARC]];
        
       draw tmppath0;            
       draw subpath (0,6-2m) of tmppath2;
      
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% h -> ()
%

start := standalone("h");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _h_[BEGIN] -- _h_[LEFT];
   draw _h_[BOTTOM]
        -- _h_[LEFT]
        .. _h_[MID]
        .. _h_[RIGHT]
        -- _h_[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
%
% h -> r
%

start := transition("h","r");

beginfig(start);
   draw tmppic;
endfig;

%
% i -> ()
%

start := standalone("i");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _i_[TOP];
   draw _i_[BEGIN]
        -- _i_[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
   
endfig;
%
% i -> t
%

start := transition("i","t");

beginfig(start);
   draw tmppic;
endfig;

aux[MID]    := (0,0.15u);
aux[BOTTOM] := _t_[BOTTOM] shifted (0.15u,0);
aux[END]    := _t_[END] shifted (0.15u,0);

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       
       draw _i_[TOP];
       draw _i_[BEGIN]
            -- m[_i_[END],aux[MID]]{down}
            .. m[_i_[END],aux[BOTTOM]]
            .. m[_i_[END],aux[END]];
       
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[_i_[TOP],_t_[LEFT]]
            -- m[_i_[TOP],_t_[RIGHT]];
       draw m[_i_[BEGIN],_t_[BEGIN]]
            -- m[aux[MID],_t_[MID]]{down}
            .. m[aux[BOTTOM],_t_[BOTTOM]]
            .. m[aux[END],_t_[END]];

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% j -> ()
%

start := standalone("j");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _j_[TOP];
   draw _j_[BEGIN]
        -- _j_[MID]
        .. _j_[BOTTOM]
        .. _j_[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% j -> a
%

start := transition("j","a");

beginfig(start);
   draw tmppic;
endfig;

%
% j -> f
%

start := transition("j","f");

beginfig(start);
   draw tmppic;
endfig;

% Der j-Bogen wandert weiter in den f-Bogen hinein
% der Hilfspunkt aux[JOINT] verbindet j und f

aux[JOINT] := (xpart(_f_[BEGIN]),ypart(_j_[MID]));

tmppath0 := _j_[BEGIN]
            -- _j_[MID]{down}
            .. _j_[BOTTOM]
            .. _j_[END]
            .. aux[JOINT]
            -- _f_[BEGIN]
            -- _f_[MID]{up}
            .. _f_[TOP]
            .. _f_[END];

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       
       draw _j_[TOP];
                     
       draw subpath (0,5m+4) of tmppath0;
       
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw m[_j_[TOP],_f_[LEFT]]
            -- m[_j_[TOP],_f_[RIGHT]];
            
       draw subpath (5m,8) of tmppath0;

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% j -> j
%

start := transition("j","j");

beginfig(start);
   draw tmppic;
endfig;

%
% k -> ()
%

beginfig(standalone("k"));
   draw_grid(u);
   pickup pc;

   draw _k_[BEGIN]
        -- _k_[END];
        
   draw _k_[TOP]
        -- _k_[MID]
        -- 4/3[_k_[MID],_k_[BOTTOM]];
   setbounds currentpicture to boundingpath;
endfig;

%
% l -> ()
%

start := standalone("l");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _l_[BEGIN]
        -- _l_[MID]{down}
        .. _l_[BOTTOM]
        .. _l_[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% l - > g
%

start := transition("l","g");

beginfig(start);
   draw tmppic;
endfig;

%
% m -> ()
%

start := standalone("m");

beginfig(start);
draw_grid(u);
   pickup pc;

   draw _m_[BEGIN] -- _m_[LEFT];
   draw _m_[BOTTOM]
        -- _m_[LEFT]{up}
        .. _m_[L_ARC]
        .. _m_[JOINT]{down}
     &  _m_[JOINT]{up}
        .. _m_[R_ARC]
        .. _m_[RIGHT]{down}
        -- _m_[END];
   draw _m_[MID] -- _m_[JOINT];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% m -> a
% 

start := transition("m","a");

beginfig(start);
draw tmppic;
endfig;

%
% m -> j
%

start := transition("m","j");

beginfig(start);
   draw tmppic;
endfig;

%
% m -> m
%

start := transition("m","m");

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/(2fpht);
       m := f;
       
       aux[BEGIN] := _m_[BEGIN] yshifted (wiggle(xpart(_m_[BEGIN])/u,f)*u);
       aux[LEFT]  := _m_[LEFT]  yshifted (wiggle(xpart(_m_[LEFT] )/u,f)*u);
       aux[JOINT] := _m_[JOINT] yshifted (wiggle(xpart(_m_[JOINT])/u,f)*u);
       aux[RIGHT] := _m_[RIGHT] yshifted (wiggle(xpart(_m_[RIGHT])/u,f)*u);
       aux[L_ARC] := _m_[L_ARC] yshifted (wiggle(xpart(_m_[L_ARC])/u,f)*u);
       aux[R_ARC] := _m_[R_ARC] yshifted (wiggle(xpart(_m_[R_ARC])/u,f)*u);
       
       draw aux[BEGIN] -- aux[LEFT];
       draw _m_[BOTTOM]
            -- aux[LEFT]{up}
            .. aux[L_ARC]
            .. aux[JOINT]{down}
         &  aux[JOINT]{up}
            .. aux[R_ARC]
            .. aux[RIGHT]{down}
            -- _m_[END];
       draw _m_[MID] -- aux[JOINT];
    setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% m -> t
%

start := transition("m","t");

beginfig(start);
   draw tmppic;
endfig;

%
% n -> ()
%

start := standalone("n");

beginfig(start);
draw_grid(u);
   pickup pc;

   draw _n_[BEGIN] -- _n_[LEFT];
   draw _n_[BOTTOM]
        -- _n_[LEFT]{up}
        .. _n_[MID]
        .. _n_[RIGHT]{down}
        --_n_[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% n -> b
%

start := transition("n","b");

beginfig(start);
draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       
       draw m[_n_[BEGIN],_b_[BEGIN]] 
            .. _n_[LEFT]
            .. m[_n_[BOTTOM],_b_[END]];
       draw _n_[LEFT]
            .. _n_[MID]
            .. _n_[RIGHT]
            --_n_[END];
       
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);
       t := 2-m;

       draw _b_[BEGIN] 
            .. m[_n_[LEFT],_b_[U_ARC]]
            .. _b_[END];

       draw m[_n_[LEFT],_b_[U_ARC]]
           .. m[_n_[MID],_b_[TOP]]
           .. m[_n_[RIGHT],_b_[RIGHT]]
           .. tension t .. m[_n_[END],_b_[RIGHT]]{down}
           .. m[_n_[END],_b_[BOTTOM]]
           .. m[_n_[END],_b_[D_ARC]];

       setbounds currentpicture to boundingpath;
    endfig;
endfor


%
% n -> d
%

start := transition("n","d");

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       
       draw m[_n_[BEGIN],_n_[LEFT]] 
            -- _n_[LEFT];
        
       draw _n_[BOTTOM]
            -- _n_[LEFT]{up}
            .. _n_[MID]
            .. _n_[RIGHT]{down}
            -- _n_[END];
            
       draw (xpart(_n_[RIGHT]),m[ypart(_n_[RIGHT]),ypart(_d_[BEGIN])])
            -- _n_[RIGHT];
       
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);
       t := 2-m;

       

       setbounds currentpicture to boundingpath;
    endfig;
endfor

% TODO: der Stiel schrumpft und wächst gleichzeitig rechts nach oben (gespiegeltes h),
% dann klappt der Bogen um.

%
% n -> e
%

start := transition("n","e");

beginfig(start);
   draw tmppic;
endfig;

%
% n -> l
%

start := transition("n","l");

beginfig(start);
   draw tmppic;
endfig;

aux[BEGIN]  := (xpart(_l_[BEGIN]),ypart(_n_[BEGIN]));
aux[BOTTOM] := (xpart(_l_[BEGIN]),ypart(_n_[BOTTOM]));
aux[LEFT]   := (xpart(_l_[BEGIN]),ypart(_n_[LEFT]));
aux[RIGHT]  := aux[LEFT] xscaled -1;
aux[END]    := aux[BOTTOM] xscaled -1;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       
       draw m[_n_[BEGIN],aux[BEGIN]]
            -- m[_n_[LEFT],aux[LEFT]];
       draw m[_n_[BOTTOM],aux[BOTTOM]]
            -- m[_n_[LEFT],aux[LEFT]]{up}
            .. _n_[MID]
            .. m[_n_[RIGHT],aux[RIGHT]]{down}
            -- m[_n_[END],aux[END]];
       
       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Wir suchen den Punkt auf halbem Weg zwischen
% aux[LEFT] und _n_[MID]:
tmppath0 := aux[BOTTOM]
            -- aux[LEFT]{up}
            .. _n_[MID]
            .. aux[RIGHT]{down}
            -- aux[END];

aux[L_ARC] := point 1.5 of tmppath0;

% Wir lassen den Startpunkt weg und bauen den Hilfspunkt ein:
tmppath1 := aux[LEFT]{up}
            .. aux[L_ARC]
            .. _n_[MID]
            .. aux[RIGHT]{down}
            -- aux[END];

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);
       
       % der n-Stamm wandert schnell zum Start von l ...
       draw (aux[BEGIN] -- aux[BOTTOM]) 
            shifted (min(2m,1)[aux[BEGIN],_l_[BEGIN]]-aux[BEGIN]);
       % während sich der Rest im Bogen verkürzt und
       % um 180° dreht – am Ende überlagern sich beide
       % geraden Abschnitte teilweise und bilden den
       % l-Strich:
       draw (subpath (m,4) of tmppath1) rotatedaround (C,-180m);

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% n -> n
%

start := transition("n","n");

beginfig(start);
   draw tmppic;
endfig;

%
% o -> ()
%

start := standalone("o");

beginfig(start);
draw_grid(u);
   pickup pc;

   draw _o_[TOP]
        .. _o_[RIGHT]
        .. _o_[BOTTOM]
        .. _o_[LEFT]
        .. cycle;
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% o -> e
%

start := transition("o","e");

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       
       draw _o_[TOP]
            .. _o_[RIGHT]
            .. _o_[BOTTOM]
            .. _o_[LEFT]
            .. cycle;
            
       draw _o_[RIGHT]
            -- m[_o_[RIGHT],_o_[LEFT]];
       
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       draw _e_[LEFT]
            -- _e_[RIGHT]{up}
            .. _e_[TOP]
            .. _e_[LEFT]
            .. _e_[BOTTOM]
            .. m[_e_[RIGHT],_e_[END]];

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% o -> n
%

start := transition("o","n");

beginfig(start);
   draw tmppic;
endfig;

%
% o -> u
%

start := transition("o","u");

beginfig(start);
   draw tmppic;
endfig;

%
% p -> ()
%

start := standalone("p");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _p_[BEGIN] -- _p_[END];
   draw _p_[U_ARC]
        .. _p_[TOP]
        .. _p_[RIGHT]
        .. _p_[BOTTOM]
        .. _p_[D_ARC];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% p -> a
%

start := transition("p","a");

beginfig(start);
   draw tmppic;
endfig;

% Wir brauchen den Winkel am unteren Ansatz des p-Bogens:
tmppath0 := _p_[D_ARC]
            .. _p_[BOTTOM]
            .. _p_[RIGHT]
            .. _p_[TOP]
            .. _p_[U_ARC];
aux0 := direction 0 of tmppath0;
phi[D_ARC] := angle(aux0);

% der Winkel im a-Bogen
tmppath1 := _a_[BEGIN]
            ..  _a_[TOP]
            ..  _a_[R_ARC]
            --- _a_[JOINT]
            .. _a_[END];
aux0 := direction 2 of tmppath1;
phi[R_ARC] := angle(aux0);

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       phi0 := 180m;

       % nach einer Vierteldrehung hat der p-Strich bereits die
       % gewünschte Länge:
       tmp1 := min(2m,1);

       aux[END] := (xpart(_p_[END]),0);

       tmppath1 := _p_[BEGIN]
                   -- tmp1[_p_[END],aux[END]];
       tmppath2 := _p_[U_ARC]
                   .. _p_[TOP]
                   .. _p_[RIGHT]
                   .. _p_[BOTTOM]
                   .. _p_[D_ARC];

       draw tmppath1 rotatedaround (C,phi0);
       draw tmppath2 rotatedaround (C,phi0);
       setbounds currentpicture to boundingpath;
    endfig;
endfor

aux[MID]    := _p_[D_ARC]  rotatedaround (C,180);
aux[BEGIN]  := aux[END]    rotatedaround (C,180);
aux[R_ARC]  := _p_[U_ARC]  rotatedaround (C,180);
aux[JOINT]  := _p_[BEGIN]  rotatedaround (C,180);
aux[L_ARC]  := _p_[RIGHT]  rotatedaround (C,180);
aux[BOTTOM] := _p_[TOP]    rotatedaround (C,180);
aux[TOP]    := _p_[BOTTOM] rotatedaround (C,180);

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);
       t := 10m+1;

       % phi[D_ARC] ist der Winkel am unteren Bogenansatz des P
       % und muss daher um 180° gedreht werden;
       % phi[R_ARC] ist der Winkel am Ansatzpunkt vom "a" (s.o.)
       phi0 := m[phi[D_ARC]-180,phi[R_ARC]];

       % der gedrehte und verkürzte p-"Stamm" wird zum oberen Bogen:
       tmppath1 := m[aux[JOINT],_a_[END]]
                   .. m[aux[JOINT],_a_[JOINT]]{up} % up/tension/up entspricht ---
                   .. tension t .. m[aux[R_ARC],_a_[R_ARC]]{up}
                   .. m[aux[MID],_a_[TOP]]
                   .. m[aux[BEGIN],_a_[BEGIN]];

       % der gedrehte p-Bogen wird zum a-"Bauch":
       tmppath2 := m[aux[MID],_a_[R_ARC]]{dir phi0}
                   .. m[aux[TOP],_a_[MID]]
                   .. m[aux[L_ARC],_a_[L_ARC]]
                   .. m[aux[BOTTOM],_a_[BOTTOM]]
                   .. m[aux[R_ARC],_a_[JOINT]];

       % die beiden Pfade überschneiden sich am Anfang sichtbar, daher
       % kürzen wir den "Bauch"-Pfad
       % [durch die Verwendung von "-numbersystem=double" ist die
       % Berechnung der intersectiontime z.T. fehlerhaft; die erste
       % Koordinate scheint korrekt zu sein, die zweite falsch.
       aux0 := tmppath2 intersectiontimes tmppath1;
       
       draw tmppath1;
       draw subpath (xpart(aux0),4) of tmppath2;
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% p -> t
%

start := transition("p","t");

beginfig(start);
   draw tmppic;
endfig;

% Der Beginn des t-Bogens
aux[MID]    := _p_[END] shifted (0,0.15u);
aux[BOTTOM] := _p_[END] shifted (0.15u,0);
aux[END]    := aux[BOTTOM] rotatedabout ((xpart(aux[BOTTOM]),ypart(aux[MID])),45);

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       
       % Der Bogen bildet sich zuerst nur bis zur Vierteldrehung aus
       draw _p_[BEGIN]
       -- aux[MID]{down}
       .. m[_p_[END],aux[BOTTOM]];
       
       draw _p_[U_ARC]
            .. _p_[TOP]
            .. _p_[RIGHT]
            .. _p_[BOTTOM]
            .. _p_[D_ARC];
             
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);

       tmppath0 := m[_p_[BEGIN],_t_[BEGIN]]
                   -- m[aux[MID],_t_[MID]]{down}
                   .. m[aux[BOTTOM],_t_[BOTTOM]]
                   .. m[aux[END],_t_[END]];
                   
       tmppath1 := m[_p_[U_ARC],_t_[LEFT]]
                   .. m[_p_[TOP],_t_[RIGHT]]{right}
                   .. _p_[RIGHT]
                   .. _p_[BOTTOM]
                   .. _p_[D_ARC];

       draw subpath (0,2+m) of tmppath0;
       draw subpath (0,4-3m) of tmppath1;

       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% q -> ()
%

start := standalone("q");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _q_[BEGIN] -- _q_[END];
   draw _q_[U_ARC]
        .. _q_[TOP]
        .. _q_[LEFT]
        .. _q_[BOTTOM]
        .. _q_[D_ARC];
   setbounds currentpicture to boundingpath;
endfig;

%
% r -> ()
%

start := standalone("r");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _r_[BEGIN] -- _r_[BOTTOM];
   draw _r_[MID]{up}
        .. _r_[TOP]
        .. _r_[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% r -> a
%

start := transition("r","a");

beginfig(start);
   draw tmppic;
endfig;

%
% r -> r 
%

start := transition("r","r");

beginfig(start);
   draw tmppic;
endfig;

%
% r -> t
%

start := transition("r","t");

beginfig(start);
   draw tmppic;
endfig;

%
% s -> ()
%

start := standalone("s");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _s_[BEGIN]{up}
        .. _s_[TOP]
        .. _s_[U_ARC]{down}
        .. _s_[MID]
        .. _s_[D_ARC]{down}
        .. _s_[BOTTOM]
        .. _s_[END]{up};
   
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% s -> m
%

start := transition("s","m");

beginfig(start);
   draw tmppic;
endfig;

%
% s -> o
%

start := transition("s","o");

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       
       draw m[_s_[BEGIN],_o_[RIGHT]]{up}
            .. _s_[TOP]
            .. m[_s_[U_ARC],_o_[LEFT]]{down}
            .. _s_[MID]
            .. m[_s_[D_ARC],_o_[RIGHT]]{down}
            .. _s_[BOTTOM]
            .. m[_s_[END],_o_[LEFT]]{up};
       
       setbounds currentpicture to boundingpath;
    endfig;
endfor

tmppath0 := _o_[RIGHT]{up}
            .. _s_[TOP]
            .. _o_[LEFT]{down}
            .. _s_[MID]
            .. _o_[RIGHT]{down}
            .. _s_[BOTTOM]
            .. _o_[LEFT]{up};

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);
       
       draw subpath (0,3-m) of tmppath0;
       draw subpath (3+m,6) of tmppath0;
              
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% s -> s
%

start := transition("s","s");

beginfig(start);
   draw tmppic;
endfig;

%
% t -> ()
%

start := standalone("t");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _t_[LEFT] -- _t_[RIGHT];
   
   draw _t_[BEGIN]
        -- _t_[MID]{down}
        .. _t_[BOTTOM]
        .. _t_[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% t -> f
%

start := transition ("t","f");

beginfig(start);
   draw tmppic;
endfig;

% Rotationszentrum
aux[MID]   := (xpart(_l_[BOTTOM]),ypart(_l_[MID]));
% Die Hilfspunkte für den geschlossenen Kreis,
% jeweils als Verlängerung durch das Rotationszentrum
% des Bogens
aux[RIGHT] := 2[_t_[MID],aux[MID]];
aux[TOP]   := 2[_t_[BOTTOM],aux[MID]];

tmppath0 := _t_[MID]
            .. _t_[BOTTOM]
            .. _t_[END]
            .. aux[RIGHT]
            .. aux[TOP]
            .. cycle;

tmppath1 := _t_[LEFT] -- _t_[RIGHT];

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       % Der t-Stamm wird oben verkürzt, um für
       % den f-Bogen Platz zu machen:
       
       draw min(2m,1)[_t_[BEGIN],_f_[MID]]
            -- _t_[MID];
       
       % Der untere Bogen wird zum Kreis aufgerollt (min(2m,1))
       % und danach bis zum Strich bewegt (max(2m-1,0)):
       
       tmp0 := max(2m-1,0)*(ypart(_t_[LEFT])-ypart(_t_[MID]));
       draw (subpath (0,3*min(2m,1)+2) of tmppath0) shifted (0,tmp0);
       
       % Der Querstrich wandert nach links, um den Kreis vorbeizulassen:

       tmp1 := max(2m-1,0)*(xpart(_t_[LEFT])-xpart(_t_[MID]));
       draw tmppath1 shifted (tmp1,0);
       
       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Andere Rotationsrichtung, zusätzlicher Hilfspunkt
aux[U_ARC] := _t_[BOTTOM] rotatedabout (aux[MID],135);
tmppath0 := _t_[MID]
            .. aux[TOP]
            .. aux[U_ARC]
            .. aux[RIGHT]
            .. _t_[BOTTOM]
            .. cycle;

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);
       
       % der Stamm wird nun nach unten verlängert:
       draw _f_[MID]
            -- max(2m-1,0)[_t_[MID],_f_[BEGIN]];
            
       % der Kreis wandert weiter und entrollt sich wieder
       tmp0 := min(2m,1)[ypart(_t_[LEFT]),ypart(_f_[MID])]-ypart(_t_[MID]);
       draw (subpath (0,5-3*max(2m-1,0)) of tmppath0) shifted (0,tmp0);
       
       % Der Querstrich wandert wieder zurück:

       tmp1 := min(2(1-m),1)*(xpart(_t_[LEFT])-xpart(_t_[MID]));
       draw tmppath1 shifted (tmp1,0);
       
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% t -> u
%

start := transition("t","u");

beginfig(start);
   draw tmppic;
endfig;

% der t-Strich wächst zu einem um 90° gedrehten
% u-Strich:

aux[LEFT]  := (xpart(_u_[END])-ypart(1[_u_[BOTTOM],_u_[END]]),ypart(_t_[LEFT]));
aux[RIGHT] := (xpart(_u_[END]),ypart(_t_[RIGHT]));

% der Schnittpunkt des t-Striches mit dem t-Stamm:
aux[MID]   := (_t_[LEFT] -- _t_[RIGHT])
              intersectionpoint
              (_t_[BEGIN] -- _t_[MID]);

tmppath0 := _t_[BEGIN]
            -- aux[MID]
            -- _t_[MID]{down}
            .. _t_[BOTTOM]
            .. _t_[END];

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);

       % der Strich wird breiter
       draw m[_t_[LEFT],aux[LEFT]]
            -- m[_t_[RIGHT],aux[RIGHT]];
   
       % der t-Stamm schrumpft, bis er bündig mit dem
       % t-Strich liegt:
       draw subpath (m,4) of tmppath0;
       
       setbounds currentpicture to boundingpath;
    endfig;
endfor

% wir brauchen den Hilfspunkt, der auf halbem Weg zwischen
% _u_[MID] und _u_[RIGHT] liegt:

tmppath1 := _u_[BEGIN]
            -- _u_[LEFT]{down}
            .. _u_[MID]
            .. _u_[RIGHT]{up}
            -- _u_[END];
aux[R_ARC] := point 2.5 of tmppath1;

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);
       
       tmppath0 := m[aux[MID],_u_[BEGIN]]
                   -- m[_t_[MID],_u_[LEFT]]{down}
                   .. m[_t_[BOTTOM],_u_[MID]]
                   .. m[_t_[END],aux[R_ARC]]
                   .. m[_t_[MID] xscaled -1,_u_[RIGHT]]{up}
                   -- m[aux[MID] xscaled -1,_u_[END]];
       % rotiere den überdimensionierten t-Strich nach unten:
       draw (aux[LEFT] -- aux[RIGHT]) rotatedaround (aux[RIGHT],90m);
       draw subpath (0,3+2m) of tmppath0;
       
       
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% t -> v
%

start := transition("t","v");

beginfig(start);
   draw tmppic;
endfig;

%
% t -> w
%

start := transition("t","w");

beginfig(start);
   draw tmppic;
endfig;

%
% u -> ()
%

start := standalone("u");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _u_[RIGHT] -- _u_[BOTTOM];
   draw _u_[BEGIN]
        -- _u_[LEFT]{down}
        .. _u_[MID]
        .. _u_[RIGHT]{up}
        -- _u_[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% u -> e
%

start := transition("u","e");

beginfig(start);
   draw tmppic;
endfig;

%
% u -> i
%

start := transition("u","i");

beginfig(start);
   draw tmppic;
endfig;

% Die Enden des u wandern auf i-Höhe
aux[BEGIN] := (xpart(_u_[BEGIN]),ypart(_i_[BEGIN]));
aux[END]   := (xpart(_u_[END]),ypart(_i_[BEGIN]));

% der Querstrich über dem u, der dann zum Punkt
% schrumpft, ist so lang wie der Strich unten rechts:
tmp0 := ypart(_u_[BOTTOM])-ypart(_u_[RIGHT]);
aux[LEFT]  := (-1/2tmp0,ypart(_i_[TOP]));
aux[RIGHT] := (1/2tmp0,ypart(_i_[TOP]));

tmppath0 := aux[LEFT]
            -- aux[RIGHT]
            -- _u_[END]
            -- aux[END];

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       
       % Der Strich wandert aus dem rechten u-Teil
       % heraus und um die Ecke, wo er einen Querstrich bildet:
       draw subpath (2-2m,3-2m) of tmppath0;
       
       % Der rechte Strich verschwindet schneller, daher min(3m,1):
       draw _u_[RIGHT]
             -- min(3m,1)[_u_[BOTTOM],_u_[RIGHT]];

       draw m[_u_[BEGIN],aux[BEGIN]]
            -- _u_[LEFT]{down}
            .. _u_[MID]
            .. _u_[RIGHT]{up}
            -- m[_u_[END],aux[END]];
       
       setbounds currentpicture to boundingpath;
    endfig;
endfor

% Die Punkte _u_[LEFT] und _u_[RIGHT] wandern
% zum i-Stamm:
aux[MID] := 1/2[_u_[LEFT],_u_[RIGHT]];

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);
      
       t := 1/(1-m);
       draw m[aux[LEFT],_i_[TOP]]
            .. m[aux[RIGHT],_i_[TOP]];
            
       draw m[aux[BEGIN],_i_[BEGIN]]
            -- m[_u_[LEFT],aux[MID]]{down}
            ... _u_[MID]
            ... m[_u_[RIGHT],aux[MID]]{up}
            -- m[aux[END],_i_[BEGIN]];
       
       % Bei engen Kurvenverläufen entstehen Artefakte, die wir
       % überdecken (müssen)
       if m > 0.95: draw _i_[BEGIN] -- _i_[END]; fi
              
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% u -> o
%

start := transition("u","o");

beginfig(start);
   draw tmppic;
endfig;

%
% u -> u
%

start := transition("u","u");

beginfig(start);
   draw tmppic;
endfig;

%
% v -> ()
%

start := standalone("v");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _v_[LEFT]
        -- _v_[BOTTOM]
        -- _v_[RIGHT];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% v -> c
%

start := transition("v","c");

beginfig(start);
   draw tmppic;
endfig;

%
% w -> ()
%

start := standalone("w");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _w_[BEGIN]
        -- _w_[LEFT]
        -- _w_[MID]
        -- _w_[RIGHT]
        -- _w_[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;


%
% w -> t
%

start := transition("w","t");

beginfig(start);
   draw tmppic;
endfig;

%
% x -> ()
%

start := standalone("x");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _x_[BEGIN]
        -- _x_[RIGHT];
   draw _x_[LEFT]
        -- 5/4[_x_[LEFT],_x_[END]];
   setbounds currentpicture to boundingpath;
endfig;

%
% y -> ()
%

start := standalone("y");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _y_[RIGHT]
        -- _y_[BOTTOM]{down}
        .. _y_[D_ARC];
   draw _y_[BEGIN]
        -- _y_[LEFT]
        .. _y_[MID]
        .. _y_[RIGHT]
        -- _y_[END];
   setbounds currentpicture to boundingpath;
   tmppic := currentpicture;
endfig;

%
% y -> n
%

start := transition("y","n");

beginfig(start);
   draw tmppic;
endfig;

for i = start+1 upto start+fpht:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start)/fpht;
       m := retarded(f);
       
       tmppath0 := _y_[D_ARC]
                   .. _y_[BOTTOM]{up}
                   -- _y_[RIGHT];
                   
       draw subpath (m,2) of tmppath0;
       
       draw _y_[BEGIN]
        -- _y_[LEFT]{down}
        .. _y_[MID]
        .. _y_[RIGHT]{up}
        -- _y_[END];
       
       setbounds currentpicture to boundingpath;
    endfig;
endfor

for i = start+fpht+1 upto start+2fpht-1:
    beginfig(i);
       draw_grid(u);
       pickup pc;

       f := (i-start-fpht)/fpht;
       m := advanced(f);
       
       tmppath0 := _y_[RIGHT] -- _y_[BOTTOM];
       tmppath1 := _y_[BEGIN]
                   -- _y_[LEFT]{down}
                   .. _y_[MID]
                   .. _y_[RIGHT]{up}
                   -- _y_[END];
                    
       draw tmppath0 rotatedabout (C,180m);
       draw tmppath1 rotatedabout (C,180m);
       
       setbounds currentpicture to boundingpath;
    endfig;
endfor

%
% z -> ()
%

start := standalone("z");

beginfig(start);
   draw_grid(u);
   pickup pc;

   draw _z_[BEGIN]
        -- _z_[U_ARC]
        -- _z_[D_ARC]
        -- _z_[END];
   setbounds currentpicture to boundingpath;
endfig;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Part VI: Uhrsymbol im "o"
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

outputtemplate := "clock-%c.mps";

tmppath0 := _o_[TOP]
            .. _o_[RIGHT]
            .. _o_[BOTTOM]
            .. _o_[LEFT]
            .. cycle;

for i = 0 upto 719:
    beginfig(i);
       draw_grid(u);
       pickup pc;
            
       % Zeiger: wir ermitteln die Schnittpunkte der o-Linie
       % mit den Zeiger-Halbgeraden, die in C ansetzen:
       tmppath1 := C -- (0,infinity) rotatedaround (C,-i*6);
       tmppath2 := C -- (0,infinity) rotatedaround (C,-i/2);
       
       aux1 := tmppath0 intersectionpoint tmppath1;
       aux2 := tmppath0 intersectionpoint tmppath2;
       
       % anschließend werden die Zeiger skaliert:
       % der Minutenzeiger ist länger,
       % der Stundenzeiger kürzer.
       draw tmppath0;
       
       pickup pc scaled 2;
       undraw C -- 4/3[C,aux1];
       
       pickup pc;
       draw 4/3[C,aux1]
            -- C
            -- 2/3[C,aux2];
       
       setbounds currentpicture to boundingpath;
    endfig;
endfor

end;
